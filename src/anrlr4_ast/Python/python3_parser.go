// Code generated from Python3Parser.g4 by ANTLR 4.9. DO NOT EDIT.

package parser // Python3Parser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa


var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 101, 1106, 
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13, 
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9, 
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23, 
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4, 
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34, 
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9, 
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44, 
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4, 
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55, 
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9, 
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65, 
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4, 
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76, 
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9, 
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86, 
	4, 87, 9, 87, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 180, 10, 2, 3, 3, 3, 
	3, 7, 3, 184, 10, 3, 12, 3, 14, 3, 187, 11, 3, 3, 3, 3, 3, 3, 4, 3, 4, 
	7, 4, 193, 10, 4, 12, 4, 14, 4, 196, 11, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 
	5, 3, 5, 5, 5, 204, 10, 5, 3, 5, 5, 5, 207, 10, 5, 3, 5, 3, 5, 3, 6, 6, 
	6, 212, 10, 6, 13, 6, 14, 6, 213, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 220, 10, 
	7, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 230, 10, 9, 3, 
	9, 3, 9, 3, 9, 3, 10, 3, 10, 5, 10, 237, 10, 10, 3, 10, 3, 10, 3, 11, 3, 
	11, 3, 11, 5, 11, 244, 10, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 250, 
	10, 11, 7, 11, 252, 10, 11, 12, 11, 14, 11, 255, 11, 11, 3, 11, 3, 11, 
	3, 11, 5, 11, 260, 10, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 266, 10, 
	11, 7, 11, 268, 10, 11, 12, 11, 14, 11, 271, 11, 11, 3, 11, 3, 11, 3, 11, 
	3, 11, 5, 11, 277, 10, 11, 5, 11, 279, 10, 11, 5, 11, 281, 10, 11, 3, 11, 
	3, 11, 3, 11, 5, 11, 286, 10, 11, 5, 11, 288, 10, 11, 5, 11, 290, 10, 11, 
	3, 11, 3, 11, 5, 11, 294, 10, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 300, 
	10, 11, 7, 11, 302, 10, 11, 12, 11, 14, 11, 305, 11, 11, 3, 11, 3, 11, 
	3, 11, 3, 11, 5, 11, 311, 10, 11, 5, 11, 313, 10, 11, 5, 11, 315, 10, 11, 
	3, 11, 3, 11, 3, 11, 5, 11, 320, 10, 11, 5, 11, 322, 10, 11, 3, 12, 3, 
	12, 3, 12, 5, 12, 327, 10, 12, 3, 13, 3, 13, 3, 13, 5, 13, 332, 10, 13, 
	3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 338, 10, 13, 7, 13, 340, 10, 13, 12, 
	13, 14, 13, 343, 11, 13, 3, 13, 3, 13, 3, 13, 5, 13, 348, 10, 13, 3, 13, 
	3, 13, 3, 13, 3, 13, 5, 13, 354, 10, 13, 7, 13, 356, 10, 13, 12, 13, 14, 
	13, 359, 11, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 365, 10, 13, 5, 13, 
	367, 10, 13, 5, 13, 369, 10, 13, 3, 13, 3, 13, 3, 13, 5, 13, 374, 10, 13, 
	5, 13, 376, 10, 13, 5, 13, 378, 10, 13, 3, 13, 3, 13, 5, 13, 382, 10, 13, 
	3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 388, 10, 13, 7, 13, 390, 10, 13, 12, 
	13, 14, 13, 393, 11, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 399, 10, 13, 
	5, 13, 401, 10, 13, 5, 13, 403, 10, 13, 3, 13, 3, 13, 3, 13, 5, 13, 408, 
	10, 13, 5, 13, 410, 10, 13, 3, 14, 3, 14, 3, 15, 3, 15, 5, 15, 416, 10, 
	15, 3, 16, 3, 16, 3, 16, 7, 16, 421, 10, 16, 12, 16, 14, 16, 424, 11, 16, 
	3, 16, 5, 16, 427, 10, 16, 3, 16, 3, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3, 
	17, 3, 17, 3, 17, 3, 17, 5, 17, 439, 10, 17, 3, 18, 3, 18, 3, 18, 3, 18, 
	3, 18, 5, 18, 446, 10, 18, 3, 18, 3, 18, 3, 18, 5, 18, 451, 10, 18, 7, 
	18, 453, 10, 18, 12, 18, 14, 18, 456, 11, 18, 5, 18, 458, 10, 18, 3, 19, 
	3, 19, 3, 19, 3, 19, 5, 19, 464, 10, 19, 3, 20, 3, 20, 5, 20, 468, 10, 
	20, 3, 20, 3, 20, 3, 20, 5, 20, 473, 10, 20, 7, 20, 475, 10, 20, 12, 20, 
	14, 20, 478, 11, 20, 3, 20, 5, 20, 481, 10, 20, 3, 21, 3, 21, 3, 22, 3, 
	22, 3, 22, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 495, 
	10, 24, 3, 25, 3, 25, 3, 26, 3, 26, 3, 27, 3, 27, 5, 27, 503, 10, 27, 3, 
	28, 3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 511, 10, 29, 5, 29, 513, 
	10, 29, 3, 30, 3, 30, 5, 30, 517, 10, 30, 3, 31, 3, 31, 3, 31, 3, 32, 3, 
	32, 7, 32, 524, 10, 32, 12, 32, 14, 32, 527, 11, 32, 3, 32, 3, 32, 6, 32, 
	531, 10, 32, 13, 32, 14, 32, 532, 5, 32, 535, 10, 32, 3, 32, 3, 32, 3, 
	32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 544, 10, 32, 3, 33, 3, 33, 3, 33, 
	5, 33, 549, 10, 33, 3, 34, 3, 34, 3, 34, 5, 34, 554, 10, 34, 3, 35, 3, 
	35, 3, 35, 7, 35, 559, 10, 35, 12, 35, 14, 35, 562, 11, 35, 3, 35, 5, 35, 
	565, 10, 35, 3, 36, 3, 36, 3, 36, 7, 36, 570, 10, 36, 12, 36, 14, 36, 573, 
	11, 36, 3, 37, 3, 37, 3, 37, 7, 37, 578, 10, 37, 12, 37, 14, 37, 581, 11, 
	37, 3, 38, 3, 38, 3, 38, 3, 38, 7, 38, 587, 10, 38, 12, 38, 14, 38, 590, 
	11, 38, 3, 39, 3, 39, 3, 39, 3, 39, 7, 39, 596, 10, 39, 12, 39, 14, 39, 
	599, 11, 39, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 605, 10, 40, 3, 41, 3, 
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 616, 10, 41, 
	3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 622, 10, 42, 3, 43, 3, 43, 3, 43, 3, 
	43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 633, 10, 43, 12, 43, 14, 
	43, 636, 11, 43, 3, 43, 3, 43, 3, 43, 5, 43, 641, 10, 43, 3, 44, 3, 44, 
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 650, 10, 44, 3, 45, 3, 45, 3, 
	45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 661, 10, 45, 3, 46, 
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 6, 46, 670, 10, 46, 13, 46, 14, 
	46, 671, 3, 46, 3, 46, 3, 46, 5, 46, 677, 10, 46, 3, 46, 3, 46, 3, 46, 
	5, 46, 682, 10, 46, 3, 46, 3, 46, 3, 46, 5, 46, 687, 10, 46, 3, 47, 3, 
	47, 3, 47, 3, 47, 7, 47, 693, 10, 47, 12, 47, 14, 47, 696, 11, 47, 3, 47, 
	3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 5, 48, 704, 10, 48, 3, 49, 3, 49, 3, 
	49, 3, 49, 5, 49, 710, 10, 49, 5, 49, 712, 10, 49, 3, 50, 3, 50, 3, 50, 
	3, 50, 6, 50, 718, 10, 50, 13, 50, 14, 50, 719, 3, 50, 3, 50, 5, 50, 724, 
	10, 50, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 732, 10, 51, 3, 
	51, 5, 51, 735, 10, 51, 3, 52, 3, 52, 5, 52, 739, 10, 52, 3, 53, 3, 53, 
	5, 53, 743, 10, 53, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 5, 54, 750, 10, 
	54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 7, 55, 758, 10, 55, 12, 55, 
	14, 55, 761, 11, 55, 3, 56, 3, 56, 3, 56, 7, 56, 766, 10, 56, 12, 56, 14, 
	56, 769, 11, 56, 3, 57, 3, 57, 3, 57, 5, 57, 774, 10, 57, 3, 58, 3, 58, 
	3, 58, 3, 58, 7, 58, 780, 10, 58, 12, 58, 14, 58, 783, 11, 58, 3, 59, 3, 
	59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 
	3, 59, 5, 59, 798, 10, 59, 3, 60, 3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 7, 
	61, 806, 10, 61, 12, 61, 14, 61, 809, 11, 61, 3, 62, 3, 62, 3, 62, 7, 62, 
	814, 10, 62, 12, 62, 14, 62, 817, 11, 62, 3, 63, 3, 63, 3, 63, 7, 63, 822, 
	10, 63, 12, 63, 14, 63, 825, 11, 63, 3, 64, 3, 64, 3, 64, 7, 64, 830, 10, 
	64, 12, 64, 14, 64, 833, 11, 64, 3, 65, 3, 65, 3, 65, 7, 65, 838, 10, 65, 
	12, 65, 14, 65, 841, 11, 65, 3, 66, 3, 66, 3, 66, 7, 66, 846, 10, 66, 12, 
	66, 14, 66, 849, 11, 66, 3, 67, 3, 67, 3, 67, 5, 67, 854, 10, 67, 3, 68, 
	3, 68, 3, 68, 5, 68, 859, 10, 68, 3, 69, 5, 69, 862, 10, 69, 3, 69, 3, 
	69, 7, 69, 866, 10, 69, 12, 69, 14, 69, 869, 11, 69, 3, 70, 3, 70, 3, 70, 
	5, 70, 874, 10, 70, 3, 70, 3, 70, 3, 70, 5, 70, 879, 10, 70, 3, 70, 3, 
	70, 3, 70, 5, 70, 884, 10, 70, 3, 70, 3, 70, 3, 70, 3, 70, 6, 70, 890, 
	10, 70, 13, 70, 14, 70, 891, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 898, 10, 
	70, 3, 71, 3, 71, 5, 71, 902, 10, 71, 3, 71, 3, 71, 3, 71, 3, 71, 5, 71, 
	908, 10, 71, 7, 71, 910, 10, 71, 12, 71, 14, 71, 913, 11, 71, 3, 71, 5, 
	71, 916, 10, 71, 5, 71, 918, 10, 71, 3, 72, 3, 72, 5, 72, 922, 10, 72, 
	3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 931, 10, 72, 3, 
	73, 3, 73, 3, 73, 7, 73, 936, 10, 73, 12, 73, 14, 73, 939, 11, 73, 3, 73, 
	5, 73, 942, 10, 73, 3, 74, 3, 74, 5, 74, 946, 10, 74, 3, 74, 3, 74, 5, 
	74, 950, 10, 74, 3, 74, 5, 74, 953, 10, 74, 5, 74, 955, 10, 74, 3, 75, 
	3, 75, 5, 75, 959, 10, 75, 3, 76, 3, 76, 5, 76, 963, 10, 76, 3, 76, 3, 
	76, 3, 76, 5, 76, 968, 10, 76, 7, 76, 970, 10, 76, 12, 76, 14, 76, 973, 
	11, 76, 3, 76, 5, 76, 976, 10, 76, 3, 77, 3, 77, 3, 77, 7, 77, 981, 10, 
	77, 12, 77, 14, 77, 984, 11, 77, 3, 77, 5, 77, 987, 10, 77, 3, 78, 3, 78, 
	3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 995, 10, 78, 3, 78, 3, 78, 3, 78, 3, 
	78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 1005, 10, 78, 7, 78, 1007, 10, 78, 
	12, 78, 14, 78, 1010, 11, 78, 3, 78, 5, 78, 1013, 10, 78, 5, 78, 1015, 
	10, 78, 3, 78, 3, 78, 5, 78, 1019, 10, 78, 3, 78, 3, 78, 3, 78, 3, 78, 
	5, 78, 1025, 10, 78, 7, 78, 1027, 10, 78, 12, 78, 14, 78, 1030, 11, 78, 
	3, 78, 5, 78, 1033, 10, 78, 5, 78, 1035, 10, 78, 5, 78, 1037, 10, 78, 3, 
	79, 3, 79, 3, 79, 3, 79, 5, 79, 1043, 10, 79, 3, 79, 5, 79, 1046, 10, 79, 
	3, 79, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 7, 80, 1054, 10, 80, 12, 80, 
	14, 80, 1057, 11, 80, 3, 80, 5, 80, 1060, 10, 80, 3, 81, 3, 81, 5, 81, 
	1064, 10, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 5, 
	81, 1074, 10, 81, 3, 82, 3, 82, 5, 82, 1078, 10, 82, 3, 83, 5, 83, 1081, 
	10, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 5, 83, 1088, 10, 83, 3, 84, 
	3, 84, 3, 84, 5, 84, 1093, 10, 84, 3, 85, 3, 85, 3, 86, 3, 86, 5, 86, 1099, 
	10, 86, 3, 87, 3, 87, 3, 87, 5, 87, 1104, 10, 87, 3, 87, 2, 2, 88, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 
	144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 
	2, 8, 3, 2, 87, 99, 3, 2, 53, 54, 3, 2, 68, 69, 3, 2, 70, 71, 5, 2, 55, 
	55, 72, 74, 85, 85, 4, 2, 70, 71, 75, 75, 2, 1231, 2, 179, 3, 2, 2, 2, 
	4, 185, 3, 2, 2, 2, 6, 190, 3, 2, 2, 2, 8, 199, 3, 2, 2, 2, 10, 211, 3, 
	2, 2, 2, 12, 215, 3, 2, 2, 2, 14, 221, 3, 2, 2, 2, 16, 224, 3, 2, 2, 2, 
	18, 234, 3, 2, 2, 2, 20, 321, 3, 2, 2, 2, 22, 323, 3, 2, 2, 2, 24, 409, 
	3, 2, 2, 2, 26, 411, 3, 2, 2, 2, 28, 415, 3, 2, 2, 2, 30, 417, 3, 2, 2, 
	2, 32, 438, 3, 2, 2, 2, 34, 440, 3, 2, 2, 2, 36, 459, 3, 2, 2, 2, 38, 467, 
	3, 2, 2, 2, 40, 482, 3, 2, 2, 2, 42, 484, 3, 2, 2, 2, 44, 487, 3, 2, 2, 
	2, 46, 494, 3, 2, 2, 2, 48, 496, 3, 2, 2, 2, 50, 498, 3, 2, 2, 2, 52, 500, 
	3, 2, 2, 2, 54, 504, 3, 2, 2, 2, 56, 506, 3, 2, 2, 2, 58, 516, 3, 2, 2, 
	2, 60, 518, 3, 2, 2, 2, 62, 521, 3, 2, 2, 2, 64, 545, 3, 2, 2, 2, 66, 550, 
	3, 2, 2, 2, 68, 555, 3, 2, 2, 2, 70, 566, 3, 2, 2, 2, 72, 574, 3, 2, 2, 
	2, 74, 582, 3, 2, 2, 2, 76, 591, 3, 2, 2, 2, 78, 600, 3, 2, 2, 2, 80, 615, 
	3, 2, 2, 2, 82, 617, 3, 2, 2, 2, 84, 623, 3, 2, 2, 2, 86, 642, 3, 2, 2, 
	2, 88, 651, 3, 2, 2, 2, 90, 662, 3, 2, 2, 2, 92, 688, 3, 2, 2, 2, 94, 700, 
	3, 2, 2, 2, 96, 705, 3, 2, 2, 2, 98, 723, 3, 2, 2, 2, 100, 734, 3, 2, 2, 
	2, 102, 738, 3, 2, 2, 2, 104, 740, 3, 2, 2, 2, 106, 747, 3, 2, 2, 2, 108, 
	754, 3, 2, 2, 2, 110, 762, 3, 2, 2, 2, 112, 773, 3, 2, 2, 2, 114, 775, 
	3, 2, 2, 2, 116, 797, 3, 2, 2, 2, 118, 799, 3, 2, 2, 2, 120, 802, 3, 2, 
	2, 2, 122, 810, 3, 2, 2, 2, 124, 818, 3, 2, 2, 2, 126, 826, 3, 2, 2, 2, 
	128, 834, 3, 2, 2, 2, 130, 842, 3, 2, 2, 2, 132, 853, 3, 2, 2, 2, 134, 
	855, 3, 2, 2, 2, 136, 861, 3, 2, 2, 2, 138, 897, 3, 2, 2, 2, 140, 901, 
	3, 2, 2, 2, 142, 930, 3, 2, 2, 2, 144, 932, 3, 2, 2, 2, 146, 954, 3, 2, 
	2, 2, 148, 956, 3, 2, 2, 2, 150, 962, 3, 2, 2, 2, 152, 977, 3, 2, 2, 2, 
	154, 1036, 3, 2, 2, 2, 156, 1038, 3, 2, 2, 2, 158, 1050, 3, 2, 2, 2, 160, 
	1073, 3, 2, 2, 2, 162, 1077, 3, 2, 2, 2, 164, 1080, 3, 2, 2, 2, 166, 1089, 
	3, 2, 2, 2, 168, 1094, 3, 2, 2, 2, 170, 1096, 3, 2, 2, 2, 172, 1103, 3, 
	2, 2, 2, 174, 180, 7, 43, 2, 2, 175, 180, 5, 30, 16, 2, 176, 177, 5, 80, 
	41, 2, 177, 178, 7, 43, 2, 2, 178, 180, 3, 2, 2, 2, 179, 174, 3, 2, 2, 
	2, 179, 175, 3, 2, 2, 2, 179, 176, 3, 2, 2, 2, 180, 3, 3, 2, 2, 2, 181, 
	184, 7, 43, 2, 2, 182, 184, 5, 28, 15, 2, 183, 181, 3, 2, 2, 2, 183, 182, 
	3, 2, 2, 2, 184, 187, 3, 2, 2, 2, 185, 183, 3, 2, 2, 2, 185, 186, 3, 2, 
	2, 2, 186, 188, 3, 2, 2, 2, 187, 185, 3, 2, 2, 2, 188, 189, 7, 2, 2, 3, 
	189, 5, 3, 2, 2, 2, 190, 194, 5, 152, 77, 2, 191, 193, 7, 43, 2, 2, 192, 
	191, 3, 2, 2, 2, 193, 196, 3, 2, 2, 2, 194, 192, 3, 2, 2, 2, 194, 195, 
	3, 2, 2, 2, 195, 197, 3, 2, 2, 2, 196, 194, 3, 2, 2, 2, 197, 198, 7, 2, 
	2, 3, 198, 7, 3, 2, 2, 2, 199, 200, 7, 85, 2, 2, 200, 206, 5, 72, 37, 2, 
	201, 203, 7, 56, 2, 2, 202, 204, 5, 158, 80, 2, 203, 202, 3, 2, 2, 2, 203, 
	204, 3, 2, 2, 2, 204, 205, 3, 2, 2, 2, 205, 207, 7, 57, 2, 2, 206, 201, 
	3, 2, 2, 2, 206, 207, 3, 2, 2, 2, 207, 208, 3, 2, 2, 2, 208, 209, 7, 43, 
	2, 2, 209, 9, 3, 2, 2, 2, 210, 212, 5, 8, 5, 2, 211, 210, 3, 2, 2, 2, 212, 
	213, 3, 2, 2, 2, 213, 211, 3, 2, 2, 2, 213, 214, 3, 2, 2, 2, 214, 11, 3, 
	2, 2, 2, 215, 219, 5, 10, 6, 2, 216, 220, 5, 156, 79, 2, 217, 220, 5, 16, 
	9, 2, 218, 220, 5, 14, 8, 2, 219, 216, 3, 2, 2, 2, 219, 217, 3, 2, 2, 2, 
	219, 218, 3, 2, 2, 2, 220, 13, 3, 2, 2, 2, 221, 222, 7, 41, 2, 2, 222, 
	223, 5, 16, 9, 2, 223, 15, 3, 2, 2, 2, 224, 225, 7, 8, 2, 2, 225, 226, 
	7, 44, 2, 2, 226, 229, 5, 18, 10, 2, 227, 228, 7, 86, 2, 2, 228, 230, 5, 
	100, 51, 2, 229, 227, 3, 2, 2, 2, 229, 230, 3, 2, 2, 2, 230, 231, 3, 2, 
	2, 2, 231, 232, 7, 59, 2, 2, 232, 233, 5, 98, 50, 2, 233, 17, 3, 2, 2, 
	2, 234, 236, 7, 56, 2, 2, 235, 237, 5, 20, 11, 2, 236, 235, 3, 2, 2, 2, 
	236, 237, 3, 2, 2, 2, 237, 238, 3, 2, 2, 2, 238, 239, 7, 57, 2, 2, 239, 
	19, 3, 2, 2, 2, 240, 243, 5, 22, 12, 2, 241, 242, 7, 62, 2, 2, 242, 244, 
	5, 100, 51, 2, 243, 241, 3, 2, 2, 2, 243, 244, 3, 2, 2, 2, 244, 253, 3, 
	2, 2, 2, 245, 246, 7, 58, 2, 2, 246, 249, 5, 22, 12, 2, 247, 248, 7, 62, 
	2, 2, 248, 250, 5, 100, 51, 2, 249, 247, 3, 2, 2, 2, 249, 250, 3, 2, 2, 
	2, 250, 252, 3, 2, 2, 2, 251, 245, 3, 2, 2, 2, 252, 255, 3, 2, 2, 2, 253, 
	251, 3, 2, 2, 2, 253, 254, 3, 2, 2, 2, 254, 289, 3, 2, 2, 2, 255, 253, 
	3, 2, 2, 2, 256, 287, 7, 58, 2, 2, 257, 259, 7, 55, 2, 2, 258, 260, 5, 
	22, 12, 2, 259, 258, 3, 2, 2, 2, 259, 260, 3, 2, 2, 2, 260, 269, 3, 2, 
	2, 2, 261, 262, 7, 58, 2, 2, 262, 265, 5, 22, 12, 2, 263, 264, 7, 62, 2, 
	2, 264, 266, 5, 100, 51, 2, 265, 263, 3, 2, 2, 2, 265, 266, 3, 2, 2, 2, 
	266, 268, 3, 2, 2, 2, 267, 261, 3, 2, 2, 2, 268, 271, 3, 2, 2, 2, 269, 
	267, 3, 2, 2, 2, 269, 270, 3, 2, 2, 2, 270, 280, 3, 2, 2, 2, 271, 269, 
	3, 2, 2, 2, 272, 278, 7, 58, 2, 2, 273, 274, 7, 61, 2, 2, 274, 276, 5, 
	22, 12, 2, 275, 277, 7, 58, 2, 2, 276, 275, 3, 2, 2, 2, 276, 277, 3, 2, 
	2, 2, 277, 279, 3, 2, 2, 2, 278, 273, 3, 2, 2, 2, 278, 279, 3, 2, 2, 2, 
	279, 281, 3, 2, 2, 2, 280, 272, 3, 2, 2, 2, 280, 281, 3, 2, 2, 2, 281, 
	288, 3, 2, 2, 2, 282, 283, 7, 61, 2, 2, 283, 285, 5, 22, 12, 2, 284, 286, 
	7, 58, 2, 2, 285, 284, 3, 2, 2, 2, 285, 286, 3, 2, 2, 2, 286, 288, 3, 2, 
	2, 2, 287, 257, 3, 2, 2, 2, 287, 282, 3, 2, 2, 2, 287, 288, 3, 2, 2, 2, 
	288, 290, 3, 2, 2, 2, 289, 256, 3, 2, 2, 2, 289, 290, 3, 2, 2, 2, 290, 
	322, 3, 2, 2, 2, 291, 293, 7, 55, 2, 2, 292, 294, 5, 22, 12, 2, 293, 292, 
	3, 2, 2, 2, 293, 294, 3, 2, 2, 2, 294, 303, 3, 2, 2, 2, 295, 296, 7, 58, 
	2, 2, 296, 299, 5, 22, 12, 2, 297, 298, 7, 62, 2, 2, 298, 300, 5, 100, 
	51, 2, 299, 297, 3, 2, 2, 2, 299, 300, 3, 2, 2, 2, 300, 302, 3, 2, 2, 2, 
	301, 295, 3, 2, 2, 2, 302, 305, 3, 2, 2, 2, 303, 301, 3, 2, 2, 2, 303, 
	304, 3, 2, 2, 2, 304, 314, 3, 2, 2, 2, 305, 303, 3, 2, 2, 2, 306, 312, 
	7, 58, 2, 2, 307, 308, 7, 61, 2, 2, 308, 310, 5, 22, 12, 2, 309, 311, 7, 
	58, 2, 2, 310, 309, 3, 2, 2, 2, 310, 311, 3, 2, 2, 2, 311, 313, 3, 2, 2, 
	2, 312, 307, 3, 2, 2, 2, 312, 313, 3, 2, 2, 2, 313, 315, 3, 2, 2, 2, 314, 
	306, 3, 2, 2, 2, 314, 315, 3, 2, 2, 2, 315, 322, 3, 2, 2, 2, 316, 317, 
	7, 61, 2, 2, 317, 319, 5, 22, 12, 2, 318, 320, 7, 58, 2, 2, 319, 318, 3, 
	2, 2, 2, 319, 320, 3, 2, 2, 2, 320, 322, 3, 2, 2, 2, 321, 240, 3, 2, 2, 
	2, 321, 291, 3, 2, 2, 2, 321, 316, 3, 2, 2, 2, 322, 21, 3, 2, 2, 2, 323, 
	326, 7, 44, 2, 2, 324, 325, 7, 59, 2, 2, 325, 327, 5, 100, 51, 2, 326, 
	324, 3, 2, 2, 2, 326, 327, 3, 2, 2, 2, 327, 23, 3, 2, 2, 2, 328, 331, 5, 
	26, 14, 2, 329, 330, 7, 62, 2, 2, 330, 332, 5, 100, 51, 2, 331, 329, 3, 
	2, 2, 2, 331, 332, 3, 2, 2, 2, 332, 341, 3, 2, 2, 2, 333, 334, 7, 58, 2, 
	2, 334, 337, 5, 26, 14, 2, 335, 336, 7, 62, 2, 2, 336, 338, 5, 100, 51, 
	2, 337, 335, 3, 2, 2, 2, 337, 338, 3, 2, 2, 2, 338, 340, 3, 2, 2, 2, 339, 
	333, 3, 2, 2, 2, 340, 343, 3, 2, 2, 2, 341, 339, 3, 2, 2, 2, 341, 342, 
	3, 2, 2, 2, 342, 377, 3, 2, 2, 2, 343, 341, 3, 2, 2, 2, 344, 375, 7, 58, 
	2, 2, 345, 347, 7, 55, 2, 2, 346, 348, 5, 26, 14, 2, 347, 346, 3, 2, 2, 
	2, 347, 348, 3, 2, 2, 2, 348, 357, 3, 2, 2, 2, 349, 350, 7, 58, 2, 2, 350, 
	353, 5, 26, 14, 2, 351, 352, 7, 62, 2, 2, 352, 354, 5, 100, 51, 2, 353, 
	351, 3, 2, 2, 2, 353, 354, 3, 2, 2, 2, 354, 356, 3, 2, 2, 2, 355, 349, 
	3, 2, 2, 2, 356, 359, 3, 2, 2, 2, 357, 355, 3, 2, 2, 2, 357, 358, 3, 2, 
	2, 2, 358, 368, 3, 2, 2, 2, 359, 357, 3, 2, 2, 2, 360, 366, 7, 58, 2, 2, 
	361, 362, 7, 61, 2, 2, 362, 364, 5, 26, 14, 2, 363, 365, 7, 58, 2, 2, 364, 
	363, 3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 367, 3, 2, 2, 2, 366, 361, 
	3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 369, 3, 2, 2, 2, 368, 360, 3, 2, 
	2, 2, 368, 369, 3, 2, 2, 2, 369, 376, 3, 2, 2, 2, 370, 371, 7, 61, 2, 2, 
	371, 373, 5, 26, 14, 2, 372, 374, 7, 58, 2, 2, 373, 372, 3, 2, 2, 2, 373, 
	374, 3, 2, 2, 2, 374, 376, 3, 2, 2, 2, 375, 345, 3, 2, 2, 2, 375, 370, 
	3, 2, 2, 2, 375, 376, 3, 2, 2, 2, 376, 378, 3, 2, 2, 2, 377, 344, 3, 2, 
	2, 2, 377, 378, 3, 2, 2, 2, 378, 410, 3, 2, 2, 2, 379, 381, 7, 55, 2, 2, 
	380, 382, 5, 26, 14, 2, 381, 380, 3, 2, 2, 2, 381, 382, 3, 2, 2, 2, 382, 
	391, 3, 2, 2, 2, 383, 384, 7, 58, 2, 2, 384, 387, 5, 26, 14, 2, 385, 386, 
	7, 62, 2, 2, 386, 388, 5, 100, 51, 2, 387, 385, 3, 2, 2, 2, 387, 388, 3, 
	2, 2, 2, 388, 390, 3, 2, 2, 2, 389, 383, 3, 2, 2, 2, 390, 393, 3, 2, 2, 
	2, 391, 389, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 402, 3, 2, 2, 2, 393, 
	391, 3, 2, 2, 2, 394, 400, 7, 58, 2, 2, 395, 396, 7, 61, 2, 2, 396, 398, 
	5, 26, 14, 2, 397, 399, 7, 58, 2, 2, 398, 397, 3, 2, 2, 2, 398, 399, 3, 
	2, 2, 2, 399, 401, 3, 2, 2, 2, 400, 395, 3, 2, 2, 2, 400, 401, 3, 2, 2, 
	2, 401, 403, 3, 2, 2, 2, 402, 394, 3, 2, 2, 2, 402, 403, 3, 2, 2, 2, 403, 
	410, 3, 2, 2, 2, 404, 405, 7, 61, 2, 2, 405, 407, 5, 26, 14, 2, 406, 408, 
	7, 58, 2, 2, 407, 406, 3, 2, 2, 2, 407, 408, 3, 2, 2, 2, 408, 410, 3, 2, 
	2, 2, 409, 328, 3, 2, 2, 2, 409, 379, 3, 2, 2, 2, 409, 404, 3, 2, 2, 2, 
	410, 25, 3, 2, 2, 2, 411, 412, 7, 44, 2, 2, 412, 27, 3, 2, 2, 2, 413, 416, 
	5, 30, 16, 2, 414, 416, 5, 80, 41, 2, 415, 413, 3, 2, 2, 2, 415, 414, 3, 
	2, 2, 2, 416, 29, 3, 2, 2, 2, 417, 422, 5, 32, 17, 2, 418, 419, 7, 60, 
	2, 2, 419, 421, 5, 32, 17, 2, 420, 418, 3, 2, 2, 2, 421, 424, 3, 2, 2, 
	2, 422, 420, 3, 2, 2, 2, 422, 423, 3, 2, 2, 2, 423, 426, 3, 2, 2, 2, 424, 
	422, 3, 2, 2, 2, 425, 427, 7, 60, 2, 2, 426, 425, 3, 2, 2, 2, 426, 427, 
	3, 2, 2, 2, 427, 428, 3, 2, 2, 2, 428, 429, 7, 43, 2, 2, 429, 31, 3, 2, 
	2, 2, 430, 439, 5, 34, 18, 2, 431, 439, 5, 42, 22, 2, 432, 439, 5, 44, 
	23, 2, 433, 439, 5, 46, 24, 2, 434, 439, 5, 58, 30, 2, 435, 439, 5, 74, 
	38, 2, 436, 439, 5, 76, 39, 2, 437, 439, 5, 78, 40, 2, 438, 430, 3, 2, 
	2, 2, 438, 431, 3, 2, 2, 2, 438, 432, 3, 2, 2, 2, 438, 433, 3, 2, 2, 2, 
	438, 434, 3, 2, 2, 2, 438, 435, 3, 2, 2, 2, 438, 436, 3, 2, 2, 2, 438, 
	437, 3, 2, 2, 2, 439, 33, 3, 2, 2, 2, 440, 457, 5, 38, 20, 2, 441, 458, 
	5, 36, 19, 2, 442, 445, 5, 40, 21, 2, 443, 446, 5, 170, 86, 2, 444, 446, 
	5, 152, 77, 2, 445, 443, 3, 2, 2, 2, 445, 444, 3, 2, 2, 2, 446, 458, 3, 
	2, 2, 2, 447, 450, 7, 62, 2, 2, 448, 451, 5, 170, 86, 2, 449, 451, 5, 38, 
	20, 2, 450, 448, 3, 2, 2, 2, 450, 449, 3, 2, 2, 2, 451, 453, 3, 2, 2, 2, 
	452, 447, 3, 2, 2, 2, 453, 456, 3, 2, 2, 2, 454, 452, 3, 2, 2, 2, 454, 
	455, 3, 2, 2, 2, 455, 458, 3, 2, 2, 2, 456, 454, 3, 2, 2, 2, 457, 441, 
	3, 2, 2, 2, 457, 442, 3, 2, 2, 2, 457, 454, 3, 2, 2, 2, 458, 35, 3, 2, 
	2, 2, 459, 460, 7, 59, 2, 2, 460, 463, 5, 100, 51, 2, 461, 462, 7, 62, 
	2, 2, 462, 464, 5, 100, 51, 2, 463, 461, 3, 2, 2, 2, 463, 464, 3, 2, 2, 
	2, 464, 37, 3, 2, 2, 2, 465, 468, 5, 100, 51, 2, 466, 468, 5, 118, 60, 
	2, 467, 465, 3, 2, 2, 2, 467, 466, 3, 2, 2, 2, 468, 476, 3, 2, 2, 2, 469, 
	472, 7, 58, 2, 2, 470, 473, 5, 100, 51, 2, 471, 473, 5, 118, 60, 2, 472, 
	470, 3, 2, 2, 2, 472, 471, 3, 2, 2, 2, 473, 475, 3, 2, 2, 2, 474, 469, 
	3, 2, 2, 2, 475, 478, 3, 2, 2, 2, 476, 474, 3, 2, 2, 2, 476, 477, 3, 2, 
	2, 2, 477, 480, 3, 2, 2, 2, 478, 476, 3, 2, 2, 2, 479, 481, 7, 58, 2, 2, 
	480, 479, 3, 2, 2, 2, 480, 481, 3, 2, 2, 2, 481, 39, 3, 2, 2, 2, 482, 483, 
	9, 2, 2, 2, 483, 41, 3, 2, 2, 2, 484, 485, 7, 37, 2, 2, 485, 486, 5, 150, 
	76, 2, 486, 43, 3, 2, 2, 2, 487, 488, 7, 38, 2, 2, 488, 45, 3, 2, 2, 2, 
	489, 495, 5, 48, 25, 2, 490, 495, 5, 50, 26, 2, 491, 495, 5, 52, 27, 2, 
	492, 495, 5, 56, 29, 2, 493, 495, 5, 54, 28, 2, 494, 489, 3, 2, 2, 2, 494, 
	490, 3, 2, 2, 2, 494, 491, 3, 2, 2, 2, 494, 492, 3, 2, 2, 2, 494, 493, 
	3, 2, 2, 2, 495, 47, 3, 2, 2, 2, 496, 497, 7, 40, 2, 2, 497, 49, 3, 2, 
	2, 2, 498, 499, 7, 39, 2, 2, 499, 51, 3, 2, 2, 2, 500, 502, 7, 9, 2, 2, 
	501, 503, 5, 152, 77, 2, 502, 501, 3, 2, 2, 2, 502, 503, 3, 2, 2, 2, 503, 
	53, 3, 2, 2, 2, 504, 505, 5, 170, 86, 2, 505, 55, 3, 2, 2, 2, 506, 512, 
	7, 10, 2, 2, 507, 510, 5, 100, 51, 2, 508, 509, 7, 11, 2, 2, 509, 511, 
	5, 100, 51, 2, 510, 508, 3, 2, 2, 2, 510, 511, 3, 2, 2, 2, 511, 513, 3, 
	2, 2, 2, 512, 507, 3, 2, 2, 2, 512, 513, 3, 2, 2, 2, 513, 57, 3, 2, 2, 
	2, 514, 517, 5, 60, 31, 2, 515, 517, 5, 62, 32, 2, 516, 514, 3, 2, 2, 2, 
	516, 515, 3, 2, 2, 2, 517, 59, 3, 2, 2, 2, 518, 519, 7, 12, 2, 2, 519, 
	520, 5, 70, 36, 2, 520, 61, 3, 2, 2, 2, 521, 534, 7, 11, 2, 2, 522, 524, 
	9, 3, 2, 2, 523, 522, 3, 2, 2, 2, 524, 527, 3, 2, 2, 2, 525, 523, 3, 2, 
	2, 2, 525, 526, 3, 2, 2, 2, 526, 528, 3, 2, 2, 2, 527, 525, 3, 2, 2, 2, 
	528, 535, 5, 72, 37, 2, 529, 531, 9, 3, 2, 2, 530, 529, 3, 2, 2, 2, 531, 
	532, 3, 2, 2, 2, 532, 530, 3, 2, 2, 2, 532, 533, 3, 2, 2, 2, 533, 535, 
	3, 2, 2, 2, 534, 525, 3, 2, 2, 2, 534, 530, 3, 2, 2, 2, 535, 536, 3, 2, 
	2, 2, 536, 543, 7, 12, 2, 2, 537, 544, 7, 55, 2, 2, 538, 539, 7, 56, 2, 
	2, 539, 540, 5, 68, 35, 2, 540, 541, 7, 57, 2, 2, 541, 544, 3, 2, 2, 2, 
	542, 544, 5, 68, 35, 2, 543, 537, 3, 2, 2, 2, 543, 538, 3, 2, 2, 2, 543, 
	542, 3, 2, 2, 2, 544, 63, 3, 2, 2, 2, 545, 548, 7, 44, 2, 2, 546, 547, 
	7, 13, 2, 2, 547, 549, 7, 44, 2, 2, 548, 546, 3, 2, 2, 2, 548, 549, 3, 
	2, 2, 2, 549, 65, 3, 2, 2, 2, 550, 553, 5, 72, 37, 2, 551, 552, 7, 13, 
	2, 2, 552, 554, 7, 44, 2, 2, 553, 551, 3, 2, 2, 2, 553, 554, 3, 2, 2, 2, 
	554, 67, 3, 2, 2, 2, 555, 560, 5, 64, 33, 2, 556, 557, 7, 58, 2, 2, 557, 
	559, 5, 64, 33, 2, 558, 556, 3, 2, 2, 2, 559, 562, 3, 2, 2, 2, 560, 558, 
	3, 2, 2, 2, 560, 561, 3, 2, 2, 2, 561, 564, 3, 2, 2, 2, 562, 560, 3, 2, 
	2, 2, 563, 565, 7, 58, 2, 2, 564, 563, 3, 2, 2, 2, 564, 565, 3, 2, 2, 2, 
	565, 69, 3, 2, 2, 2, 566, 571, 5, 66, 34, 2, 567, 568, 7, 58, 2, 2, 568, 
	570, 5, 66, 34, 2, 569, 567, 3, 2, 2, 2, 570, 573, 3, 2, 2, 2, 571, 569, 
	3, 2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 71, 3, 2, 2, 2, 573, 571, 3, 2, 
	2, 2, 574, 579, 7, 44, 2, 2, 575, 576, 7, 53, 2, 2, 576, 578, 7, 44, 2, 
	2, 577, 575, 3, 2, 2, 2, 578, 581, 3, 2, 2, 2, 579, 577, 3, 2, 2, 2, 579, 
	580, 3, 2, 2, 2, 580, 73, 3, 2, 2, 2, 581, 579, 3, 2, 2, 2, 582, 583, 7, 
	14, 2, 2, 583, 588, 7, 44, 2, 2, 584, 585, 7, 58, 2, 2, 585, 587, 7, 44, 
	2, 2, 586, 584, 3, 2, 2, 2, 587, 590, 3, 2, 2, 2, 588, 586, 3, 2, 2, 2, 
	588, 589, 3, 2, 2, 2, 589, 75, 3, 2, 2, 2, 590, 588, 3, 2, 2, 2, 591, 592, 
	7, 15, 2, 2, 592, 597, 7, 44, 2, 2, 593, 594, 7, 58, 2, 2, 594, 596, 7, 
	44, 2, 2, 595, 593, 3, 2, 2, 2, 596, 599, 3, 2, 2, 2, 597, 595, 3, 2, 2, 
	2, 597, 598, 3, 2, 2, 2, 598, 77, 3, 2, 2, 2, 599, 597, 3, 2, 2, 2, 600, 
	601, 7, 16, 2, 2, 601, 604, 5, 100, 51, 2, 602, 603, 7, 58, 2, 2, 603, 
	605, 5, 100, 51, 2, 604, 602, 3, 2, 2, 2, 604, 605, 3, 2, 2, 2, 605, 79, 
	3, 2, 2, 2, 606, 616, 5, 84, 43, 2, 607, 616, 5, 86, 44, 2, 608, 616, 5, 
	88, 45, 2, 609, 616, 5, 90, 46, 2, 610, 616, 5, 92, 47, 2, 611, 616, 5, 
	16, 9, 2, 612, 616, 5, 156, 79, 2, 613, 616, 5, 12, 7, 2, 614, 616, 5, 
	82, 42, 2, 615, 606, 3, 2, 2, 2, 615, 607, 3, 2, 2, 2, 615, 608, 3, 2, 
	2, 2, 615, 609, 3, 2, 2, 2, 615, 610, 3, 2, 2, 2, 615, 611, 3, 2, 2, 2, 
	615, 612, 3, 2, 2, 2, 615, 613, 3, 2, 2, 2, 615, 614, 3, 2, 2, 2, 616, 
	81, 3, 2, 2, 2, 617, 621, 7, 41, 2, 2, 618, 622, 5, 16, 9, 2, 619, 622, 
	5, 92, 47, 2, 620, 622, 5, 88, 45, 2, 621, 618, 3, 2, 2, 2, 621, 619, 3, 
	2, 2, 2, 621, 620, 3, 2, 2, 2, 622, 83, 3, 2, 2, 2, 623, 624, 7, 17, 2, 
	2, 624, 625, 5, 100, 51, 2, 625, 626, 7, 59, 2, 2, 626, 634, 5, 98, 50, 
	2, 627, 628, 7, 18, 2, 2, 628, 629, 5, 100, 51, 2, 629, 630, 7, 59, 2, 
	2, 630, 631, 5, 98, 50, 2, 631, 633, 3, 2, 2, 2, 632, 627, 3, 2, 2, 2, 
	633, 636, 3, 2, 2, 2, 634, 632, 3, 2, 2, 2, 634, 635, 3, 2, 2, 2, 635, 
	640, 3, 2, 2, 2, 636, 634, 3, 2, 2, 2, 637, 638, 7, 19, 2, 2, 638, 639, 
	7, 59, 2, 2, 639, 641, 5, 98, 50, 2, 640, 637, 3, 2, 2, 2, 640, 641, 3, 
	2, 2, 2, 641, 85, 3, 2, 2, 2, 642, 643, 7, 20, 2, 2, 643, 644, 5, 100, 
	51, 2, 644, 645, 7, 59, 2, 2, 645, 649, 5, 98, 50, 2, 646, 647, 7, 19, 
	2, 2, 647, 648, 7, 59, 2, 2, 648, 650, 5, 98, 50, 2, 649, 646, 3, 2, 2, 
	2, 649, 650, 3, 2, 2, 2, 650, 87, 3, 2, 2, 2, 651, 652, 7, 21, 2, 2, 652, 
	653, 5, 150, 76, 2, 653, 654, 7, 22, 2, 2, 654, 655, 5, 152, 77, 2, 655, 
	656, 7, 59, 2, 2, 656, 660, 5, 98, 50, 2, 657, 658, 7, 19, 2, 2, 658, 659, 
	7, 59, 2, 2, 659, 661, 5, 98, 50, 2, 660, 657, 3, 2, 2, 2, 660, 661, 3, 
	2, 2, 2, 661, 89, 3, 2, 2, 2, 662, 663, 7, 23, 2, 2, 663, 664, 7, 59, 2, 
	2, 664, 686, 5, 98, 50, 2, 665, 666, 5, 96, 49, 2, 666, 667, 7, 59, 2, 
	2, 667, 668, 5, 98, 50, 2, 668, 670, 3, 2, 2, 2, 669, 665, 3, 2, 2, 2, 
	670, 671, 3, 2, 2, 2, 671, 669, 3, 2, 2, 2, 671, 672, 3, 2, 2, 2, 672, 
	676, 3, 2, 2, 2, 673, 674, 7, 19, 2, 2, 674, 675, 7, 59, 2, 2, 675, 677, 
	5, 98, 50, 2, 676, 673, 3, 2, 2, 2, 676, 677, 3, 2, 2, 2, 677, 681, 3, 
	2, 2, 2, 678, 679, 7, 24, 2, 2, 679, 680, 7, 59, 2, 2, 680, 682, 5, 98, 
	50, 2, 681, 678, 3, 2, 2, 2, 681, 682, 3, 2, 2, 2, 682, 687, 3, 2, 2, 2, 
	683, 684, 7, 24, 2, 2, 684, 685, 7, 59, 2, 2, 685, 687, 5, 98, 50, 2, 686, 
	669, 3, 2, 2, 2, 686, 683, 3, 2, 2, 2, 687, 91, 3, 2, 2, 2, 688, 689, 7, 
	25, 2, 2, 689, 694, 5, 94, 48, 2, 690, 691, 7, 58, 2, 2, 691, 693, 5, 94, 
	48, 2, 692, 690, 3, 2, 2, 2, 693, 696, 3, 2, 2, 2, 694, 692, 3, 2, 2, 2, 
	694, 695, 3, 2, 2, 2, 695, 697, 3, 2, 2, 2, 696, 694, 3, 2, 2, 2, 697, 
	698, 7, 59, 2, 2, 698, 699, 5, 98, 50, 2, 699, 93, 3, 2, 2, 2, 700, 703, 
	5, 100, 51, 2, 701, 702, 7, 13, 2, 2, 702, 704, 5, 120, 61, 2, 703, 701, 
	3, 2, 2, 2, 703, 704, 3, 2, 2, 2, 704, 95, 3, 2, 2, 2, 705, 711, 7, 26, 
	2, 2, 706, 709, 5, 100, 51, 2, 707, 708, 7, 13, 2, 2, 708, 710, 7, 44, 
	2, 2, 709, 707, 3, 2, 2, 2, 709, 710, 3, 2, 2, 2, 710, 712, 3, 2, 2, 2, 
	711, 706, 3, 2, 2, 2, 711, 712, 3, 2, 2, 2, 712, 97, 3, 2, 2, 2, 713, 724, 
	5, 30, 16, 2, 714, 715, 7, 43, 2, 2, 715, 717, 7, 3, 2, 2, 716, 718, 5, 
	28, 15, 2, 717, 716, 3, 2, 2, 2, 718, 719, 3, 2, 2, 2, 719, 717, 3, 2, 
	2, 2, 719, 720, 3, 2, 2, 2, 720, 721, 3, 2, 2, 2, 721, 722, 7, 4, 2, 2, 
	722, 724, 3, 2, 2, 2, 723, 713, 3, 2, 2, 2, 723, 714, 3, 2, 2, 2, 724, 
	99, 3, 2, 2, 2, 725, 731, 5, 108, 55, 2, 726, 727, 7, 17, 2, 2, 727, 728, 
	5, 108, 55, 2, 728, 729, 7, 19, 2, 2, 729, 730, 5, 100, 51, 2, 730, 732, 
	3, 2, 2, 2, 731, 726, 3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 735, 3, 2, 
	2, 2, 733, 735, 5, 104, 53, 2, 734, 725, 3, 2, 2, 2, 734, 733, 3, 2, 2, 
	2, 735, 101, 3, 2, 2, 2, 736, 739, 5, 108, 55, 2, 737, 739, 5, 106, 54, 
	2, 738, 736, 3, 2, 2, 2, 738, 737, 3, 2, 2, 2, 739, 103, 3, 2, 2, 2, 740, 
	742, 7, 27, 2, 2, 741, 743, 5, 24, 13, 2, 742, 741, 3, 2, 2, 2, 742, 743, 
	3, 2, 2, 2, 743, 744, 3, 2, 2, 2, 744, 745, 7, 59, 2, 2, 745, 746, 5, 100, 
	51, 2, 746, 105, 3, 2, 2, 2, 747, 749, 7, 27, 2, 2, 748, 750, 5, 24, 13, 
	2, 749, 748, 3, 2, 2, 2, 749, 750, 3, 2, 2, 2, 750, 751, 3, 2, 2, 2, 751, 
	752, 7, 59, 2, 2, 752, 753, 5, 102, 52, 2, 753, 107, 3, 2, 2, 2, 754, 759, 
	5, 110, 56, 2, 755, 756, 7, 28, 2, 2, 756, 758, 5, 110, 56, 2, 757, 755, 
	3, 2, 2, 2, 758, 761, 3, 2, 2, 2, 759, 757, 3, 2, 2, 2, 759, 760, 3, 2, 
	2, 2, 760, 109, 3, 2, 2, 2, 761, 759, 3, 2, 2, 2, 762, 767, 5, 112, 57, 
	2, 763, 764, 7, 29, 2, 2, 764, 766, 5, 112, 57, 2, 765, 763, 3, 2, 2, 2, 
	766, 769, 3, 2, 2, 2, 767, 765, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2, 768, 
	111, 3, 2, 2, 2, 769, 767, 3, 2, 2, 2, 770, 771, 7, 30, 2, 2, 771, 774, 
	5, 112, 57, 2, 772, 774, 5, 114, 58, 2, 773, 770, 3, 2, 2, 2, 773, 772, 
	3, 2, 2, 2, 774, 113, 3, 2, 2, 2, 775, 781, 5, 120, 61, 2, 776, 777, 5, 
	116, 59, 2, 777, 778, 5, 120, 61, 2, 778, 780, 3, 2, 2, 2, 779, 776, 3, 
	2, 2, 2, 780, 783, 3, 2, 2, 2, 781, 779, 3, 2, 2, 2, 781, 782, 3, 2, 2, 
	2, 782, 115, 3, 2, 2, 2, 783, 781, 3, 2, 2, 2, 784, 798, 7, 78, 2, 2, 785, 
	798, 7, 79, 2, 2, 786, 798, 7, 80, 2, 2, 787, 798, 7, 81, 2, 2, 788, 798, 
	7, 82, 2, 2, 789, 798, 7, 83, 2, 2, 790, 798, 7, 84, 2, 2, 791, 798, 7, 
	22, 2, 2, 792, 793, 7, 30, 2, 2, 793, 798, 7, 22, 2, 2, 794, 798, 7, 31, 
	2, 2, 795, 796, 7, 31, 2, 2, 796, 798, 7, 30, 2, 2, 797, 784, 3, 2, 2, 
	2, 797, 785, 3, 2, 2, 2, 797, 786, 3, 2, 2, 2, 797, 787, 3, 2, 2, 2, 797, 
	788, 3, 2, 2, 2, 797, 789, 3, 2, 2, 2, 797, 790, 3, 2, 2, 2, 797, 791, 
	3, 2, 2, 2, 797, 792, 3, 2, 2, 2, 797, 794, 3, 2, 2, 2, 797, 795, 3, 2, 
	2, 2, 798, 117, 3, 2, 2, 2, 799, 800, 7, 55, 2, 2, 800, 801, 5, 120, 61, 
	2, 801, 119, 3, 2, 2, 2, 802, 807, 5, 122, 62, 2, 803, 804, 7, 65, 2, 2, 
	804, 806, 5, 122, 62, 2, 805, 803, 3, 2, 2, 2, 806, 809, 3, 2, 2, 2, 807, 
	805, 3, 2, 2, 2, 807, 808, 3, 2, 2, 2, 808, 121, 3, 2, 2, 2, 809, 807, 
	3, 2, 2, 2, 810, 815, 5, 124, 63, 2, 811, 812, 7, 66, 2, 2, 812, 814, 5, 
	124, 63, 2, 813, 811, 3, 2, 2, 2, 814, 817, 3, 2, 2, 2, 815, 813, 3, 2, 
	2, 2, 815, 816, 3, 2, 2, 2, 816, 123, 3, 2, 2, 2, 817, 815, 3, 2, 2, 2, 
	818, 823, 5, 126, 64, 2, 819, 820, 7, 67, 2, 2, 820, 822, 5, 126, 64, 2, 
	821, 819, 3, 2, 2, 2, 822, 825, 3, 2, 2, 2, 823, 821, 3, 2, 2, 2, 823, 
	824, 3, 2, 2, 2, 824, 125, 3, 2, 2, 2, 825, 823, 3, 2, 2, 2, 826, 831, 
	5, 128, 65, 2, 827, 828, 9, 4, 2, 2, 828, 830, 5, 128, 65, 2, 829, 827, 
	3, 2, 2, 2, 830, 833, 3, 2, 2, 2, 831, 829, 3, 2, 2, 2, 831, 832, 3, 2, 
	2, 2, 832, 127, 3, 2, 2, 2, 833, 831, 3, 2, 2, 2, 834, 839, 5, 130, 66, 
	2, 835, 836, 9, 5, 2, 2, 836, 838, 5, 130, 66, 2, 837, 835, 3, 2, 2, 2, 
	838, 841, 3, 2, 2, 2, 839, 837, 3, 2, 2, 2, 839, 840, 3, 2, 2, 2, 840, 
	129, 3, 2, 2, 2, 841, 839, 3, 2, 2, 2, 842, 847, 5, 132, 67, 2, 843, 844, 
	9, 6, 2, 2, 844, 846, 5, 132, 67, 2, 845, 843, 3, 2, 2, 2, 846, 849, 3, 
	2, 2, 2, 847, 845, 3, 2, 2, 2, 847, 848, 3, 2, 2, 2, 848, 131, 3, 2, 2, 
	2, 849, 847, 3, 2, 2, 2, 850, 851, 9, 7, 2, 2, 851, 854, 5, 132, 67, 2, 
	852, 854, 5, 134, 68, 2, 853, 850, 3, 2, 2, 2, 853, 852, 3, 2, 2, 2, 854, 
	133, 3, 2, 2, 2, 855, 858, 5, 136, 69, 2, 856, 857, 7, 61, 2, 2, 857, 859, 
	5, 132, 67, 2, 858, 856, 3, 2, 2, 2, 858, 859, 3, 2, 2, 2, 859, 135, 3, 
	2, 2, 2, 860, 862, 7, 42, 2, 2, 861, 860, 3, 2, 2, 2, 861, 862, 3, 2, 2, 
	2, 862, 863, 3, 2, 2, 2, 863, 867, 5, 138, 70, 2, 864, 866, 5, 142, 72, 
	2, 865, 864, 3, 2, 2, 2, 866, 869, 3, 2, 2, 2, 867, 865, 3, 2, 2, 2, 867, 
	868, 3, 2, 2, 2, 868, 137, 3, 2, 2, 2, 869, 867, 3, 2, 2, 2, 870, 873, 
	7, 56, 2, 2, 871, 874, 5, 170, 86, 2, 872, 874, 5, 140, 71, 2, 873, 871, 
	3, 2, 2, 2, 873, 872, 3, 2, 2, 2, 873, 874, 3, 2, 2, 2, 874, 875, 3, 2, 
	2, 2, 875, 898, 7, 57, 2, 2, 876, 878, 7, 63, 2, 2, 877, 879, 5, 140, 71, 
	2, 878, 877, 3, 2, 2, 2, 878, 879, 3, 2, 2, 2, 879, 880, 3, 2, 2, 2, 880, 
	898, 7, 64, 2, 2, 881, 883, 7, 76, 2, 2, 882, 884, 5, 154, 78, 2, 883, 
	882, 3, 2, 2, 2, 883, 884, 3, 2, 2, 2, 884, 885, 3, 2, 2, 2, 885, 898, 
	7, 77, 2, 2, 886, 898, 7, 44, 2, 2, 887, 898, 7, 6, 2, 2, 888, 890, 7, 
	5, 2, 2, 889, 888, 3, 2, 2, 2, 890, 891, 3, 2, 2, 2, 891, 889, 3, 2, 2, 
	2, 891, 892, 3, 2, 2, 2, 892, 898, 3, 2, 2, 2, 893, 898, 7, 54, 2, 2, 894, 
	898, 7, 32, 2, 2, 895, 898, 7, 33, 2, 2, 896, 898, 7, 34, 2, 2, 897, 870, 
	3, 2, 2, 2, 897, 876, 3, 2, 2, 2, 897, 881, 3, 2, 2, 2, 897, 886, 3, 2, 
	2, 2, 897, 887, 3, 2, 2, 2, 897, 889, 3, 2, 2, 2, 897, 893, 3, 2, 2, 2, 
	897, 894, 3, 2, 2, 2, 897, 895, 3, 2, 2, 2, 897, 896, 3, 2, 2, 2, 898, 
	139, 3, 2, 2, 2, 899, 902, 5, 100, 51, 2, 900, 902, 5, 118, 60, 2, 901, 
	899, 3, 2, 2, 2, 901, 900, 3, 2, 2, 2, 902, 917, 3, 2, 2, 2, 903, 918, 
	5, 164, 83, 2, 904, 907, 7, 58, 2, 2, 905, 908, 5, 100, 51, 2, 906, 908, 
	5, 118, 60, 2, 907, 905, 3, 2, 2, 2, 907, 906, 3, 2, 2, 2, 908, 910, 3, 
	2, 2, 2, 909, 904, 3, 2, 2, 2, 910, 913, 3, 2, 2, 2, 911, 909, 3, 2, 2, 
	2, 911, 912, 3, 2, 2, 2, 912, 915, 3, 2, 2, 2, 913, 911, 3, 2, 2, 2, 914, 
	916, 7, 58, 2, 2, 915, 914, 3, 2, 2, 2, 915, 916, 3, 2, 2, 2, 916, 918, 
	3, 2, 2, 2, 917, 903, 3, 2, 2, 2, 917, 911, 3, 2, 2, 2, 918, 141, 3, 2, 
	2, 2, 919, 921, 7, 56, 2, 2, 920, 922, 5, 158, 80, 2, 921, 920, 3, 2, 2, 
	2, 921, 922, 3, 2, 2, 2, 922, 923, 3, 2, 2, 2, 923, 931, 7, 57, 2, 2, 924, 
	925, 7, 63, 2, 2, 925, 926, 5, 144, 73, 2, 926, 927, 7, 64, 2, 2, 927, 
	931, 3, 2, 2, 2, 928, 929, 7, 53, 2, 2, 929, 931, 7, 44, 2, 2, 930, 919, 
	3, 2, 2, 2, 930, 924, 3, 2, 2, 2, 930, 928, 3, 2, 2, 2, 931, 143, 3, 2, 
	2, 2, 932, 937, 5, 146, 74, 2, 933, 934, 7, 58, 2, 2, 934, 936, 5, 146, 
	74, 2, 935, 933, 3, 2, 2, 2, 936, 939, 3, 2, 2, 2, 937, 935, 3, 2, 2, 2, 
	937, 938, 3, 2, 2, 2, 938, 941, 3, 2, 2, 2, 939, 937, 3, 2, 2, 2, 940, 
	942, 7, 58, 2, 2, 941, 940, 3, 2, 2, 2, 941, 942, 3, 2, 2, 2, 942, 145, 
	3, 2, 2, 2, 943, 955, 5, 100, 51, 2, 944, 946, 5, 100, 51, 2, 945, 944, 
	3, 2, 2, 2, 945, 946, 3, 2, 2, 2, 946, 947, 3, 2, 2, 2, 947, 949, 7, 59, 
	2, 2, 948, 950, 5, 100, 51, 2, 949, 948, 3, 2, 2, 2, 949, 950, 3, 2, 2, 
	2, 950, 952, 3, 2, 2, 2, 951, 953, 5, 148, 75, 2, 952, 951, 3, 2, 2, 2, 
	952, 953, 3, 2, 2, 2, 953, 955, 3, 2, 2, 2, 954, 943, 3, 2, 2, 2, 954, 
	945, 3, 2, 2, 2, 955, 147, 3, 2, 2, 2, 956, 958, 7, 59, 2, 2, 957, 959, 
	5, 100, 51, 2, 958, 957, 3, 2, 2, 2, 958, 959, 3, 2, 2, 2, 959, 149, 3, 
	2, 2, 2, 960, 963, 5, 120, 61, 2, 961, 963, 5, 118, 60, 2, 962, 960, 3, 
	2, 2, 2, 962, 961, 3, 2, 2, 2, 963, 971, 3, 2, 2, 2, 964, 967, 7, 58, 2, 
	2, 965, 968, 5, 120, 61, 2, 966, 968, 5, 118, 60, 2, 967, 965, 3, 2, 2, 
	2, 967, 966, 3, 2, 2, 2, 968, 970, 3, 2, 2, 2, 969, 964, 3, 2, 2, 2, 970, 
	973, 3, 2, 2, 2, 971, 969, 3, 2, 2, 2, 971, 972, 3, 2, 2, 2, 972, 975, 
	3, 2, 2, 2, 973, 971, 3, 2, 2, 2, 974, 976, 7, 58, 2, 2, 975, 974, 3, 2, 
	2, 2, 975, 976, 3, 2, 2, 2, 976, 151, 3, 2, 2, 2, 977, 982, 5, 100, 51, 
	2, 978, 979, 7, 58, 2, 2, 979, 981, 5, 100, 51, 2, 980, 978, 3, 2, 2, 2, 
	981, 984, 3, 2, 2, 2, 982, 980, 3, 2, 2, 2, 982, 983, 3, 2, 2, 2, 983, 
	986, 3, 2, 2, 2, 984, 982, 3, 2, 2, 2, 985, 987, 7, 58, 2, 2, 986, 985, 
	3, 2, 2, 2, 986, 987, 3, 2, 2, 2, 987, 153, 3, 2, 2, 2, 988, 989, 5, 100, 
	51, 2, 989, 990, 7, 59, 2, 2, 990, 991, 5, 100, 51, 2, 991, 995, 3, 2, 
	2, 2, 992, 993, 7, 61, 2, 2, 993, 995, 5, 120, 61, 2, 994, 988, 3, 2, 2, 
	2, 994, 992, 3, 2, 2, 2, 995, 1014, 3, 2, 2, 2, 996, 1015, 5, 164, 83, 
	2, 997, 1004, 7, 58, 2, 2, 998, 999, 5, 100, 51, 2, 999, 1000, 7, 59, 2, 
	2, 1000, 1001, 5, 100, 51, 2, 1001, 1005, 3, 2, 2, 2, 1002, 1003, 7, 61, 
	2, 2, 1003, 1005, 5, 120, 61, 2, 1004, 998, 3, 2, 2, 2, 1004, 1002, 3, 
	2, 2, 2, 1005, 1007, 3, 2, 2, 2, 1006, 997, 3, 2, 2, 2, 1007, 1010, 3, 
	2, 2, 2, 1008, 1006, 3, 2, 2, 2, 1008, 1009, 3, 2, 2, 2, 1009, 1012, 3, 
	2, 2, 2, 1010, 1008, 3, 2, 2, 2, 1011, 1013, 7, 58, 2, 2, 1012, 1011, 3, 
	2, 2, 2, 1012, 1013, 3, 2, 2, 2, 1013, 1015, 3, 2, 2, 2, 1014, 996, 3, 
	2, 2, 2, 1014, 1008, 3, 2, 2, 2, 1015, 1037, 3, 2, 2, 2, 1016, 1019, 5, 
	100, 51, 2, 1017, 1019, 5, 118, 60, 2, 1018, 1016, 3, 2, 2, 2, 1018, 1017, 
	3, 2, 2, 2, 1019, 1034, 3, 2, 2, 2, 1020, 1035, 5, 164, 83, 2, 1021, 1024, 
	7, 58, 2, 2, 1022, 1025, 5, 100, 51, 2, 1023, 1025, 5, 118, 60, 2, 1024, 
	1022, 3, 2, 2, 2, 1024, 1023, 3, 2, 2, 2, 1025, 1027, 3, 2, 2, 2, 1026, 
	1021, 3, 2, 2, 2, 1027, 1030, 3, 2, 2, 2, 1028, 1026, 3, 2, 2, 2, 1028, 
	1029, 3, 2, 2, 2, 1029, 1032, 3, 2, 2, 2, 1030, 1028, 3, 2, 2, 2, 1031, 
	1033, 7, 58, 2, 2, 1032, 1031, 3, 2, 2, 2, 1032, 1033, 3, 2, 2, 2, 1033, 
	1035, 3, 2, 2, 2, 1034, 1020, 3, 2, 2, 2, 1034, 1028, 3, 2, 2, 2, 1035, 
	1037, 3, 2, 2, 2, 1036, 994, 3, 2, 2, 2, 1036, 1018, 3, 2, 2, 2, 1037, 
	155, 3, 2, 2, 2, 1038, 1039, 7, 35, 2, 2, 1039, 1045, 7, 44, 2, 2, 1040, 
	1042, 7, 56, 2, 2, 1041, 1043, 5, 158, 80, 2, 1042, 1041, 3, 2, 2, 2, 1042, 
	1043, 3, 2, 2, 2, 1043, 1044, 3, 2, 2, 2, 1044, 1046, 7, 57, 2, 2, 1045, 
	1040, 3, 2, 2, 2, 1045, 1046, 3, 2, 2, 2, 1046, 1047, 3, 2, 2, 2, 1047, 
	1048, 7, 59, 2, 2, 1048, 1049, 5, 98, 50, 2, 1049, 157, 3, 2, 2, 2, 1050, 
	1055, 5, 160, 81, 2, 1051, 1052, 7, 58, 2, 2, 1052, 1054, 5, 160, 81, 2, 
	1053, 1051, 3, 2, 2, 2, 1054, 1057, 3, 2, 2, 2, 1055, 1053, 3, 2, 2, 2, 
	1055, 1056, 3, 2, 2, 2, 1056, 1059, 3, 2, 2, 2, 1057, 1055, 3, 2, 2, 2, 
	1058, 1060, 7, 58, 2, 2, 1059, 1058, 3, 2, 2, 2, 1059, 1060, 3, 2, 2, 2, 
	1060, 159, 3, 2, 2, 2, 1061, 1063, 5, 100, 51, 2, 1062, 1064, 5, 164, 83, 
	2, 1063, 1062, 3, 2, 2, 2, 1063, 1064, 3, 2, 2, 2, 1064, 1074, 3, 2, 2, 
	2, 1065, 1066, 5, 100, 51, 2, 1066, 1067, 7, 62, 2, 2, 1067, 1068, 5, 100, 
	51, 2, 1068, 1074, 3, 2, 2, 2, 1069, 1070, 7, 61, 2, 2, 1070, 1074, 5, 
	100, 51, 2, 1071, 1072, 7, 55, 2, 2, 1072, 1074, 5, 100, 51, 2, 1073, 1061, 
	3, 2, 2, 2, 1073, 1065, 3, 2, 2, 2, 1073, 1069, 3, 2, 2, 2, 1073, 1071, 
	3, 2, 2, 2, 1074, 161, 3, 2, 2, 2, 1075, 1078, 5, 164, 83, 2, 1076, 1078, 
	5, 166, 84, 2, 1077, 1075, 3, 2, 2, 2, 1077, 1076, 3, 2, 2, 2, 1078, 163, 
	3, 2, 2, 2, 1079, 1081, 7, 41, 2, 2, 1080, 1079, 3, 2, 2, 2, 1080, 1081, 
	3, 2, 2, 2, 1081, 1082, 3, 2, 2, 2, 1082, 1083, 7, 21, 2, 2, 1083, 1084, 
	5, 150, 76, 2, 1084, 1085, 7, 22, 2, 2, 1085, 1087, 5, 108, 55, 2, 1086, 
	1088, 5, 162, 82, 2, 1087, 1086, 3, 2, 2, 2, 1087, 1088, 3, 2, 2, 2, 1088, 
	165, 3, 2, 2, 2, 1089, 1090, 7, 17, 2, 2, 1090, 1092, 5, 102, 52, 2, 1091, 
	1093, 5, 162, 82, 2, 1092, 1091, 3, 2, 2, 2, 1092, 1093, 3, 2, 2, 2, 1093, 
	167, 3, 2, 2, 2, 1094, 1095, 7, 44, 2, 2, 1095, 169, 3, 2, 2, 2, 1096, 
	1098, 7, 36, 2, 2, 1097, 1099, 5, 172, 87, 2, 1098, 1097, 3, 2, 2, 2, 1098, 
	1099, 3, 2, 2, 2, 1099, 171, 3, 2, 2, 2, 1100, 1101, 7, 11, 2, 2, 1101, 
	1104, 5, 100, 51, 2, 1102, 1104, 5, 152, 77, 2, 1103, 1100, 3, 2, 2, 2, 
	1103, 1102, 3, 2, 2, 2, 1104, 173, 3, 2, 2, 2, 168, 179, 183, 185, 194, 
	203, 206, 213, 219, 229, 236, 243, 249, 253, 259, 265, 269, 276, 278, 280, 
	285, 287, 289, 293, 299, 303, 310, 312, 314, 319, 321, 326, 331, 337, 341, 
	347, 353, 357, 364, 366, 368, 373, 375, 377, 381, 387, 391, 398, 400, 402, 
	407, 409, 415, 422, 426, 438, 445, 450, 454, 457, 463, 467, 472, 476, 480, 
	494, 502, 510, 512, 516, 525, 532, 534, 543, 548, 553, 560, 564, 571, 579, 
	588, 597, 604, 615, 621, 634, 640, 649, 660, 671, 676, 681, 686, 694, 703, 
	709, 711, 719, 723, 731, 734, 738, 742, 749, 759, 767, 773, 781, 797, 807, 
	815, 823, 831, 839, 847, 853, 858, 861, 867, 873, 878, 883, 891, 897, 901, 
	907, 911, 915, 917, 921, 930, 937, 941, 945, 949, 952, 954, 958, 962, 967, 
	971, 975, 982, 986, 994, 1004, 1008, 1012, 1014, 1018, 1024, 1028, 1032, 
	1034, 1036, 1042, 1045, 1055, 1059, 1063, 1073, 1077, 1080, 1087, 1092, 
	1098, 1103,
}
var literalNames = []string{
	"", "", "", "", "", "", "'def'", "'return'", "'raise'", "'from'", "'import'", 
	"'as'", "'global'", "'nonlocal'", "'assert'", "'if'", "'elif'", "'else'", 
	"'while'", "'for'", "'in'", "'try'", "'finally'", "'with'", "'except'", 
	"'lambda'", "'or'", "'and'", "'not'", "'is'", "'None'", "'True'", "'False'", 
	"'class'", "'yield'", "'del'", "'pass'", "'continue'", "'break'", "'async'", 
	"'await'", "", "", "", "", "", "", "", "", "", "", "'.'", "'...'", "'*'", 
	"'('", "')'", "','", "':'", "';'", "'**'", "'='", "'['", "']'", "'|'", 
	"'^'", "'&'", "'<<'", "'>>'", "'+'", "'-'", "'/'", "'%'", "'//'", "'~'", 
	"'{'", "'}'", "'<'", "'>'", "'=='", "'>='", "'<='", "'<>'", "'!='", "'@'", 
	"'->'", "'+='", "'-='", "'*='", "'@='", "'/='", "'%='", "'&='", "'|='", 
	"'^='", "'<<='", "'>>='", "'**='", "'//='",
}
var symbolicNames = []string{
	"", "INDENT", "DEDENT", "STRING", "NUMBER", "INTEGER", "DEF", "RETURN", 
	"RAISE", "FROM", "IMPORT", "AS", "GLOBAL", "NONLOCAL", "ASSERT", "IF", 
	"ELIF", "ELSE", "WHILE", "FOR", "IN", "TRY", "FINALLY", "WITH", "EXCEPT", 
	"LAMBDA", "OR", "AND", "NOT", "IS", "NONE", "TRUE", "FALSE", "CLASS", "YIELD", 
	"DEL", "PASS", "CONTINUE", "BREAK", "ASYNC", "AWAIT", "NEWLINE", "NAME", 
	"STRING_LITERAL", "BYTES_LITERAL", "DECIMAL_INTEGER", "OCT_INTEGER", "HEX_INTEGER", 
	"BIN_INTEGER", "FLOAT_NUMBER", "IMAG_NUMBER", "DOT", "ELLIPSIS", "STAR", 
	"OPEN_PAREN", "CLOSE_PAREN", "COMMA", "COLON", "SEMI_COLON", "POWER", "ASSIGN", 
	"OPEN_BRACK", "CLOSE_BRACK", "OR_OP", "XOR", "AND_OP", "LEFT_SHIFT", "RIGHT_SHIFT", 
	"ADD", "MINUS", "DIV", "MOD", "IDIV", "NOT_OP", "OPEN_BRACE", "CLOSE_BRACE", 
	"LESS_THAN", "GREATER_THAN", "EQUALS", "GT_EQ", "LT_EQ", "NOT_EQ_1", "NOT_EQ_2", 
	"AT", "ARROW", "ADD_ASSIGN", "SUB_ASSIGN", "MULT_ASSIGN", "AT_ASSIGN", 
	"DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "LEFT_SHIFT_ASSIGN", 
	"RIGHT_SHIFT_ASSIGN", "POWER_ASSIGN", "IDIV_ASSIGN", "SKIP_", "UNKNOWN_CHAR",
}

var ruleNames = []string{
	"single_input", "file_input", "eval_input", "decorator", "decorators", 
	"decorated", "async_funcdef", "funcdef", "parameters", "typedargslist", 
	"tfpdef", "varargslist", "vfpdef", "stmt", "simple_stmt", "small_stmt", 
	"expr_stmt", "annassign", "testlist_star_expr", "augassign", "del_stmt", 
	"pass_stmt", "flow_stmt", "break_stmt", "continue_stmt", "return_stmt", 
	"yield_stmt", "raise_stmt", "import_stmt", "import_name", "import_from", 
	"import_as_name", "dotted_as_name", "import_as_names", "dotted_as_names", 
	"dotted_name", "global_stmt", "nonlocal_stmt", "assert_stmt", "compound_stmt", 
	"async_stmt", "if_stmt", "while_stmt", "for_stmt", "try_stmt", "with_stmt", 
	"with_item", "except_clause", "suite", "test", "test_nocond", "lambdef", 
	"lambdef_nocond", "or_test", "and_test", "not_test", "comparison", "comp_op", 
	"star_expr", "expr", "xor_expr", "and_expr", "shift_expr", "arith_expr", 
	"term", "factor", "power", "atom_expr", "atom", "testlist_comp", "trailer", 
	"subscriptlist", "subscript_", "sliceop", "exprlist", "testlist", "dictorsetmaker", 
	"classdef", "arglist", "argument", "comp_iter", "comp_for", "comp_if", 
	"encoding_decl", "yield_expr", "yield_arg",
}
type Python3Parser struct {
	*antlr.BaseParser
}

// NewPython3Parser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *Python3Parser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewPython3Parser(input antlr.TokenStream) *Python3Parser {
	this := new(Python3Parser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Python3Parser.g4"

	return this
}


// Python3Parser tokens.
const (
	Python3ParserEOF = antlr.TokenEOF
	Python3ParserINDENT = 1
	Python3ParserDEDENT = 2
	Python3ParserSTRING = 3
	Python3ParserNUMBER = 4
	Python3ParserINTEGER = 5
	Python3ParserDEF = 6
	Python3ParserRETURN = 7
	Python3ParserRAISE = 8
	Python3ParserFROM = 9
	Python3ParserIMPORT = 10
	Python3ParserAS = 11
	Python3ParserGLOBAL = 12
	Python3ParserNONLOCAL = 13
	Python3ParserASSERT = 14
	Python3ParserIF = 15
	Python3ParserELIF = 16
	Python3ParserELSE = 17
	Python3ParserWHILE = 18
	Python3ParserFOR = 19
	Python3ParserIN = 20
	Python3ParserTRY = 21
	Python3ParserFINALLY = 22
	Python3ParserWITH = 23
	Python3ParserEXCEPT = 24
	Python3ParserLAMBDA = 25
	Python3ParserOR = 26
	Python3ParserAND = 27
	Python3ParserNOT = 28
	Python3ParserIS = 29
	Python3ParserNONE = 30
	Python3ParserTRUE = 31
	Python3ParserFALSE = 32
	Python3ParserCLASS = 33
	Python3ParserYIELD = 34
	Python3ParserDEL = 35
	Python3ParserPASS = 36
	Python3ParserCONTINUE = 37
	Python3ParserBREAK = 38
	Python3ParserASYNC = 39
	Python3ParserAWAIT = 40
	Python3ParserNEWLINE = 41
	Python3ParserNAME = 42
	Python3ParserSTRING_LITERAL = 43
	Python3ParserBYTES_LITERAL = 44
	Python3ParserDECIMAL_INTEGER = 45
	Python3ParserOCT_INTEGER = 46
	Python3ParserHEX_INTEGER = 47
	Python3ParserBIN_INTEGER = 48
	Python3ParserFLOAT_NUMBER = 49
	Python3ParserIMAG_NUMBER = 50
	Python3ParserDOT = 51
	Python3ParserELLIPSIS = 52
	Python3ParserSTAR = 53
	Python3ParserOPEN_PAREN = 54
	Python3ParserCLOSE_PAREN = 55
	Python3ParserCOMMA = 56
	Python3ParserCOLON = 57
	Python3ParserSEMI_COLON = 58
	Python3ParserPOWER = 59
	Python3ParserASSIGN = 60
	Python3ParserOPEN_BRACK = 61
	Python3ParserCLOSE_BRACK = 62
	Python3ParserOR_OP = 63
	Python3ParserXOR = 64
	Python3ParserAND_OP = 65
	Python3ParserLEFT_SHIFT = 66
	Python3ParserRIGHT_SHIFT = 67
	Python3ParserADD = 68
	Python3ParserMINUS = 69
	Python3ParserDIV = 70
	Python3ParserMOD = 71
	Python3ParserIDIV = 72
	Python3ParserNOT_OP = 73
	Python3ParserOPEN_BRACE = 74
	Python3ParserCLOSE_BRACE = 75
	Python3ParserLESS_THAN = 76
	Python3ParserGREATER_THAN = 77
	Python3ParserEQUALS = 78
	Python3ParserGT_EQ = 79
	Python3ParserLT_EQ = 80
	Python3ParserNOT_EQ_1 = 81
	Python3ParserNOT_EQ_2 = 82
	Python3ParserAT = 83
	Python3ParserARROW = 84
	Python3ParserADD_ASSIGN = 85
	Python3ParserSUB_ASSIGN = 86
	Python3ParserMULT_ASSIGN = 87
	Python3ParserAT_ASSIGN = 88
	Python3ParserDIV_ASSIGN = 89
	Python3ParserMOD_ASSIGN = 90
	Python3ParserAND_ASSIGN = 91
	Python3ParserOR_ASSIGN = 92
	Python3ParserXOR_ASSIGN = 93
	Python3ParserLEFT_SHIFT_ASSIGN = 94
	Python3ParserRIGHT_SHIFT_ASSIGN = 95
	Python3ParserPOWER_ASSIGN = 96
	Python3ParserIDIV_ASSIGN = 97
	Python3ParserSKIP_ = 98
	Python3ParserUNKNOWN_CHAR = 99
)

// Python3Parser rules.
const (
	Python3ParserRULE_single_input = 0
	Python3ParserRULE_file_input = 1
	Python3ParserRULE_eval_input = 2
	Python3ParserRULE_decorator = 3
	Python3ParserRULE_decorators = 4
	Python3ParserRULE_decorated = 5
	Python3ParserRULE_async_funcdef = 6
	Python3ParserRULE_funcdef = 7
	Python3ParserRULE_parameters = 8
	Python3ParserRULE_typedargslist = 9
	Python3ParserRULE_tfpdef = 10
	Python3ParserRULE_varargslist = 11
	Python3ParserRULE_vfpdef = 12
	Python3ParserRULE_stmt = 13
	Python3ParserRULE_simple_stmt = 14
	Python3ParserRULE_small_stmt = 15
	Python3ParserRULE_expr_stmt = 16
	Python3ParserRULE_annassign = 17
	Python3ParserRULE_testlist_star_expr = 18
	Python3ParserRULE_augassign = 19
	Python3ParserRULE_del_stmt = 20
	Python3ParserRULE_pass_stmt = 21
	Python3ParserRULE_flow_stmt = 22
	Python3ParserRULE_break_stmt = 23
	Python3ParserRULE_continue_stmt = 24
	Python3ParserRULE_return_stmt = 25
	Python3ParserRULE_yield_stmt = 26
	Python3ParserRULE_raise_stmt = 27
	Python3ParserRULE_import_stmt = 28
	Python3ParserRULE_import_name = 29
	Python3ParserRULE_import_from = 30
	Python3ParserRULE_import_as_name = 31
	Python3ParserRULE_dotted_as_name = 32
	Python3ParserRULE_import_as_names = 33
	Python3ParserRULE_dotted_as_names = 34
	Python3ParserRULE_dotted_name = 35
	Python3ParserRULE_global_stmt = 36
	Python3ParserRULE_nonlocal_stmt = 37
	Python3ParserRULE_assert_stmt = 38
	Python3ParserRULE_compound_stmt = 39
	Python3ParserRULE_async_stmt = 40
	Python3ParserRULE_if_stmt = 41
	Python3ParserRULE_while_stmt = 42
	Python3ParserRULE_for_stmt = 43
	Python3ParserRULE_try_stmt = 44
	Python3ParserRULE_with_stmt = 45
	Python3ParserRULE_with_item = 46
	Python3ParserRULE_except_clause = 47
	Python3ParserRULE_suite = 48
	Python3ParserRULE_test = 49
	Python3ParserRULE_test_nocond = 50
	Python3ParserRULE_lambdef = 51
	Python3ParserRULE_lambdef_nocond = 52
	Python3ParserRULE_or_test = 53
	Python3ParserRULE_and_test = 54
	Python3ParserRULE_not_test = 55
	Python3ParserRULE_comparison = 56
	Python3ParserRULE_comp_op = 57
	Python3ParserRULE_star_expr = 58
	Python3ParserRULE_expr = 59
	Python3ParserRULE_xor_expr = 60
	Python3ParserRULE_and_expr = 61
	Python3ParserRULE_shift_expr = 62
	Python3ParserRULE_arith_expr = 63
	Python3ParserRULE_term = 64
	Python3ParserRULE_factor = 65
	Python3ParserRULE_power = 66
	Python3ParserRULE_atom_expr = 67
	Python3ParserRULE_atom = 68
	Python3ParserRULE_testlist_comp = 69
	Python3ParserRULE_trailer = 70
	Python3ParserRULE_subscriptlist = 71
	Python3ParserRULE_subscript_ = 72
	Python3ParserRULE_sliceop = 73
	Python3ParserRULE_exprlist = 74
	Python3ParserRULE_testlist = 75
	Python3ParserRULE_dictorsetmaker = 76
	Python3ParserRULE_classdef = 77
	Python3ParserRULE_arglist = 78
	Python3ParserRULE_argument = 79
	Python3ParserRULE_comp_iter = 80
	Python3ParserRULE_comp_for = 81
	Python3ParserRULE_comp_if = 82
	Python3ParserRULE_encoding_decl = 83
	Python3ParserRULE_yield_expr = 84
	Python3ParserRULE_yield_arg = 85
)

// ISingle_inputContext is an interface to support dynamic dispatch.
type ISingle_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_inputContext differentiates from other interfaces.
	IsSingle_inputContext()
}

type Single_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_inputContext() *Single_inputContext {
	var p = new(Single_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_single_input
	return p
}

func (*Single_inputContext) IsSingle_inputContext() {}

func NewSingle_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_inputContext {
	var p = new(Single_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_single_input

	return p
}

func (s *Single_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_inputContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *Single_inputContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *Single_inputContext) Compound_stmt() ICompound_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *Single_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Single_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSingle_input(s)
	}
}

func (s *Single_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSingle_input(s)
	}
}




func (p *Python3Parser) Single_input() (localctx ISingle_inputContext) {
	localctx = NewSingle_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Python3ParserRULE_single_input)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(177)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(172)
			p.Match(Python3ParserNEWLINE)
		}


	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(173)
			p.Simple_stmt()
		}


	case Python3ParserDEF, Python3ParserIF, Python3ParserWHILE, Python3ParserFOR, Python3ParserTRY, Python3ParserWITH, Python3ParserCLASS, Python3ParserASYNC, Python3ParserAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(174)
			p.Compound_stmt()
		}
		{
			p.SetState(175)
			p.Match(Python3ParserNEWLINE)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IFile_inputContext is an interface to support dynamic dispatch.
type IFile_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_inputContext differentiates from other interfaces.
	IsFile_inputContext()
}

type File_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_inputContext() *File_inputContext {
	var p = new(File_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_file_input
	return p
}

func (*File_inputContext) IsFile_inputContext() {}

func NewFile_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_inputContext {
	var p = new(File_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_file_input

	return p
}

func (s *File_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *File_inputContext) EOF() antlr.TerminalNode {
	return s.GetToken(Python3ParserEOF, 0)
}

func (s *File_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNEWLINE)
}

func (s *File_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, i)
}

func (s *File_inputContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *File_inputContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *File_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *File_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFile_input(s)
	}
}

func (s *File_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFile_input(s)
	}
}




func (p *Python3Parser) File_input() (localctx IFile_inputContext) {
	localctx = NewFile_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Python3ParserRULE_file_input)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(183)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserDEF) | (1 << Python3ParserRETURN) | (1 << Python3ParserRAISE) | (1 << Python3ParserFROM) | (1 << Python3ParserIMPORT) | (1 << Python3ParserGLOBAL) | (1 << Python3ParserNONLOCAL) | (1 << Python3ParserASSERT) | (1 << Python3ParserIF) | (1 << Python3ParserWHILE) | (1 << Python3ParserFOR) | (1 << Python3ParserTRY) | (1 << Python3ParserWITH) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserCLASS - 32)) | (1 << (Python3ParserYIELD - 32)) | (1 << (Python3ParserDEL - 32)) | (1 << (Python3ParserPASS - 32)) | (1 << (Python3ParserCONTINUE - 32)) | (1 << (Python3ParserBREAK - 32)) | (1 << (Python3ParserASYNC - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNEWLINE - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserSTAR - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)) | (1 << (Python3ParserAT - 68)))) != 0) {
		p.SetState(181)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserNEWLINE:
			{
				p.SetState(179)
				p.Match(Python3ParserNEWLINE)
			}


		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserDEF, Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserIF, Python3ParserWHILE, Python3ParserFOR, Python3ParserTRY, Python3ParserWITH, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserCLASS, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserASYNC, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE, Python3ParserAT:
			{
				p.SetState(180)
				p.Stmt()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(186)
		p.Match(Python3ParserEOF)
	}



	return localctx
}


// IEval_inputContext is an interface to support dynamic dispatch.
type IEval_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEval_inputContext differentiates from other interfaces.
	IsEval_inputContext()
}

type Eval_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEval_inputContext() *Eval_inputContext {
	var p = new(Eval_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_eval_input
	return p
}

func (*Eval_inputContext) IsEval_inputContext() {}

func NewEval_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eval_inputContext {
	var p = new(Eval_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_eval_input

	return p
}

func (s *Eval_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Eval_inputContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Eval_inputContext) EOF() antlr.TerminalNode {
	return s.GetToken(Python3ParserEOF, 0)
}

func (s *Eval_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNEWLINE)
}

func (s *Eval_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, i)
}

func (s *Eval_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eval_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Eval_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterEval_input(s)
	}
}

func (s *Eval_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitEval_input(s)
	}
}




func (p *Python3Parser) Eval_input() (localctx IEval_inputContext) {
	localctx = NewEval_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Python3ParserRULE_eval_input)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(188)
		p.Testlist()
	}
	p.SetState(192)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserNEWLINE {
		{
			p.SetState(189)
			p.Match(Python3ParserNEWLINE)
		}


		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(195)
		p.Match(Python3ParserEOF)
	}



	return localctx
}


// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorContext differentiates from other interfaces.
	IsDecoratorContext()
}

type DecoratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext {
	var p = new(DecoratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_decorator
	return p
}

func (*DecoratorContext) IsDecoratorContext() {}

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext {
	var p = new(DecoratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorator

	return p
}

func (s *DecoratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorContext) AT() antlr.TerminalNode {
	return s.GetToken(Python3ParserAT, 0)
}

func (s *DecoratorContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *DecoratorContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *DecoratorContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *DecoratorContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *DecoratorContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecoratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDecorator(s)
	}
}

func (s *DecoratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDecorator(s)
	}
}




func (p *Python3Parser) Decorator() (localctx IDecoratorContext) {
	localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Python3ParserRULE_decorator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(197)
		p.Match(Python3ParserAT)
	}
	{
		p.SetState(198)
		p.Dotted_name()
	}
	p.SetState(204)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserOPEN_PAREN {
		{
			p.SetState(199)
			p.Match(Python3ParserOPEN_PAREN)
		}
		p.SetState(201)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserSTAR - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserPOWER - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
			{
				p.SetState(200)
				p.Arglist()
			}

		}
		{
			p.SetState(203)
			p.Match(Python3ParserCLOSE_PAREN)
		}

	}
	{
		p.SetState(206)
		p.Match(Python3ParserNEWLINE)
	}



	return localctx
}


// IDecoratorsContext is an interface to support dynamic dispatch.
type IDecoratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorsContext differentiates from other interfaces.
	IsDecoratorsContext()
}

type DecoratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorsContext() *DecoratorsContext {
	var p = new(DecoratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_decorators
	return p
}

func (*DecoratorsContext) IsDecoratorsContext() {}

func NewDecoratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorsContext {
	var p = new(DecoratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorators

	return p
}

func (s *DecoratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorsContext) AllDecorator() []IDecoratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDecoratorContext)(nil)).Elem())
	var tst = make([]IDecoratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDecoratorContext)
		}
	}

	return tst
}

func (s *DecoratorsContext) Decorator(i int) IDecoratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *DecoratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecoratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDecorators(s)
	}
}

func (s *DecoratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDecorators(s)
	}
}




func (p *Python3Parser) Decorators() (localctx IDecoratorsContext) {
	localctx = NewDecoratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Python3ParserRULE_decorators)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(209)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == Python3ParserAT {
		{
			p.SetState(208)
			p.Decorator()
		}


		p.SetState(211)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IDecoratedContext is an interface to support dynamic dispatch.
type IDecoratedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratedContext differentiates from other interfaces.
	IsDecoratedContext()
}

type DecoratedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratedContext() *DecoratedContext {
	var p = new(DecoratedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_decorated
	return p
}

func (*DecoratedContext) IsDecoratedContext() {}

func NewDecoratedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratedContext {
	var p = new(DecoratedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorated

	return p
}

func (s *DecoratedContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratedContext) Decorators() IDecoratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecoratorsContext)
}

func (s *DecoratedContext) Classdef() IClassdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *DecoratedContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *DecoratedContext) Async_funcdef() IAsync_funcdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsync_funcdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsync_funcdefContext)
}

func (s *DecoratedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecoratedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDecorated(s)
	}
}

func (s *DecoratedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDecorated(s)
	}
}




func (p *Python3Parser) Decorated() (localctx IDecoratedContext) {
	localctx = NewDecoratedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Python3ParserRULE_decorated)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(213)
		p.Decorators()
	}
	p.SetState(217)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserCLASS:
		{
			p.SetState(214)
			p.Classdef()
		}


	case Python3ParserDEF:
		{
			p.SetState(215)
			p.Funcdef()
		}


	case Python3ParserASYNC:
		{
			p.SetState(216)
			p.Async_funcdef()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IAsync_funcdefContext is an interface to support dynamic dispatch.
type IAsync_funcdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsync_funcdefContext differentiates from other interfaces.
	IsAsync_funcdefContext()
}

type Async_funcdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsync_funcdefContext() *Async_funcdefContext {
	var p = new(Async_funcdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_async_funcdef
	return p
}

func (*Async_funcdefContext) IsAsync_funcdefContext() {}

func NewAsync_funcdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Async_funcdefContext {
	var p = new(Async_funcdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_async_funcdef

	return p
}

func (s *Async_funcdefContext) GetParser() antlr.Parser { return s.parser }

func (s *Async_funcdefContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *Async_funcdefContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Async_funcdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Async_funcdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Async_funcdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAsync_funcdef(s)
	}
}

func (s *Async_funcdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAsync_funcdef(s)
	}
}




func (p *Python3Parser) Async_funcdef() (localctx IAsync_funcdefContext) {
	localctx = NewAsync_funcdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Python3ParserRULE_async_funcdef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(219)
		p.Match(Python3ParserASYNC)
	}
	{
		p.SetState(220)
		p.Funcdef()
	}



	return localctx
}


// IFuncdefContext is an interface to support dynamic dispatch.
type IFuncdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncdefContext differentiates from other interfaces.
	IsFuncdefContext()
}

type FuncdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncdefContext() *FuncdefContext {
	var p = new(FuncdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_funcdef
	return p
}

func (*FuncdefContext) IsFuncdefContext() {}

func NewFuncdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncdefContext {
	var p = new(FuncdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_funcdef

	return p
}

func (s *FuncdefContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncdefContext) DEF() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEF, 0)
}

func (s *FuncdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *FuncdefContext) Parameters() IParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FuncdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *FuncdefContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *FuncdefContext) ARROW() antlr.TerminalNode {
	return s.GetToken(Python3ParserARROW, 0)
}

func (s *FuncdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *FuncdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FuncdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFuncdef(s)
	}
}

func (s *FuncdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFuncdef(s)
	}
}




func (p *Python3Parser) Funcdef() (localctx IFuncdefContext) {
	localctx = NewFuncdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Python3ParserRULE_funcdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(Python3ParserDEF)
	}
	{
		p.SetState(223)
		p.Match(Python3ParserNAME)
	}
	{
		p.SetState(224)
		p.Parameters()
	}
	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserARROW {
		{
			p.SetState(225)
			p.Match(Python3ParserARROW)
		}
		{
			p.SetState(226)
			p.Test()
		}

	}
	{
		p.SetState(229)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(230)
		p.Suite()
	}



	return localctx
}


// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_parameters
	return p
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *ParametersContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *ParametersContext) Typedargslist() ITypedargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedargslistContext)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitParameters(s)
	}
}




func (p *Python3Parser) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Python3ParserRULE_parameters)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(232)
		p.Match(Python3ParserOPEN_PAREN)
	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 42)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 42))) & ((1 << (Python3ParserNAME - 42)) | (1 << (Python3ParserSTAR - 42)) | (1 << (Python3ParserPOWER - 42)))) != 0) {
		{
			p.SetState(233)
			p.Typedargslist()
		}

	}
	{
		p.SetState(236)
		p.Match(Python3ParserCLOSE_PAREN)
	}



	return localctx
}


// ITypedargslistContext is an interface to support dynamic dispatch.
type ITypedargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedargslistContext differentiates from other interfaces.
	IsTypedargslistContext()
}

type TypedargslistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedargslistContext() *TypedargslistContext {
	var p = new(TypedargslistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_typedargslist
	return p
}

func (*TypedargslistContext) IsTypedargslistContext() {}

func NewTypedargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedargslistContext {
	var p = new(TypedargslistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_typedargslist

	return p
}

func (s *TypedargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedargslistContext) AllTfpdef() []ITfpdefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITfpdefContext)(nil)).Elem())
	var tst = make([]ITfpdefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITfpdefContext)
		}
	}

	return tst
}

func (s *TypedargslistContext) Tfpdef(i int) ITfpdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITfpdefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITfpdefContext)
}

func (s *TypedargslistContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *TypedargslistContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *TypedargslistContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserASSIGN)
}

func (s *TypedargslistContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, i)
}

func (s *TypedargslistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *TypedargslistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TypedargslistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *TypedargslistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *TypedargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypedargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTypedargslist(s)
	}
}

func (s *TypedargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTypedargslist(s)
	}
}




func (p *Python3Parser) Typedargslist() (localctx ITypedargslistContext) {
	localctx = NewTypedargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Python3ParserRULE_typedargslist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(319)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNAME:
		{
			p.SetState(238)
			p.Tfpdef()
		}
		p.SetState(241)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserASSIGN {
			{
				p.SetState(239)
				p.Match(Python3ParserASSIGN)
			}
			{
				p.SetState(240)
				p.Test()
			}

		}
		p.SetState(251)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(243)
					p.Match(Python3ParserCOMMA)
				}
				{
					p.SetState(244)
					p.Tfpdef()
				}
				p.SetState(247)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserASSIGN {
					{
						p.SetState(245)
						p.Match(Python3ParserASSIGN)
					}
					{
						p.SetState(246)
						p.Test()
					}

				}


			}
			p.SetState(253)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
		}
		p.SetState(287)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserCOMMA {
			{
				p.SetState(254)
				p.Match(Python3ParserCOMMA)
			}
			p.SetState(285)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTAR:
				{
					p.SetState(255)
					p.Match(Python3ParserSTAR)
				}
				p.SetState(257)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserNAME {
					{
						p.SetState(256)
						p.Tfpdef()
					}

				}
				p.SetState(267)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(259)
							p.Match(Python3ParserCOMMA)
						}
						{
							p.SetState(260)
							p.Tfpdef()
						}
						p.SetState(263)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)


						if _la == Python3ParserASSIGN {
							{
								p.SetState(261)
								p.Match(Python3ParserASSIGN)
							}
							{
								p.SetState(262)
								p.Test()
							}

						}


					}
					p.SetState(269)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())
				}
				p.SetState(278)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserCOMMA {
					{
						p.SetState(270)
						p.Match(Python3ParserCOMMA)
					}
					p.SetState(276)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)


					if _la == Python3ParserPOWER {
						{
							p.SetState(271)
							p.Match(Python3ParserPOWER)
						}
						{
							p.SetState(272)
							p.Tfpdef()
						}
						p.SetState(274)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)


						if _la == Python3ParserCOMMA {
							{
								p.SetState(273)
								p.Match(Python3ParserCOMMA)
							}

						}

					}

				}


			case Python3ParserPOWER:
				{
					p.SetState(280)
					p.Match(Python3ParserPOWER)
				}
				{
					p.SetState(281)
					p.Tfpdef()
				}
				p.SetState(283)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserCOMMA {
					{
						p.SetState(282)
						p.Match(Python3ParserCOMMA)
					}

				}


			case Python3ParserCLOSE_PAREN:



			default:
			}

		}


	case Python3ParserSTAR:
		{
			p.SetState(289)
			p.Match(Python3ParserSTAR)
		}
		p.SetState(291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserNAME {
			{
				p.SetState(290)
				p.Tfpdef()
			}

		}
		p.SetState(301)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(293)
					p.Match(Python3ParserCOMMA)
				}
				{
					p.SetState(294)
					p.Tfpdef()
				}
				p.SetState(297)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserASSIGN {
					{
						p.SetState(295)
						p.Match(Python3ParserASSIGN)
					}
					{
						p.SetState(296)
						p.Test()
					}

				}


			}
			p.SetState(303)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
		}
		p.SetState(312)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserCOMMA {
			{
				p.SetState(304)
				p.Match(Python3ParserCOMMA)
			}
			p.SetState(310)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python3ParserPOWER {
				{
					p.SetState(305)
					p.Match(Python3ParserPOWER)
				}
				{
					p.SetState(306)
					p.Tfpdef()
				}
				p.SetState(308)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserCOMMA {
					{
						p.SetState(307)
						p.Match(Python3ParserCOMMA)
					}

				}

			}

		}


	case Python3ParserPOWER:
		{
			p.SetState(314)
			p.Match(Python3ParserPOWER)
		}
		{
			p.SetState(315)
			p.Tfpdef()
		}
		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserCOMMA {
			{
				p.SetState(316)
				p.Match(Python3ParserCOMMA)
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// ITfpdefContext is an interface to support dynamic dispatch.
type ITfpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTfpdefContext differentiates from other interfaces.
	IsTfpdefContext()
}

type TfpdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfpdefContext() *TfpdefContext {
	var p = new(TfpdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_tfpdef
	return p
}

func (*TfpdefContext) IsTfpdefContext() {}

func NewTfpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TfpdefContext {
	var p = new(TfpdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_tfpdef

	return p
}

func (s *TfpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *TfpdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *TfpdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *TfpdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TfpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TfpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TfpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTfpdef(s)
	}
}

func (s *TfpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTfpdef(s)
	}
}




func (p *Python3Parser) Tfpdef() (localctx ITfpdefContext) {
	localctx = NewTfpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Python3ParserRULE_tfpdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(321)
		p.Match(Python3ParserNAME)
	}
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserCOLON {
		{
			p.SetState(322)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(323)
			p.Test()
		}

	}



	return localctx
}


// IVarargslistContext is an interface to support dynamic dispatch.
type IVarargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarargslistContext differentiates from other interfaces.
	IsVarargslistContext()
}

type VarargslistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarargslistContext() *VarargslistContext {
	var p = new(VarargslistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_varargslist
	return p
}

func (*VarargslistContext) IsVarargslistContext() {}

func NewVarargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarargslistContext {
	var p = new(VarargslistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_varargslist

	return p
}

func (s *VarargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *VarargslistContext) AllVfpdef() []IVfpdefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVfpdefContext)(nil)).Elem())
	var tst = make([]IVfpdefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVfpdefContext)
		}
	}

	return tst
}

func (s *VarargslistContext) Vfpdef(i int) IVfpdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVfpdefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVfpdefContext)
}

func (s *VarargslistContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *VarargslistContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *VarargslistContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserASSIGN)
}

func (s *VarargslistContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, i)
}

func (s *VarargslistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *VarargslistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *VarargslistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *VarargslistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *VarargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VarargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterVarargslist(s)
	}
}

func (s *VarargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitVarargslist(s)
	}
}




func (p *Python3Parser) Varargslist() (localctx IVarargslistContext) {
	localctx = NewVarargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Python3ParserRULE_varargslist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(407)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNAME:
		{
			p.SetState(326)
			p.Vfpdef()
		}
		p.SetState(329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserASSIGN {
			{
				p.SetState(327)
				p.Match(Python3ParserASSIGN)
			}
			{
				p.SetState(328)
				p.Test()
			}

		}
		p.SetState(339)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(331)
					p.Match(Python3ParserCOMMA)
				}
				{
					p.SetState(332)
					p.Vfpdef()
				}
				p.SetState(335)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserASSIGN {
					{
						p.SetState(333)
						p.Match(Python3ParserASSIGN)
					}
					{
						p.SetState(334)
						p.Test()
					}

				}


			}
			p.SetState(341)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())
		}
		p.SetState(375)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserCOMMA {
			{
				p.SetState(342)
				p.Match(Python3ParserCOMMA)
			}
			p.SetState(373)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTAR:
				{
					p.SetState(343)
					p.Match(Python3ParserSTAR)
				}
				p.SetState(345)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserNAME {
					{
						p.SetState(344)
						p.Vfpdef()
					}

				}
				p.SetState(355)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(347)
							p.Match(Python3ParserCOMMA)
						}
						{
							p.SetState(348)
							p.Vfpdef()
						}
						p.SetState(351)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)


						if _la == Python3ParserASSIGN {
							{
								p.SetState(349)
								p.Match(Python3ParserASSIGN)
							}
							{
								p.SetState(350)
								p.Test()
							}

						}


					}
					p.SetState(357)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
				}
				p.SetState(366)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserCOMMA {
					{
						p.SetState(358)
						p.Match(Python3ParserCOMMA)
					}
					p.SetState(364)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)


					if _la == Python3ParserPOWER {
						{
							p.SetState(359)
							p.Match(Python3ParserPOWER)
						}
						{
							p.SetState(360)
							p.Vfpdef()
						}
						p.SetState(362)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)


						if _la == Python3ParserCOMMA {
							{
								p.SetState(361)
								p.Match(Python3ParserCOMMA)
							}

						}

					}

				}


			case Python3ParserPOWER:
				{
					p.SetState(368)
					p.Match(Python3ParserPOWER)
				}
				{
					p.SetState(369)
					p.Vfpdef()
				}
				p.SetState(371)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserCOMMA {
					{
						p.SetState(370)
						p.Match(Python3ParserCOMMA)
					}

				}


			case Python3ParserCOLON:



			default:
			}

		}


	case Python3ParserSTAR:
		{
			p.SetState(377)
			p.Match(Python3ParserSTAR)
		}
		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserNAME {
			{
				p.SetState(378)
				p.Vfpdef()
			}

		}
		p.SetState(389)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(381)
					p.Match(Python3ParserCOMMA)
				}
				{
					p.SetState(382)
					p.Vfpdef()
				}
				p.SetState(385)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserASSIGN {
					{
						p.SetState(383)
						p.Match(Python3ParserASSIGN)
					}
					{
						p.SetState(384)
						p.Test()
					}

				}


			}
			p.SetState(391)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())
		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserCOMMA {
			{
				p.SetState(392)
				p.Match(Python3ParserCOMMA)
			}
			p.SetState(398)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python3ParserPOWER {
				{
					p.SetState(393)
					p.Match(Python3ParserPOWER)
				}
				{
					p.SetState(394)
					p.Vfpdef()
				}
				p.SetState(396)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python3ParserCOMMA {
					{
						p.SetState(395)
						p.Match(Python3ParserCOMMA)
					}

				}

			}

		}


	case Python3ParserPOWER:
		{
			p.SetState(402)
			p.Match(Python3ParserPOWER)
		}
		{
			p.SetState(403)
			p.Vfpdef()
		}
		p.SetState(405)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserCOMMA {
			{
				p.SetState(404)
				p.Match(Python3ParserCOMMA)
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IVfpdefContext is an interface to support dynamic dispatch.
type IVfpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVfpdefContext differentiates from other interfaces.
	IsVfpdefContext()
}

type VfpdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVfpdefContext() *VfpdefContext {
	var p = new(VfpdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_vfpdef
	return p
}

func (*VfpdefContext) IsVfpdefContext() {}

func NewVfpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VfpdefContext {
	var p = new(VfpdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_vfpdef

	return p
}

func (s *VfpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *VfpdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *VfpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VfpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VfpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterVfpdef(s)
	}
}

func (s *VfpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitVfpdef(s)
	}
}




func (p *Python3Parser) Vfpdef() (localctx IVfpdefContext) {
	localctx = NewVfpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Python3ParserRULE_vfpdef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.Match(Python3ParserNAME)
	}



	return localctx
}


// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_stmt
	return p
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *StmtContext) Compound_stmt() ICompound_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitStmt(s)
	}
}




func (p *Python3Parser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Python3ParserRULE_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(413)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(411)
			p.Simple_stmt()
		}


	case Python3ParserDEF, Python3ParserIF, Python3ParserWHILE, Python3ParserFOR, Python3ParserTRY, Python3ParserWITH, Python3ParserCLASS, Python3ParserASYNC, Python3ParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(412)
			p.Compound_stmt()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ISimple_stmtContext is an interface to support dynamic dispatch.
type ISimple_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_stmtContext differentiates from other interfaces.
	IsSimple_stmtContext()
}

type Simple_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_stmtContext() *Simple_stmtContext {
	var p = new(Simple_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_simple_stmt
	return p
}

func (*Simple_stmtContext) IsSimple_stmtContext() {}

func NewSimple_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_stmtContext {
	var p = new(Simple_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_simple_stmt

	return p
}

func (s *Simple_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_stmtContext) AllSmall_stmt() []ISmall_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISmall_stmtContext)(nil)).Elem())
	var tst = make([]ISmall_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISmall_stmtContext)
		}
	}

	return tst
}

func (s *Simple_stmtContext) Small_stmt(i int) ISmall_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISmall_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISmall_stmtContext)
}

func (s *Simple_stmtContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *Simple_stmtContext) AllSEMI_COLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSEMI_COLON)
}

func (s *Simple_stmtContext) SEMI_COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSEMI_COLON, i)
}

func (s *Simple_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Simple_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSimple_stmt(s)
	}
}




func (p *Python3Parser) Simple_stmt() (localctx ISimple_stmtContext) {
	localctx = NewSimple_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Python3ParserRULE_simple_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Small_stmt()
	}
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(416)
				p.Match(Python3ParserSEMI_COLON)
			}
			{
				p.SetState(417)
				p.Small_stmt()
			}


		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}
	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserSEMI_COLON {
		{
			p.SetState(423)
			p.Match(Python3ParserSEMI_COLON)
		}

	}
	{
		p.SetState(426)
		p.Match(Python3ParserNEWLINE)
	}



	return localctx
}


// ISmall_stmtContext is an interface to support dynamic dispatch.
type ISmall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSmall_stmtContext differentiates from other interfaces.
	IsSmall_stmtContext()
}

type Small_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySmall_stmtContext() *Small_stmtContext {
	var p = new(Small_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_small_stmt
	return p
}

func (*Small_stmtContext) IsSmall_stmtContext() {}

func NewSmall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Small_stmtContext {
	var p = new(Small_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_small_stmt

	return p
}

func (s *Small_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Small_stmtContext) Expr_stmt() IExpr_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *Small_stmtContext) Del_stmt() IDel_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDel_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDel_stmtContext)
}

func (s *Small_stmtContext) Pass_stmt() IPass_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_stmtContext)
}

func (s *Small_stmtContext) Flow_stmt() IFlow_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_stmtContext)
}

func (s *Small_stmtContext) Import_stmt() IImport_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Small_stmtContext) Global_stmt() IGlobal_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobal_stmtContext)
}

func (s *Small_stmtContext) Nonlocal_stmt() INonlocal_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonlocal_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonlocal_stmtContext)
}

func (s *Small_stmtContext) Assert_stmt() IAssert_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssert_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssert_stmtContext)
}

func (s *Small_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Small_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Small_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSmall_stmt(s)
	}
}

func (s *Small_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSmall_stmt(s)
	}
}




func (p *Python3Parser) Small_stmt() (localctx ISmall_stmtContext) {
	localctx = NewSmall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Python3ParserRULE_small_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(436)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(428)
			p.Expr_stmt()
		}


	case Python3ParserDEL:
		{
			p.SetState(429)
			p.Del_stmt()
		}


	case Python3ParserPASS:
		{
			p.SetState(430)
			p.Pass_stmt()
		}


	case Python3ParserRETURN, Python3ParserRAISE, Python3ParserYIELD, Python3ParserCONTINUE, Python3ParserBREAK:
		{
			p.SetState(431)
			p.Flow_stmt()
		}


	case Python3ParserFROM, Python3ParserIMPORT:
		{
			p.SetState(432)
			p.Import_stmt()
		}


	case Python3ParserGLOBAL:
		{
			p.SetState(433)
			p.Global_stmt()
		}


	case Python3ParserNONLOCAL:
		{
			p.SetState(434)
			p.Nonlocal_stmt()
		}


	case Python3ParserASSERT:
		{
			p.SetState(435)
			p.Assert_stmt()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_expr_stmt
	return p
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) AllTestlist_star_expr() []ITestlist_star_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestlist_star_exprContext)(nil)).Elem())
	var tst = make([]ITestlist_star_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestlist_star_exprContext)
		}
	}

	return tst
}

func (s *Expr_stmtContext) Testlist_star_expr(i int) ITestlist_star_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_star_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestlist_star_exprContext)
}

func (s *Expr_stmtContext) Annassign() IAnnassignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnassignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnassignContext)
}

func (s *Expr_stmtContext) Augassign() IAugassignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAugassignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAugassignContext)
}

func (s *Expr_stmtContext) AllYield_expr() []IYield_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IYield_exprContext)(nil)).Elem())
	var tst = make([]IYield_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IYield_exprContext)
		}
	}

	return tst
}

func (s *Expr_stmtContext) Yield_expr(i int) IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Expr_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Expr_stmtContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserASSIGN)
}

func (s *Expr_stmtContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, i)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}




func (p *Python3Parser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Python3ParserRULE_expr_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(438)
		p.Testlist_star_expr()
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserCOLON:
		{
			p.SetState(439)
			p.Annassign()
		}


	case Python3ParserADD_ASSIGN, Python3ParserSUB_ASSIGN, Python3ParserMULT_ASSIGN, Python3ParserAT_ASSIGN, Python3ParserDIV_ASSIGN, Python3ParserMOD_ASSIGN, Python3ParserAND_ASSIGN, Python3ParserOR_ASSIGN, Python3ParserXOR_ASSIGN, Python3ParserLEFT_SHIFT_ASSIGN, Python3ParserRIGHT_SHIFT_ASSIGN, Python3ParserPOWER_ASSIGN, Python3ParserIDIV_ASSIGN:
		{
			p.SetState(440)
			p.Augassign()
		}
		p.SetState(443)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserYIELD:
			{
				p.SetState(441)
				p.Yield_expr()
			}


		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(442)
				p.Testlist()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}


	case Python3ParserNEWLINE, Python3ParserSEMI_COLON, Python3ParserASSIGN:
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == Python3ParserASSIGN {
			{
				p.SetState(445)
				p.Match(Python3ParserASSIGN)
			}
			p.SetState(448)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Python3ParserYIELD:
				{
					p.SetState(446)
					p.Yield_expr()
				}


			case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
				{
					p.SetState(447)
					p.Testlist_star_expr()
				}



			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}


			p.SetState(454)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IAnnassignContext is an interface to support dynamic dispatch.
type IAnnassignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnassignContext differentiates from other interfaces.
	IsAnnassignContext()
}

type AnnassignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnassignContext() *AnnassignContext {
	var p = new(AnnassignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_annassign
	return p
}

func (*AnnassignContext) IsAnnassignContext() {}

func NewAnnassignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnassignContext {
	var p = new(AnnassignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_annassign

	return p
}

func (s *AnnassignContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnassignContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *AnnassignContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *AnnassignContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *AnnassignContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, 0)
}

func (s *AnnassignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnassignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AnnassignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAnnassign(s)
	}
}

func (s *AnnassignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAnnassign(s)
	}
}




func (p *Python3Parser) Annassign() (localctx IAnnassignContext) {
	localctx = NewAnnassignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Python3ParserRULE_annassign)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(458)
		p.Test()
	}
	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserASSIGN {
		{
			p.SetState(459)
			p.Match(Python3ParserASSIGN)
		}
		{
			p.SetState(460)
			p.Test()
		}

	}



	return localctx
}


// ITestlist_star_exprContext is an interface to support dynamic dispatch.
type ITestlist_star_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist_star_exprContext differentiates from other interfaces.
	IsTestlist_star_exprContext()
}

type Testlist_star_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_star_exprContext() *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_star_expr
	return p
}

func (*Testlist_star_exprContext) IsTestlist_star_exprContext() {}

func NewTestlist_star_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist_star_expr

	return p
}

func (s *Testlist_star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_star_exprContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_star_exprContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_star_exprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Testlist_star_exprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Testlist_star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Testlist_star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTestlist_star_expr(s)
	}
}

func (s *Testlist_star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTestlist_star_expr(s)
	}
}




func (p *Python3Parser) Testlist_star_expr() (localctx ITestlist_star_exprContext) {
	localctx = NewTestlist_star_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Python3ParserRULE_testlist_star_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(465)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(463)
			p.Test()
		}


	case Python3ParserSTAR:
		{
			p.SetState(464)
			p.Star_expr()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(467)
				p.Match(Python3ParserCOMMA)
			}
			p.SetState(470)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
				{
					p.SetState(468)
					p.Test()
				}


			case Python3ParserSTAR:
				{
					p.SetState(469)
					p.Star_expr()
				}



			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}


		}
		p.SetState(476)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserCOMMA {
		{
			p.SetState(477)
			p.Match(Python3ParserCOMMA)
		}

	}



	return localctx
}


// IAugassignContext is an interface to support dynamic dispatch.
type IAugassignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAugassignContext differentiates from other interfaces.
	IsAugassignContext()
}

type AugassignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAugassignContext() *AugassignContext {
	var p = new(AugassignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_augassign
	return p
}

func (*AugassignContext) IsAugassignContext() {}

func NewAugassignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AugassignContext {
	var p = new(AugassignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_augassign

	return p
}

func (s *AugassignContext) GetParser() antlr.Parser { return s.parser }

func (s *AugassignContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserADD_ASSIGN, 0)
}

func (s *AugassignContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserSUB_ASSIGN, 0)
}

func (s *AugassignContext) MULT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserMULT_ASSIGN, 0)
}

func (s *AugassignContext) AT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserAT_ASSIGN, 0)
}

func (s *AugassignContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserDIV_ASSIGN, 0)
}

func (s *AugassignContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserMOD_ASSIGN, 0)
}

func (s *AugassignContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserAND_ASSIGN, 0)
}

func (s *AugassignContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOR_ASSIGN, 0)
}

func (s *AugassignContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserXOR_ASSIGN, 0)
}

func (s *AugassignContext) LEFT_SHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserLEFT_SHIFT_ASSIGN, 0)
}

func (s *AugassignContext) RIGHT_SHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserRIGHT_SHIFT_ASSIGN, 0)
}

func (s *AugassignContext) POWER_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER_ASSIGN, 0)
}

func (s *AugassignContext) IDIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIDIV_ASSIGN, 0)
}

func (s *AugassignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AugassignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AugassignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAugassign(s)
	}
}

func (s *AugassignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAugassign(s)
	}
}




func (p *Python3Parser) Augassign() (localctx IAugassignContext) {
	localctx = NewAugassignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Python3ParserRULE_augassign)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(480)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 85)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 85))) & ((1 << (Python3ParserADD_ASSIGN - 85)) | (1 << (Python3ParserSUB_ASSIGN - 85)) | (1 << (Python3ParserMULT_ASSIGN - 85)) | (1 << (Python3ParserAT_ASSIGN - 85)) | (1 << (Python3ParserDIV_ASSIGN - 85)) | (1 << (Python3ParserMOD_ASSIGN - 85)) | (1 << (Python3ParserAND_ASSIGN - 85)) | (1 << (Python3ParserOR_ASSIGN - 85)) | (1 << (Python3ParserXOR_ASSIGN - 85)) | (1 << (Python3ParserLEFT_SHIFT_ASSIGN - 85)) | (1 << (Python3ParserRIGHT_SHIFT_ASSIGN - 85)) | (1 << (Python3ParserPOWER_ASSIGN - 85)) | (1 << (Python3ParserIDIV_ASSIGN - 85)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IDel_stmtContext is an interface to support dynamic dispatch.
type IDel_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDel_stmtContext differentiates from other interfaces.
	IsDel_stmtContext()
}

type Del_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDel_stmtContext() *Del_stmtContext {
	var p = new(Del_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_del_stmt
	return p
}

func (*Del_stmtContext) IsDel_stmtContext() {}

func NewDel_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Del_stmtContext {
	var p = new(Del_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_del_stmt

	return p
}

func (s *Del_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Del_stmtContext) DEL() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEL, 0)
}

func (s *Del_stmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Del_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Del_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Del_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDel_stmt(s)
	}
}

func (s *Del_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDel_stmt(s)
	}
}




func (p *Python3Parser) Del_stmt() (localctx IDel_stmtContext) {
	localctx = NewDel_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Python3ParserRULE_del_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.Match(Python3ParserDEL)
	}
	{
		p.SetState(483)
		p.Exprlist()
	}



	return localctx
}


// IPass_stmtContext is an interface to support dynamic dispatch.
type IPass_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_stmtContext differentiates from other interfaces.
	IsPass_stmtContext()
}

type Pass_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_stmtContext() *Pass_stmtContext {
	var p = new(Pass_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_pass_stmt
	return p
}

func (*Pass_stmtContext) IsPass_stmtContext() {}

func NewPass_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_stmtContext {
	var p = new(Pass_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_pass_stmt

	return p
}

func (s *Pass_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_stmtContext) PASS() antlr.TerminalNode {
	return s.GetToken(Python3ParserPASS, 0)
}

func (s *Pass_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pass_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterPass_stmt(s)
	}
}

func (s *Pass_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitPass_stmt(s)
	}
}




func (p *Python3Parser) Pass_stmt() (localctx IPass_stmtContext) {
	localctx = NewPass_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Python3ParserRULE_pass_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(Python3ParserPASS)
	}



	return localctx
}


// IFlow_stmtContext is an interface to support dynamic dispatch.
type IFlow_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_stmtContext differentiates from other interfaces.
	IsFlow_stmtContext()
}

type Flow_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_stmtContext() *Flow_stmtContext {
	var p = new(Flow_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_flow_stmt
	return p
}

func (*Flow_stmtContext) IsFlow_stmtContext() {}

func NewFlow_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_stmtContext {
	var p = new(Flow_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_flow_stmt

	return p
}

func (s *Flow_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_stmtContext) Break_stmt() IBreak_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_stmtContext)
}

func (s *Flow_stmtContext) Continue_stmt() IContinue_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinue_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinue_stmtContext)
}

func (s *Flow_stmtContext) Return_stmt() IReturn_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_stmtContext)
}

func (s *Flow_stmtContext) Raise_stmt() IRaise_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaise_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaise_stmtContext)
}

func (s *Flow_stmtContext) Yield_stmt() IYield_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_stmtContext)
}

func (s *Flow_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Flow_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFlow_stmt(s)
	}
}

func (s *Flow_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFlow_stmt(s)
	}
}




func (p *Python3Parser) Flow_stmt() (localctx IFlow_stmtContext) {
	localctx = NewFlow_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Python3ParserRULE_flow_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(492)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserBREAK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(487)
			p.Break_stmt()
		}


	case Python3ParserCONTINUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(488)
			p.Continue_stmt()
		}


	case Python3ParserRETURN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(489)
			p.Return_stmt()
		}


	case Python3ParserRAISE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(490)
			p.Raise_stmt()
		}


	case Python3ParserYIELD:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(491)
			p.Yield_stmt()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IBreak_stmtContext is an interface to support dynamic dispatch.
type IBreak_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_stmtContext differentiates from other interfaces.
	IsBreak_stmtContext()
}

type Break_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_stmtContext() *Break_stmtContext {
	var p = new(Break_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_break_stmt
	return p
}

func (*Break_stmtContext) IsBreak_stmtContext() {}

func NewBreak_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_stmtContext {
	var p = new(Break_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_break_stmt

	return p
}

func (s *Break_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_stmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(Python3ParserBREAK, 0)
}

func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}




func (p *Python3Parser) Break_stmt() (localctx IBreak_stmtContext) {
	localctx = NewBreak_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Python3ParserRULE_break_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(494)
		p.Match(Python3ParserBREAK)
	}



	return localctx
}


// IContinue_stmtContext is an interface to support dynamic dispatch.
type IContinue_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinue_stmtContext differentiates from other interfaces.
	IsContinue_stmtContext()
}

type Continue_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinue_stmtContext() *Continue_stmtContext {
	var p = new(Continue_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_continue_stmt
	return p
}

func (*Continue_stmtContext) IsContinue_stmtContext() {}

func NewContinue_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continue_stmtContext {
	var p = new(Continue_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_continue_stmt

	return p
}

func (s *Continue_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Continue_stmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCONTINUE, 0)
}

func (s *Continue_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Continue_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitContinue_stmt(s)
	}
}




func (p *Python3Parser) Continue_stmt() (localctx IContinue_stmtContext) {
	localctx = NewContinue_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Python3ParserRULE_continue_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Match(Python3ParserCONTINUE)
	}



	return localctx
}


// IReturn_stmtContext is an interface to support dynamic dispatch.
type IReturn_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_stmtContext differentiates from other interfaces.
	IsReturn_stmtContext()
}

type Return_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_stmtContext() *Return_stmtContext {
	var p = new(Return_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_return_stmt
	return p
}

func (*Return_stmtContext) IsReturn_stmtContext() {}

func NewReturn_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_stmtContext {
	var p = new(Return_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_return_stmt

	return p
}

func (s *Return_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(Python3ParserRETURN, 0)
}

func (s *Return_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}




func (p *Python3Parser) Return_stmt() (localctx IReturn_stmtContext) {
	localctx = NewReturn_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Python3ParserRULE_return_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Match(Python3ParserRETURN)
	}
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
		{
			p.SetState(499)
			p.Testlist()
		}

	}



	return localctx
}


// IYield_stmtContext is an interface to support dynamic dispatch.
type IYield_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_stmtContext differentiates from other interfaces.
	IsYield_stmtContext()
}

type Yield_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_stmtContext() *Yield_stmtContext {
	var p = new(Yield_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_stmt
	return p
}

func (*Yield_stmtContext) IsYield_stmtContext() {}

func NewYield_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_stmtContext {
	var p = new(Yield_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_stmt

	return p
}

func (s *Yield_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_stmtContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Yield_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Yield_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterYield_stmt(s)
	}
}

func (s *Yield_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitYield_stmt(s)
	}
}




func (p *Python3Parser) Yield_stmt() (localctx IYield_stmtContext) {
	localctx = NewYield_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Python3ParserRULE_yield_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(502)
		p.Yield_expr()
	}



	return localctx
}


// IRaise_stmtContext is an interface to support dynamic dispatch.
type IRaise_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRaise_stmtContext differentiates from other interfaces.
	IsRaise_stmtContext()
}

type Raise_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaise_stmtContext() *Raise_stmtContext {
	var p = new(Raise_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_raise_stmt
	return p
}

func (*Raise_stmtContext) IsRaise_stmtContext() {}

func NewRaise_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_raise_stmt

	return p
}

func (s *Raise_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Raise_stmtContext) RAISE() antlr.TerminalNode {
	return s.GetToken(Python3ParserRAISE, 0)
}

func (s *Raise_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Raise_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Raise_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}




func (p *Python3Parser) Raise_stmt() (localctx IRaise_stmtContext) {
	localctx = NewRaise_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Python3ParserRULE_raise_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(504)
		p.Match(Python3ParserRAISE)
	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
		{
			p.SetState(505)
			p.Test()
		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserFROM {
			{
				p.SetState(506)
				p.Match(Python3ParserFROM)
			}
			{
				p.SetState(507)
				p.Test()
			}

		}

	}



	return localctx
}


// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_import_stmt
	return p
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) Import_name() IImport_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_nameContext)
}

func (s *Import_stmtContext) Import_from() IImport_fromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_fromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_fromContext)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_stmt(s)
	}
}




func (p *Python3Parser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Python3ParserRULE_import_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(514)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserIMPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(512)
			p.Import_name()
		}


	case Python3ParserFROM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(513)
			p.Import_from()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IImport_nameContext is an interface to support dynamic dispatch.
type IImport_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_nameContext differentiates from other interfaces.
	IsImport_nameContext()
}

type Import_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_nameContext() *Import_nameContext {
	var p = new(Import_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_import_name
	return p
}

func (*Import_nameContext) IsImport_nameContext() {}

func NewImport_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_nameContext {
	var p = new(Import_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_name

	return p
}

func (s *Import_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_nameContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMPORT, 0)
}

func (s *Import_nameContext) Dotted_as_names() IDotted_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_as_namesContext)
}

func (s *Import_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_name(s)
	}
}

func (s *Import_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_name(s)
	}
}




func (p *Python3Parser) Import_name() (localctx IImport_nameContext) {
	localctx = NewImport_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Python3ParserRULE_import_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(516)
		p.Match(Python3ParserIMPORT)
	}
	{
		p.SetState(517)
		p.Dotted_as_names()
	}



	return localctx
}


// IImport_fromContext is an interface to support dynamic dispatch.
type IImport_fromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_fromContext differentiates from other interfaces.
	IsImport_fromContext()
}

type Import_fromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_fromContext() *Import_fromContext {
	var p = new(Import_fromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_import_from
	return p
}

func (*Import_fromContext) IsImport_fromContext() {}

func NewImport_fromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_fromContext {
	var p = new(Import_fromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_from

	return p
}

func (s *Import_fromContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_fromContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Import_fromContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMPORT, 0)
}

func (s *Import_fromContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Import_fromContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Import_fromContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *Import_fromContext) Import_as_names() IImport_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_as_namesContext)
}

func (s *Import_fromContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *Import_fromContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDOT)
}

func (s *Import_fromContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, i)
}

func (s *Import_fromContext) AllELLIPSIS() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserELLIPSIS)
}

func (s *Import_fromContext) ELLIPSIS(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserELLIPSIS, i)
}

func (s *Import_fromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_fromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_fromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_from(s)
	}
}

func (s *Import_fromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_from(s)
	}
}




func (p *Python3Parser) Import_from() (localctx IImport_fromContext) {
	localctx = NewImport_fromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Python3ParserRULE_import_from)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)
		p.Match(Python3ParserFROM)
	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == Python3ParserDOT || _la == Python3ParserELLIPSIS {
			{
				p.SetState(520)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Python3ParserDOT || _la == Python3ParserELLIPSIS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


			p.SetState(525)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(526)
			p.Dotted_name()
		}


	case 2:
		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == Python3ParserDOT || _la == Python3ParserELLIPSIS {
			{
				p.SetState(527)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Python3ParserDOT || _la == Python3ParserELLIPSIS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


			p.SetState(530)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(534)
		p.Match(Python3ParserIMPORT)
	}
	p.SetState(541)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTAR:
		{
			p.SetState(535)
			p.Match(Python3ParserSTAR)
		}


	case Python3ParserOPEN_PAREN:
		{
			p.SetState(536)
			p.Match(Python3ParserOPEN_PAREN)
		}
		{
			p.SetState(537)
			p.Import_as_names()
		}
		{
			p.SetState(538)
			p.Match(Python3ParserCLOSE_PAREN)
		}


	case Python3ParserNAME:
		{
			p.SetState(540)
			p.Import_as_names()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}




	return localctx
}


// IImport_as_nameContext is an interface to support dynamic dispatch.
type IImport_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_as_nameContext differentiates from other interfaces.
	IsImport_as_nameContext()
}

type Import_as_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_nameContext() *Import_as_nameContext {
	var p = new(Import_as_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_name
	return p
}

func (*Import_as_nameContext) IsImport_as_nameContext() {}

func NewImport_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_nameContext {
	var p = new(Import_as_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_as_name

	return p
}

func (s *Import_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Import_as_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Import_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Import_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_as_name(s)
	}
}

func (s *Import_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_as_name(s)
	}
}




func (p *Python3Parser) Import_as_name() (localctx IImport_as_nameContext) {
	localctx = NewImport_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Python3ParserRULE_import_as_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.Match(Python3ParserNAME)
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserAS {
		{
			p.SetState(544)
			p.Match(Python3ParserAS)
		}
		{
			p.SetState(545)
			p.Match(Python3ParserNAME)
		}

	}



	return localctx
}


// IDotted_as_nameContext is an interface to support dynamic dispatch.
type IDotted_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_as_nameContext differentiates from other interfaces.
	IsDotted_as_nameContext()
}

type Dotted_as_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_nameContext() *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_name
	return p
}

func (*Dotted_as_nameContext) IsDotted_as_nameContext() {}

func NewDotted_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_as_name

	return p
}

func (s *Dotted_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_nameContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Dotted_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Dotted_as_nameContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *Dotted_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dotted_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDotted_as_name(s)
	}
}




func (p *Python3Parser) Dotted_as_name() (localctx IDotted_as_nameContext) {
	localctx = NewDotted_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Python3ParserRULE_dotted_as_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		p.Dotted_name()
	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserAS {
		{
			p.SetState(549)
			p.Match(Python3ParserAS)
		}
		{
			p.SetState(550)
			p.Match(Python3ParserNAME)
		}

	}



	return localctx
}


// IImport_as_namesContext is an interface to support dynamic dispatch.
type IImport_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_as_namesContext differentiates from other interfaces.
	IsImport_as_namesContext()
}

type Import_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_namesContext() *Import_as_namesContext {
	var p = new(Import_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_names
	return p
}

func (*Import_as_namesContext) IsImport_as_namesContext() {}

func NewImport_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_namesContext {
	var p = new(Import_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_as_names

	return p
}

func (s *Import_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_namesContext) AllImport_as_name() []IImport_as_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_as_nameContext)(nil)).Elem())
	var tst = make([]IImport_as_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_as_nameContext)
		}
	}

	return tst
}

func (s *Import_as_namesContext) Import_as_name(i int) IImport_as_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_as_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_as_nameContext)
}

func (s *Import_as_namesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Import_as_namesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Import_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_as_names(s)
	}
}

func (s *Import_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_as_names(s)
	}
}




func (p *Python3Parser) Import_as_names() (localctx IImport_as_namesContext) {
	localctx = NewImport_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Python3ParserRULE_import_as_names)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Import_as_name()
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(554)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(555)
				p.Import_as_name()
			}


		}
		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserCOMMA {
		{
			p.SetState(561)
			p.Match(Python3ParserCOMMA)
		}

	}



	return localctx
}


// IDotted_as_namesContext is an interface to support dynamic dispatch.
type IDotted_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_as_namesContext differentiates from other interfaces.
	IsDotted_as_namesContext()
}

type Dotted_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_namesContext() *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_names
	return p
}

func (*Dotted_as_namesContext) IsDotted_as_namesContext() {}

func NewDotted_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_as_names

	return p
}

func (s *Dotted_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_namesContext) AllDotted_as_name() []IDotted_as_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDotted_as_nameContext)(nil)).Elem())
	var tst = make([]IDotted_as_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDotted_as_nameContext)
		}
	}

	return tst
}

func (s *Dotted_as_namesContext) Dotted_as_name(i int) IDotted_as_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_as_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDotted_as_nameContext)
}

func (s *Dotted_as_namesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Dotted_as_namesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Dotted_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dotted_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDotted_as_names(s)
	}
}




func (p *Python3Parser) Dotted_as_names() (localctx IDotted_as_namesContext) {
	localctx = NewDotted_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Python3ParserRULE_dotted_as_names)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Dotted_as_name()
	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserCOMMA {
		{
			p.SetState(565)
			p.Match(Python3ParserCOMMA)
		}
		{
			p.SetState(566)
			p.Dotted_as_name()
		}


		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IDotted_nameContext is an interface to support dynamic dispatch.
type IDotted_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_nameContext differentiates from other interfaces.
	IsDotted_nameContext()
}

type Dotted_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_nameContext() *Dotted_nameContext {
	var p = new(Dotted_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_name
	return p
}

func (*Dotted_nameContext) IsDotted_nameContext() {}

func NewDotted_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_nameContext {
	var p = new(Dotted_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_name

	return p
}

func (s *Dotted_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Dotted_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Dotted_nameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDOT)
}

func (s *Dotted_nameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, i)
}

func (s *Dotted_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dotted_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDotted_name(s)
	}
}

func (s *Dotted_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDotted_name(s)
	}
}




func (p *Python3Parser) Dotted_name() (localctx IDotted_nameContext) {
	localctx = NewDotted_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Python3ParserRULE_dotted_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Match(Python3ParserNAME)
	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserDOT {
		{
			p.SetState(573)
			p.Match(Python3ParserDOT)
		}
		{
			p.SetState(574)
			p.Match(Python3ParserNAME)
		}


		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IGlobal_stmtContext is an interface to support dynamic dispatch.
type IGlobal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobal_stmtContext differentiates from other interfaces.
	IsGlobal_stmtContext()
}

type Global_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_stmtContext() *Global_stmtContext {
	var p = new(Global_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_global_stmt
	return p
}

func (*Global_stmtContext) IsGlobal_stmtContext() {}

func NewGlobal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_stmtContext {
	var p = new(Global_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_global_stmt

	return p
}

func (s *Global_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_stmtContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserGLOBAL, 0)
}

func (s *Global_stmtContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Global_stmtContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Global_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Global_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Global_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Global_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitGlobal_stmt(s)
	}
}




func (p *Python3Parser) Global_stmt() (localctx IGlobal_stmtContext) {
	localctx = NewGlobal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Python3ParserRULE_global_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Match(Python3ParserGLOBAL)
	}
	{
		p.SetState(581)
		p.Match(Python3ParserNAME)
	}
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserCOMMA {
		{
			p.SetState(582)
			p.Match(Python3ParserCOMMA)
		}
		{
			p.SetState(583)
			p.Match(Python3ParserNAME)
		}


		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// INonlocal_stmtContext is an interface to support dynamic dispatch.
type INonlocal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonlocal_stmtContext differentiates from other interfaces.
	IsNonlocal_stmtContext()
}

type Nonlocal_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonlocal_stmtContext() *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_nonlocal_stmt
	return p
}

func (*Nonlocal_stmtContext) IsNonlocal_stmtContext() {}

func NewNonlocal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_nonlocal_stmt

	return p
}

func (s *Nonlocal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonlocal_stmtContext) NONLOCAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONLOCAL, 0)
}

func (s *Nonlocal_stmtContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Nonlocal_stmtContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Nonlocal_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Nonlocal_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Nonlocal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonlocal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Nonlocal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterNonlocal_stmt(s)
	}
}

func (s *Nonlocal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitNonlocal_stmt(s)
	}
}




func (p *Python3Parser) Nonlocal_stmt() (localctx INonlocal_stmtContext) {
	localctx = NewNonlocal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Python3ParserRULE_nonlocal_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(589)
		p.Match(Python3ParserNONLOCAL)
	}
	{
		p.SetState(590)
		p.Match(Python3ParserNAME)
	}
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserCOMMA {
		{
			p.SetState(591)
			p.Match(Python3ParserCOMMA)
		}
		{
			p.SetState(592)
			p.Match(Python3ParserNAME)
		}


		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAssert_stmtContext is an interface to support dynamic dispatch.
type IAssert_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssert_stmtContext differentiates from other interfaces.
	IsAssert_stmtContext()
}

type Assert_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssert_stmtContext() *Assert_stmtContext {
	var p = new(Assert_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_assert_stmt
	return p
}

func (*Assert_stmtContext) IsAssert_stmtContext() {}

func NewAssert_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assert_stmtContext {
	var p = new(Assert_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_assert_stmt

	return p
}

func (s *Assert_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Assert_stmtContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSERT, 0)
}

func (s *Assert_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Assert_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Assert_stmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, 0)
}

func (s *Assert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAssert_stmt(s)
	}
}




func (p *Python3Parser) Assert_stmt() (localctx IAssert_stmtContext) {
	localctx = NewAssert_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Python3ParserRULE_assert_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		p.Match(Python3ParserASSERT)
	}
	{
		p.SetState(599)
		p.Test()
	}
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserCOMMA {
		{
			p.SetState(600)
			p.Match(Python3ParserCOMMA)
		}
		{
			p.SetState(601)
			p.Test()
		}

	}



	return localctx
}


// ICompound_stmtContext is an interface to support dynamic dispatch.
type ICompound_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_stmtContext differentiates from other interfaces.
	IsCompound_stmtContext()
}

type Compound_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_stmtContext() *Compound_stmtContext {
	var p = new(Compound_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_compound_stmt
	return p
}

func (*Compound_stmtContext) IsCompound_stmtContext() {}

func NewCompound_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_stmtContext {
	var p = new(Compound_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_compound_stmt

	return p
}

func (s *Compound_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_stmtContext) If_stmt() IIf_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *Compound_stmtContext) While_stmt() IWhile_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhile_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhile_stmtContext)
}

func (s *Compound_stmtContext) For_stmt() IFor_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Compound_stmtContext) Try_stmt() ITry_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITry_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITry_stmtContext)
}

func (s *Compound_stmtContext) With_stmt() IWith_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWith_stmtContext)
}

func (s *Compound_stmtContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Compound_stmtContext) Classdef() IClassdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *Compound_stmtContext) Decorated() IDecoratedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecoratedContext)
}

func (s *Compound_stmtContext) Async_stmt() IAsync_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsync_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsync_stmtContext)
}

func (s *Compound_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Compound_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterCompound_stmt(s)
	}
}

func (s *Compound_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitCompound_stmt(s)
	}
}




func (p *Python3Parser) Compound_stmt() (localctx ICompound_stmtContext) {
	localctx = NewCompound_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Python3ParserRULE_compound_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(613)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(604)
			p.If_stmt()
		}


	case Python3ParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(605)
			p.While_stmt()
		}


	case Python3ParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(606)
			p.For_stmt()
		}


	case Python3ParserTRY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(607)
			p.Try_stmt()
		}


	case Python3ParserWITH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(608)
			p.With_stmt()
		}


	case Python3ParserDEF:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(609)
			p.Funcdef()
		}


	case Python3ParserCLASS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(610)
			p.Classdef()
		}


	case Python3ParserAT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(611)
			p.Decorated()
		}


	case Python3ParserASYNC:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(612)
			p.Async_stmt()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IAsync_stmtContext is an interface to support dynamic dispatch.
type IAsync_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsync_stmtContext differentiates from other interfaces.
	IsAsync_stmtContext()
}

type Async_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsync_stmtContext() *Async_stmtContext {
	var p = new(Async_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_async_stmt
	return p
}

func (*Async_stmtContext) IsAsync_stmtContext() {}

func NewAsync_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Async_stmtContext {
	var p = new(Async_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_async_stmt

	return p
}

func (s *Async_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Async_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *Async_stmtContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Async_stmtContext) With_stmt() IWith_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWith_stmtContext)
}

func (s *Async_stmtContext) For_stmt() IFor_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Async_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Async_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Async_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAsync_stmt(s)
	}
}

func (s *Async_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAsync_stmt(s)
	}
}




func (p *Python3Parser) Async_stmt() (localctx IAsync_stmtContext) {
	localctx = NewAsync_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Python3ParserRULE_async_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.Match(Python3ParserASYNC)
	}
	p.SetState(619)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserDEF:
		{
			p.SetState(616)
			p.Funcdef()
		}


	case Python3ParserWITH:
		{
			p.SetState(617)
			p.With_stmt()
		}


	case Python3ParserFOR:
		{
			p.SetState(618)
			p.For_stmt()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_if_stmt
	return p
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *If_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *If_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *If_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *If_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *If_stmtContext) AllELIF() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserELIF)
}

func (s *If_stmtContext) ELIF(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserELIF, i)
}

func (s *If_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}




func (p *Python3Parser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Python3ParserRULE_if_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.Match(Python3ParserIF)
	}
	{
		p.SetState(622)
		p.Test()
	}
	{
		p.SetState(623)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(624)
		p.Suite()
	}
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserELIF {
		{
			p.SetState(625)
			p.Match(Python3ParserELIF)
		}
		{
			p.SetState(626)
			p.Test()
		}
		{
			p.SetState(627)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(628)
			p.Suite()
		}


		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserELSE {
		{
			p.SetState(635)
			p.Match(Python3ParserELSE)
		}
		{
			p.SetState(636)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(637)
			p.Suite()
		}

	}



	return localctx
}


// IWhile_stmtContext is an interface to support dynamic dispatch.
type IWhile_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhile_stmtContext differentiates from other interfaces.
	IsWhile_stmtContext()
}

type While_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_stmtContext() *While_stmtContext {
	var p = new(While_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_while_stmt
	return p
}

func (*While_stmtContext) IsWhile_stmtContext() {}

func NewWhile_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_stmtContext {
	var p = new(While_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_while_stmt

	return p
}

func (s *While_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *While_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Python3ParserWHILE, 0)
}

func (s *While_stmtContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *While_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *While_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *While_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *While_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *While_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}




func (p *Python3Parser) While_stmt() (localctx IWhile_stmtContext) {
	localctx = NewWhile_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Python3ParserRULE_while_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(Python3ParserWHILE)
	}
	{
		p.SetState(641)
		p.Test()
	}
	{
		p.SetState(642)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(643)
		p.Suite()
	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserELSE {
		{
			p.SetState(644)
			p.Match(Python3ParserELSE)
		}
		{
			p.SetState(645)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(646)
			p.Suite()
		}

	}



	return localctx
}


// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_for_stmt
	return p
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserFOR, 0)
}

func (s *For_stmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *For_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *For_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *For_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *For_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *For_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *For_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *For_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFor_stmt(s)
	}
}




func (p *Python3Parser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Python3ParserRULE_for_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(649)
		p.Match(Python3ParserFOR)
	}
	{
		p.SetState(650)
		p.Exprlist()
	}
	{
		p.SetState(651)
		p.Match(Python3ParserIN)
	}
	{
		p.SetState(652)
		p.Testlist()
	}
	{
		p.SetState(653)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(654)
		p.Suite()
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserELSE {
		{
			p.SetState(655)
			p.Match(Python3ParserELSE)
		}
		{
			p.SetState(656)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(657)
			p.Suite()
		}

	}



	return localctx
}


// ITry_stmtContext is an interface to support dynamic dispatch.
type ITry_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_stmtContext differentiates from other interfaces.
	IsTry_stmtContext()
}

type Try_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_stmtContext() *Try_stmtContext {
	var p = new(Try_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_try_stmt
	return p
}

func (*Try_stmtContext) IsTry_stmtContext() {}

func NewTry_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_stmtContext {
	var p = new(Try_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_try_stmt

	return p
}

func (s *Try_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_stmtContext) TRY() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRY, 0)
}

func (s *Try_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *Try_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *Try_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *Try_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Try_stmtContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(Python3ParserFINALLY, 0)
}

func (s *Try_stmtContext) AllExcept_clause() []IExcept_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExcept_clauseContext)(nil)).Elem())
	var tst = make([]IExcept_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExcept_clauseContext)
		}
	}

	return tst
}

func (s *Try_stmtContext) Except_clause(i int) IExcept_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExcept_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExcept_clauseContext)
}

func (s *Try_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *Try_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Try_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTry_stmt(s)
	}
}

func (s *Try_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTry_stmt(s)
	}
}




func (p *Python3Parser) Try_stmt() (localctx ITry_stmtContext) {
	localctx = NewTry_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Python3ParserRULE_try_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(Python3ParserTRY)
	}
	{
		p.SetState(661)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(662)
		p.Suite()
	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserEXCEPT:
		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == Python3ParserEXCEPT {
			{
				p.SetState(663)
				p.Except_clause()
			}
			{
				p.SetState(664)
				p.Match(Python3ParserCOLON)
			}
			{
				p.SetState(665)
				p.Suite()
			}


			p.SetState(669)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(674)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserELSE {
			{
				p.SetState(671)
				p.Match(Python3ParserELSE)
			}
			{
				p.SetState(672)
				p.Match(Python3ParserCOLON)
			}
			{
				p.SetState(673)
				p.Suite()
			}

		}
		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserFINALLY {
			{
				p.SetState(676)
				p.Match(Python3ParserFINALLY)
			}
			{
				p.SetState(677)
				p.Match(Python3ParserCOLON)
			}
			{
				p.SetState(678)
				p.Suite()
			}

		}


	case Python3ParserFINALLY:
		{
			p.SetState(681)
			p.Match(Python3ParserFINALLY)
		}
		{
			p.SetState(682)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(683)
			p.Suite()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}




	return localctx
}


// IWith_stmtContext is an interface to support dynamic dispatch.
type IWith_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWith_stmtContext differentiates from other interfaces.
	IsWith_stmtContext()
}

type With_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_stmtContext() *With_stmtContext {
	var p = new(With_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_with_stmt
	return p
}

func (*With_stmtContext) IsWith_stmtContext() {}

func NewWith_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_stmtContext {
	var p = new(With_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_with_stmt

	return p
}

func (s *With_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *With_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(Python3ParserWITH, 0)
}

func (s *With_stmtContext) AllWith_item() []IWith_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWith_itemContext)(nil)).Elem())
	var tst = make([]IWith_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWith_itemContext)
		}
	}

	return tst
}

func (s *With_stmtContext) With_item(i int) IWith_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWith_itemContext)
}

func (s *With_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *With_stmtContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *With_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *With_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *With_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterWith_stmt(s)
	}
}

func (s *With_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitWith_stmt(s)
	}
}




func (p *Python3Parser) With_stmt() (localctx IWith_stmtContext) {
	localctx = NewWith_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Python3ParserRULE_with_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(Python3ParserWITH)
	}
	{
		p.SetState(687)
		p.With_item()
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserCOMMA {
		{
			p.SetState(688)
			p.Match(Python3ParserCOMMA)
		}
		{
			p.SetState(689)
			p.With_item()
		}


		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(695)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(696)
		p.Suite()
	}



	return localctx
}


// IWith_itemContext is an interface to support dynamic dispatch.
type IWith_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWith_itemContext differentiates from other interfaces.
	IsWith_itemContext()
}

type With_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_itemContext() *With_itemContext {
	var p = new(With_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_with_item
	return p
}

func (*With_itemContext) IsWith_itemContext() {}

func NewWith_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_itemContext {
	var p = new(With_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_with_item

	return p
}

func (s *With_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *With_itemContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *With_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *With_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *With_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterWith_item(s)
	}
}

func (s *With_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitWith_item(s)
	}
}




func (p *Python3Parser) With_item() (localctx IWith_itemContext) {
	localctx = NewWith_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Python3ParserRULE_with_item)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Test()
	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserAS {
		{
			p.SetState(699)
			p.Match(Python3ParserAS)
		}
		{
			p.SetState(700)
			p.Expr()
		}

	}



	return localctx
}


// IExcept_clauseContext is an interface to support dynamic dispatch.
type IExcept_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExcept_clauseContext differentiates from other interfaces.
	IsExcept_clauseContext()
}

type Except_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_clauseContext() *Except_clauseContext {
	var p = new(Except_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_except_clause
	return p
}

func (*Except_clauseContext) IsExcept_clauseContext() {}

func NewExcept_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_clauseContext {
	var p = new(Except_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_except_clause

	return p
}

func (s *Except_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_clauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(Python3ParserEXCEPT, 0)
}

func (s *Except_clauseContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Except_clauseContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Except_clauseContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *Except_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Except_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExcept_clause(s)
	}
}

func (s *Except_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExcept_clause(s)
	}
}




func (p *Python3Parser) Except_clause() (localctx IExcept_clauseContext) {
	localctx = NewExcept_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Python3ParserRULE_except_clause)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.Match(Python3ParserEXCEPT)
	}
	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
		{
			p.SetState(704)
			p.Test()
		}
		p.SetState(707)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserAS {
			{
				p.SetState(705)
				p.Match(Python3ParserAS)
			}
			{
				p.SetState(706)
				p.Match(Python3ParserNAME)
			}

		}

	}



	return localctx
}


// ISuiteContext is an interface to support dynamic dispatch.
type ISuiteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuiteContext differentiates from other interfaces.
	IsSuiteContext()
}

type SuiteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuiteContext() *SuiteContext {
	var p = new(SuiteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_suite
	return p
}

func (*SuiteContext) IsSuiteContext() {}

func NewSuiteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuiteContext {
	var p = new(SuiteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_suite

	return p
}

func (s *SuiteContext) GetParser() antlr.Parser { return s.parser }

func (s *SuiteContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *SuiteContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *SuiteContext) INDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserINDENT, 0)
}

func (s *SuiteContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEDENT, 0)
}

func (s *SuiteContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *SuiteContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *SuiteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuiteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SuiteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSuite(s)
	}
}

func (s *SuiteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSuite(s)
	}
}




func (p *Python3Parser) Suite() (localctx ISuiteContext) {
	localctx = NewSuiteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Python3ParserRULE_suite)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(721)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(711)
			p.Simple_stmt()
		}


	case Python3ParserNEWLINE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(712)
			p.Match(Python3ParserNEWLINE)
		}
		{
			p.SetState(713)
			p.Match(Python3ParserINDENT)
		}
		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserDEF) | (1 << Python3ParserRETURN) | (1 << Python3ParserRAISE) | (1 << Python3ParserFROM) | (1 << Python3ParserIMPORT) | (1 << Python3ParserGLOBAL) | (1 << Python3ParserNONLOCAL) | (1 << Python3ParserASSERT) | (1 << Python3ParserIF) | (1 << Python3ParserWHILE) | (1 << Python3ParserFOR) | (1 << Python3ParserTRY) | (1 << Python3ParserWITH) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserCLASS - 32)) | (1 << (Python3ParserYIELD - 32)) | (1 << (Python3ParserDEL - 32)) | (1 << (Python3ParserPASS - 32)) | (1 << (Python3ParserCONTINUE - 32)) | (1 << (Python3ParserBREAK - 32)) | (1 << (Python3ParserASYNC - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserSTAR - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)) | (1 << (Python3ParserAT - 68)))) != 0) {
			{
				p.SetState(714)
				p.Stmt()
			}


			p.SetState(717)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(719)
			p.Match(Python3ParserDEDENT)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ITestContext is an interface to support dynamic dispatch.
type ITestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestContext differentiates from other interfaces.
	IsTestContext()
}

type TestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestContext() *TestContext {
	var p = new(TestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_test
	return p
}

func (*TestContext) IsTestContext() {}

func NewTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestContext {
	var p = new(TestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_test

	return p
}

func (s *TestContext) GetParser() antlr.Parser { return s.parser }

func (s *TestContext) AllOr_test() []IOr_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOr_testContext)(nil)).Elem())
	var tst = make([]IOr_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOr_testContext)
		}
	}

	return tst
}

func (s *TestContext) Or_test(i int) IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *TestContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *TestContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *TestContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestContext) Lambdef() ILambdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdefContext)
}

func (s *TestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTest(s)
	}
}

func (s *TestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTest(s)
	}
}




func (p *Python3Parser) Test() (localctx ITestContext) {
	localctx = NewTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Python3ParserRULE_test)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(732)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(723)
			p.Or_test()
		}
		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserIF {
			{
				p.SetState(724)
				p.Match(Python3ParserIF)
			}
			{
				p.SetState(725)
				p.Or_test()
			}
			{
				p.SetState(726)
				p.Match(Python3ParserELSE)
			}
			{
				p.SetState(727)
				p.Test()
			}

		}


	case Python3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(731)
			p.Lambdef()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ITest_nocondContext is an interface to support dynamic dispatch.
type ITest_nocondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTest_nocondContext differentiates from other interfaces.
	IsTest_nocondContext()
}

type Test_nocondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTest_nocondContext() *Test_nocondContext {
	var p = new(Test_nocondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_test_nocond
	return p
}

func (*Test_nocondContext) IsTest_nocondContext() {}

func NewTest_nocondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Test_nocondContext {
	var p = new(Test_nocondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_test_nocond

	return p
}

func (s *Test_nocondContext) GetParser() antlr.Parser { return s.parser }

func (s *Test_nocondContext) Or_test() IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Test_nocondContext) Lambdef_nocond() ILambdef_nocondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdef_nocondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdef_nocondContext)
}

func (s *Test_nocondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Test_nocondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Test_nocondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTest_nocond(s)
	}
}

func (s *Test_nocondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTest_nocond(s)
	}
}




func (p *Python3Parser) Test_nocond() (localctx ITest_nocondContext) {
	localctx = NewTest_nocondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Python3ParserRULE_test_nocond)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(736)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(734)
			p.Or_test()
		}


	case Python3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(735)
			p.Lambdef_nocond()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ILambdefContext is an interface to support dynamic dispatch.
type ILambdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdefContext differentiates from other interfaces.
	IsLambdefContext()
}

type LambdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdefContext() *LambdefContext {
	var p = new(LambdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef
	return p
}

func (*LambdefContext) IsLambdefContext() {}

func NewLambdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdefContext {
	var p = new(LambdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_lambdef

	return p
}

func (s *LambdefContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdefContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(Python3ParserLAMBDA, 0)
}

func (s *LambdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *LambdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *LambdefContext) Varargslist() IVarargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *LambdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LambdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterLambdef(s)
	}
}

func (s *LambdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitLambdef(s)
	}
}




func (p *Python3Parser) Lambdef() (localctx ILambdefContext) {
	localctx = NewLambdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Python3ParserRULE_lambdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Match(Python3ParserLAMBDA)
	}
	p.SetState(740)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 42)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 42))) & ((1 << (Python3ParserNAME - 42)) | (1 << (Python3ParserSTAR - 42)) | (1 << (Python3ParserPOWER - 42)))) != 0) {
		{
			p.SetState(739)
			p.Varargslist()
		}

	}
	{
		p.SetState(742)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(743)
		p.Test()
	}



	return localctx
}


// ILambdef_nocondContext is an interface to support dynamic dispatch.
type ILambdef_nocondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdef_nocondContext differentiates from other interfaces.
	IsLambdef_nocondContext()
}

type Lambdef_nocondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdef_nocondContext() *Lambdef_nocondContext {
	var p = new(Lambdef_nocondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef_nocond
	return p
}

func (*Lambdef_nocondContext) IsLambdef_nocondContext() {}

func NewLambdef_nocondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambdef_nocondContext {
	var p = new(Lambdef_nocondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_lambdef_nocond

	return p
}

func (s *Lambdef_nocondContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambdef_nocondContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(Python3ParserLAMBDA, 0)
}

func (s *Lambdef_nocondContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Lambdef_nocondContext) Test_nocond() ITest_nocondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITest_nocondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITest_nocondContext)
}

func (s *Lambdef_nocondContext) Varargslist() IVarargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *Lambdef_nocondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambdef_nocondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Lambdef_nocondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterLambdef_nocond(s)
	}
}

func (s *Lambdef_nocondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitLambdef_nocond(s)
	}
}




func (p *Python3Parser) Lambdef_nocond() (localctx ILambdef_nocondContext) {
	localctx = NewLambdef_nocondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Python3ParserRULE_lambdef_nocond)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Match(Python3ParserLAMBDA)
	}
	p.SetState(747)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 42)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 42))) & ((1 << (Python3ParserNAME - 42)) | (1 << (Python3ParserSTAR - 42)) | (1 << (Python3ParserPOWER - 42)))) != 0) {
		{
			p.SetState(746)
			p.Varargslist()
		}

	}
	{
		p.SetState(749)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(750)
		p.Test_nocond()
	}



	return localctx
}


// IOr_testContext is an interface to support dynamic dispatch.
type IOr_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOr_testContext differentiates from other interfaces.
	IsOr_testContext()
}

type Or_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_testContext() *Or_testContext {
	var p = new(Or_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_or_test
	return p
}

func (*Or_testContext) IsOr_testContext() {}

func NewOr_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_testContext {
	var p = new(Or_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_or_test

	return p
}

func (s *Or_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_testContext) AllAnd_test() []IAnd_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_testContext)(nil)).Elem())
	var tst = make([]IAnd_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_testContext)
		}
	}

	return tst
}

func (s *Or_testContext) And_test(i int) IAnd_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_testContext)
}

func (s *Or_testContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserOR)
}

func (s *Or_testContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserOR, i)
}

func (s *Or_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Or_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterOr_test(s)
	}
}

func (s *Or_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitOr_test(s)
	}
}




func (p *Python3Parser) Or_test() (localctx IOr_testContext) {
	localctx = NewOr_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Python3ParserRULE_or_test)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(752)
		p.And_test()
	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserOR {
		{
			p.SetState(753)
			p.Match(Python3ParserOR)
		}
		{
			p.SetState(754)
			p.And_test()
		}


		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAnd_testContext is an interface to support dynamic dispatch.
type IAnd_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_testContext differentiates from other interfaces.
	IsAnd_testContext()
}

type And_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_testContext() *And_testContext {
	var p = new(And_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_and_test
	return p
}

func (*And_testContext) IsAnd_testContext() {}

func NewAnd_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_testContext {
	var p = new(And_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_and_test

	return p
}

func (s *And_testContext) GetParser() antlr.Parser { return s.parser }

func (s *And_testContext) AllNot_test() []INot_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INot_testContext)(nil)).Elem())
	var tst = make([]INot_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INot_testContext)
		}
	}

	return tst
}

func (s *And_testContext) Not_test(i int) INot_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *And_testContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserAND)
}

func (s *And_testContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserAND, i)
}

func (s *And_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *And_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAnd_test(s)
	}
}

func (s *And_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAnd_test(s)
	}
}




func (p *Python3Parser) And_test() (localctx IAnd_testContext) {
	localctx = NewAnd_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Python3ParserRULE_and_test)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(760)
		p.Not_test()
	}
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserAND {
		{
			p.SetState(761)
			p.Match(Python3ParserAND)
		}
		{
			p.SetState(762)
			p.Not_test()
		}


		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// INot_testContext is an interface to support dynamic dispatch.
type INot_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNot_testContext differentiates from other interfaces.
	IsNot_testContext()
}

type Not_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot_testContext() *Not_testContext {
	var p = new(Not_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_not_test
	return p
}

func (*Not_testContext) IsNot_testContext() {}

func NewNot_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not_testContext {
	var p = new(Not_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_not_test

	return p
}

func (s *Not_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Not_testContext) NOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT, 0)
}

func (s *Not_testContext) Not_test() INot_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *Not_testContext) Comparison() IComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *Not_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Not_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterNot_test(s)
	}
}

func (s *Not_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitNot_test(s)
	}
}




func (p *Python3Parser) Not_test() (localctx INot_testContext) {
	localctx = NewNot_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Python3ParserRULE_not_test)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(771)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(768)
			p.Match(Python3ParserNOT)
		}
		{
			p.SetState(769)
			p.Not_test()
		}


	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(770)
			p.Comparison()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_comparison
	return p
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ComparisonContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ComparisonContext) AllComp_op() []IComp_opContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComp_opContext)(nil)).Elem())
	var tst = make([]IComp_opContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComp_opContext)
		}
	}

	return tst
}

func (s *ComparisonContext) Comp_op(i int) IComp_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_opContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComp_opContext)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComparison(s)
	}
}




func (p *Python3Parser) Comparison() (localctx IComparisonContext) {
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Python3ParserRULE_comparison)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.Expr()
	}
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserIN) | (1 << Python3ParserNOT) | (1 << Python3ParserIS))) != 0) || ((((_la - 76)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 76))) & ((1 << (Python3ParserLESS_THAN - 76)) | (1 << (Python3ParserGREATER_THAN - 76)) | (1 << (Python3ParserEQUALS - 76)) | (1 << (Python3ParserGT_EQ - 76)) | (1 << (Python3ParserLT_EQ - 76)) | (1 << (Python3ParserNOT_EQ_1 - 76)) | (1 << (Python3ParserNOT_EQ_2 - 76)))) != 0) {
		{
			p.SetState(774)
			p.Comp_op()
		}
		{
			p.SetState(775)
			p.Expr()
		}


		p.SetState(781)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IComp_opContext is an interface to support dynamic dispatch.
type IComp_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_opContext differentiates from other interfaces.
	IsComp_opContext()
}

type Comp_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_opContext() *Comp_opContext {
	var p = new(Comp_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_op
	return p
}

func (*Comp_opContext) IsComp_opContext() {}

func NewComp_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_opContext {
	var p = new(Comp_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_op

	return p
}

func (s *Comp_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_opContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(Python3ParserLESS_THAN, 0)
}

func (s *Comp_opContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(Python3ParserGREATER_THAN, 0)
}

func (s *Comp_opContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(Python3ParserEQUALS, 0)
}

func (s *Comp_opContext) GT_EQ() antlr.TerminalNode {
	return s.GetToken(Python3ParserGT_EQ, 0)
}

func (s *Comp_opContext) LT_EQ() antlr.TerminalNode {
	return s.GetToken(Python3ParserLT_EQ, 0)
}

func (s *Comp_opContext) NOT_EQ_1() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_EQ_1, 0)
}

func (s *Comp_opContext) NOT_EQ_2() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_EQ_2, 0)
}

func (s *Comp_opContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *Comp_opContext) NOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT, 0)
}

func (s *Comp_opContext) IS() antlr.TerminalNode {
	return s.GetToken(Python3ParserIS, 0)
}

func (s *Comp_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComp_op(s)
	}
}

func (s *Comp_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComp_op(s)
	}
}




func (p *Python3Parser) Comp_op() (localctx IComp_opContext) {
	localctx = NewComp_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Python3ParserRULE_comp_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(782)
			p.Match(Python3ParserLESS_THAN)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(783)
			p.Match(Python3ParserGREATER_THAN)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(784)
			p.Match(Python3ParserEQUALS)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(785)
			p.Match(Python3ParserGT_EQ)
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(786)
			p.Match(Python3ParserLT_EQ)
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(787)
			p.Match(Python3ParserNOT_EQ_1)
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(788)
			p.Match(Python3ParserNOT_EQ_2)
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(789)
			p.Match(Python3ParserIN)
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(790)
			p.Match(Python3ParserNOT)
		}
		{
			p.SetState(791)
			p.Match(Python3ParserIN)
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(792)
			p.Match(Python3ParserIS)
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(793)
			p.Match(Python3ParserIS)
		}
		{
			p.SetState(794)
			p.Match(Python3ParserNOT)
		}

	}


	return localctx
}


// IStar_exprContext is an interface to support dynamic dispatch.
type IStar_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStar_exprContext differentiates from other interfaces.
	IsStar_exprContext()
}

type Star_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStar_exprContext() *Star_exprContext {
	var p = new(Star_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_star_expr
	return p
}

func (*Star_exprContext) IsStar_exprContext() {}

func NewStar_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Star_exprContext {
	var p = new(Star_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_star_expr

	return p
}

func (s *Star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Star_exprContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Star_exprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterStar_expr(s)
	}
}

func (s *Star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitStar_expr(s)
	}
}




func (p *Python3Parser) Star_expr() (localctx IStar_exprContext) {
	localctx = NewStar_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Python3ParserRULE_star_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(797)
		p.Match(Python3ParserSTAR)
	}
	{
		p.SetState(798)
		p.Expr()
	}



	return localctx
}


// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllXor_expr() []IXor_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXor_exprContext)(nil)).Elem())
	var tst = make([]IXor_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXor_exprContext)
		}
	}

	return tst
}

func (s *ExprContext) Xor_expr(i int) IXor_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXor_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXor_exprContext)
}

func (s *ExprContext) AllOR_OP() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserOR_OP)
}

func (s *ExprContext) OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserOR_OP, i)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExpr(s)
	}
}




func (p *Python3Parser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Python3ParserRULE_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		p.Xor_expr()
	}
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserOR_OP {
		{
			p.SetState(801)
			p.Match(Python3ParserOR_OP)
		}
		{
			p.SetState(802)
			p.Xor_expr()
		}


		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IXor_exprContext is an interface to support dynamic dispatch.
type IXor_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXor_exprContext differentiates from other interfaces.
	IsXor_exprContext()
}

type Xor_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_exprContext() *Xor_exprContext {
	var p = new(Xor_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_xor_expr
	return p
}

func (*Xor_exprContext) IsXor_exprContext() {}

func NewXor_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_exprContext {
	var p = new(Xor_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_xor_expr

	return p
}

func (s *Xor_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_exprContext) AllAnd_expr() []IAnd_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem())
	var tst = make([]IAnd_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_exprContext)
		}
	}

	return tst
}

func (s *Xor_exprContext) And_expr(i int) IAnd_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_exprContext)
}

func (s *Xor_exprContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserXOR)
}

func (s *Xor_exprContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserXOR, i)
}

func (s *Xor_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Xor_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterXor_expr(s)
	}
}

func (s *Xor_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitXor_expr(s)
	}
}




func (p *Python3Parser) Xor_expr() (localctx IXor_exprContext) {
	localctx = NewXor_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Python3ParserRULE_xor_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.And_expr()
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserXOR {
		{
			p.SetState(809)
			p.Match(Python3ParserXOR)
		}
		{
			p.SetState(810)
			p.And_expr()
		}


		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAnd_exprContext is an interface to support dynamic dispatch.
type IAnd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_exprContext differentiates from other interfaces.
	IsAnd_exprContext()
}

type And_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_exprContext() *And_exprContext {
	var p = new(And_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_and_expr
	return p
}

func (*And_exprContext) IsAnd_exprContext() {}

func NewAnd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_exprContext {
	var p = new(And_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_and_expr

	return p
}

func (s *And_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *And_exprContext) AllShift_expr() []IShift_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShift_exprContext)(nil)).Elem())
	var tst = make([]IShift_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShift_exprContext)
		}
	}

	return tst
}

func (s *And_exprContext) Shift_expr(i int) IShift_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShift_exprContext)
}

func (s *And_exprContext) AllAND_OP() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserAND_OP)
}

func (s *And_exprContext) AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserAND_OP, i)
}

func (s *And_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *And_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAnd_expr(s)
	}
}

func (s *And_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAnd_expr(s)
	}
}




func (p *Python3Parser) And_expr() (localctx IAnd_exprContext) {
	localctx = NewAnd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Python3ParserRULE_and_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Shift_expr()
	}
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserAND_OP {
		{
			p.SetState(817)
			p.Match(Python3ParserAND_OP)
		}
		{
			p.SetState(818)
			p.Shift_expr()
		}


		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IShift_exprContext is an interface to support dynamic dispatch.
type IShift_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_exprContext differentiates from other interfaces.
	IsShift_exprContext()
}

type Shift_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_exprContext() *Shift_exprContext {
	var p = new(Shift_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_shift_expr
	return p
}

func (*Shift_exprContext) IsShift_exprContext() {}

func NewShift_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_exprContext {
	var p = new(Shift_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_shift_expr

	return p
}

func (s *Shift_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_exprContext) AllArith_expr() []IArith_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArith_exprContext)(nil)).Elem())
	var tst = make([]IArith_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArith_exprContext)
		}
	}

	return tst
}

func (s *Shift_exprContext) Arith_expr(i int) IArith_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArith_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArith_exprContext)
}

func (s *Shift_exprContext) AllLEFT_SHIFT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserLEFT_SHIFT)
}

func (s *Shift_exprContext) LEFT_SHIFT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserLEFT_SHIFT, i)
}

func (s *Shift_exprContext) AllRIGHT_SHIFT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserRIGHT_SHIFT)
}

func (s *Shift_exprContext) RIGHT_SHIFT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserRIGHT_SHIFT, i)
}

func (s *Shift_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Shift_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterShift_expr(s)
	}
}

func (s *Shift_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitShift_expr(s)
	}
}




func (p *Python3Parser) Shift_expr() (localctx IShift_exprContext) {
	localctx = NewShift_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Python3ParserRULE_shift_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		p.Arith_expr()
	}
	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserLEFT_SHIFT || _la == Python3ParserRIGHT_SHIFT {
		{
			p.SetState(825)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Python3ParserLEFT_SHIFT || _la == Python3ParserRIGHT_SHIFT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(826)
			p.Arith_expr()
		}


		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IArith_exprContext is an interface to support dynamic dispatch.
type IArith_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArith_exprContext differentiates from other interfaces.
	IsArith_exprContext()
}

type Arith_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArith_exprContext() *Arith_exprContext {
	var p = new(Arith_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_arith_expr
	return p
}

func (*Arith_exprContext) IsArith_exprContext() {}

func NewArith_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arith_exprContext {
	var p = new(Arith_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_arith_expr

	return p
}

func (s *Arith_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Arith_exprContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Arith_exprContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Arith_exprContext) AllADD() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserADD)
}

func (s *Arith_exprContext) ADD(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserADD, i)
}

func (s *Arith_exprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserMINUS)
}

func (s *Arith_exprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, i)
}

func (s *Arith_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arith_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Arith_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterArith_expr(s)
	}
}

func (s *Arith_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitArith_expr(s)
	}
}




func (p *Python3Parser) Arith_expr() (localctx IArith_exprContext) {
	localctx = NewArith_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Python3ParserRULE_arith_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.Term()
	}
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python3ParserADD || _la == Python3ParserMINUS {
		{
			p.SetState(833)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Python3ParserADD || _la == Python3ParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(834)
			p.Term()
		}


		p.SetState(839)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) AllFactor() []IFactorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFactorContext)(nil)).Elem())
	var tst = make([]IFactorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFactorContext)
		}
	}

	return tst
}

func (s *TermContext) Factor(i int) IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *TermContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSTAR)
}

func (s *TermContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, i)
}

func (s *TermContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserAT)
}

func (s *TermContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserAT, i)
}

func (s *TermContext) AllDIV() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDIV)
}

func (s *TermContext) DIV(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDIV, i)
}

func (s *TermContext) AllMOD() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserMOD)
}

func (s *TermContext) MOD(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserMOD, i)
}

func (s *TermContext) AllIDIV() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserIDIV)
}

func (s *TermContext) IDIV(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserIDIV, i)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTerm(s)
	}
}




func (p *Python3Parser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Python3ParserRULE_term)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.Factor()
	}
	p.SetState(845)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ((((_la - 53)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 53))) & ((1 << (Python3ParserSTAR - 53)) | (1 << (Python3ParserDIV - 53)) | (1 << (Python3ParserMOD - 53)) | (1 << (Python3ParserIDIV - 53)) | (1 << (Python3ParserAT - 53)))) != 0) {
		{
			p.SetState(841)
			_la = p.GetTokenStream().LA(1)

			if !(((((_la - 53)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 53))) & ((1 << (Python3ParserSTAR - 53)) | (1 << (Python3ParserDIV - 53)) | (1 << (Python3ParserMOD - 53)) | (1 << (Python3ParserIDIV - 53)) | (1 << (Python3ParserAT - 53)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(842)
			p.Factor()
		}


		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_factor
	return p
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) Factor() IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) ADD() antlr.TerminalNode {
	return s.GetToken(Python3ParserADD, 0)
}

func (s *FactorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, 0)
}

func (s *FactorContext) NOT_OP() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_OP, 0)
}

func (s *FactorContext) Power() IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFactor(s)
	}
}




func (p *Python3Parser) Factor() (localctx IFactorContext) {
	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Python3ParserRULE_factor)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(851)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(848)
			_la = p.GetTokenStream().LA(1)

			if !(((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(849)
			p.Factor()
		}


	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(850)
			p.Power()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom_expr() IAtom_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_exprContext)
}

func (s *PowerContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *PowerContext) Factor() IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitPower(s)
	}
}




func (p *Python3Parser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Python3ParserRULE_power)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Atom_expr()
	}
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserPOWER {
		{
			p.SetState(854)
			p.Match(Python3ParserPOWER)
		}
		{
			p.SetState(855)
			p.Factor()
		}

	}



	return localctx
}


// IAtom_exprContext is an interface to support dynamic dispatch.
type IAtom_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_exprContext differentiates from other interfaces.
	IsAtom_exprContext()
}

type Atom_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_exprContext() *Atom_exprContext {
	var p = new(Atom_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_atom_expr
	return p
}

func (*Atom_exprContext) IsAtom_exprContext() {}

func NewAtom_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_exprContext {
	var p = new(Atom_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_atom_expr

	return p
}

func (s *Atom_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_exprContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Atom_exprContext) AWAIT() antlr.TerminalNode {
	return s.GetToken(Python3ParserAWAIT, 0)
}

func (s *Atom_exprContext) AllTrailer() []ITrailerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITrailerContext)(nil)).Elem())
	var tst = make([]ITrailerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITrailerContext)
		}
	}

	return tst
}

func (s *Atom_exprContext) Trailer(i int) ITrailerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITrailerContext)
}

func (s *Atom_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Atom_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAtom_expr(s)
	}
}

func (s *Atom_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAtom_expr(s)
	}
}




func (p *Python3Parser) Atom_expr() (localctx IAtom_exprContext) {
	localctx = NewAtom_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Python3ParserRULE_atom_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserAWAIT {
		{
			p.SetState(858)
			p.Match(Python3ParserAWAIT)
		}

	}
	{
		p.SetState(861)
		p.Atom()
	}
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ((((_la - 51)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 51))) & ((1 << (Python3ParserDOT - 51)) | (1 << (Python3ParserOPEN_PAREN - 51)) | (1 << (Python3ParserOPEN_BRACK - 51)))) != 0) {
		{
			p.SetState(862)
			p.Trailer()
		}


		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *AtomContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *AtomContext) OPEN_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACK, 0)
}

func (s *AtomContext) CLOSE_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACK, 0)
}

func (s *AtomContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACE, 0)
}

func (s *AtomContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACE, 0)
}

func (s *AtomContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *AtomContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Python3ParserNUMBER, 0)
}

func (s *AtomContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(Python3ParserELLIPSIS, 0)
}

func (s *AtomContext) NONE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONE, 0)
}

func (s *AtomContext) TRUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRUE, 0)
}

func (s *AtomContext) FALSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserFALSE, 0)
}

func (s *AtomContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *AtomContext) Testlist_comp() ITestlist_compContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_compContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlist_compContext)
}

func (s *AtomContext) Dictorsetmaker() IDictorsetmakerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictorsetmakerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictorsetmakerContext)
}

func (s *AtomContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSTRING)
}

func (s *AtomContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSTRING, i)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAtom(s)
	}
}




func (p *Python3Parser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Python3ParserRULE_atom)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(895)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_PAREN:
		{
			p.SetState(868)
			p.Match(Python3ParserOPEN_PAREN)
		}
		p.SetState(871)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserYIELD:
			{
				p.SetState(869)
				p.Yield_expr()
			}


		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(870)
				p.Testlist_comp()
			}


		case Python3ParserCLOSE_PAREN:



		default:
		}
		{
			p.SetState(873)
			p.Match(Python3ParserCLOSE_PAREN)
		}


	case Python3ParserOPEN_BRACK:
		{
			p.SetState(874)
			p.Match(Python3ParserOPEN_BRACK)
		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserSTAR - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
			{
				p.SetState(875)
				p.Testlist_comp()
			}

		}
		{
			p.SetState(878)
			p.Match(Python3ParserCLOSE_BRACK)
		}


	case Python3ParserOPEN_BRACE:
		{
			p.SetState(879)
			p.Match(Python3ParserOPEN_BRACE)
		}
		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserSTAR - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserPOWER - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
			{
				p.SetState(880)
				p.Dictorsetmaker()
			}

		}
		{
			p.SetState(883)
			p.Match(Python3ParserCLOSE_BRACE)
		}


	case Python3ParserNAME:
		{
			p.SetState(884)
			p.Match(Python3ParserNAME)
		}


	case Python3ParserNUMBER:
		{
			p.SetState(885)
			p.Match(Python3ParserNUMBER)
		}


	case Python3ParserSTRING:
		p.SetState(887)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == Python3ParserSTRING {
			{
				p.SetState(886)
				p.Match(Python3ParserSTRING)
			}


			p.SetState(889)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}


	case Python3ParserELLIPSIS:
		{
			p.SetState(891)
			p.Match(Python3ParserELLIPSIS)
		}


	case Python3ParserNONE:
		{
			p.SetState(892)
			p.Match(Python3ParserNONE)
		}


	case Python3ParserTRUE:
		{
			p.SetState(893)
			p.Match(Python3ParserTRUE)
		}


	case Python3ParserFALSE:
		{
			p.SetState(894)
			p.Match(Python3ParserFALSE)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// ITestlist_compContext is an interface to support dynamic dispatch.
type ITestlist_compContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist_compContext differentiates from other interfaces.
	IsTestlist_compContext()
}

type Testlist_compContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_compContext() *Testlist_compContext {
	var p = new(Testlist_compContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_comp
	return p
}

func (*Testlist_compContext) IsTestlist_compContext() {}

func NewTestlist_compContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_compContext {
	var p = new(Testlist_compContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist_comp

	return p
}

func (s *Testlist_compContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_compContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Testlist_compContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_compContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *Testlist_compContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_compContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Testlist_compContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Testlist_compContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Testlist_compContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_compContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Testlist_compContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTestlist_comp(s)
	}
}

func (s *Testlist_compContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTestlist_comp(s)
	}
}




func (p *Python3Parser) Testlist_comp() (localctx ITestlist_compContext) {
	localctx = NewTestlist_compContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Python3ParserRULE_testlist_comp)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(899)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(897)
			p.Test()
		}


	case Python3ParserSTAR:
		{
			p.SetState(898)
			p.Star_expr()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFOR, Python3ParserASYNC:
		{
			p.SetState(901)
			p.Comp_for()
		}


	case Python3ParserCLOSE_PAREN, Python3ParserCOMMA, Python3ParserCLOSE_BRACK:
		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(902)
					p.Match(Python3ParserCOMMA)
				}
				p.SetState(905)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
					{
						p.SetState(903)
						p.Test()
					}


				case Python3ParserSTAR:
					{
						p.SetState(904)
						p.Star_expr()
					}



				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}


			}
			p.SetState(911)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())
		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserCOMMA {
			{
				p.SetState(912)
				p.Match(Python3ParserCOMMA)
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// ITrailerContext is an interface to support dynamic dispatch.
type ITrailerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrailerContext differentiates from other interfaces.
	IsTrailerContext()
}

type TrailerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailerContext() *TrailerContext {
	var p = new(TrailerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_trailer
	return p
}

func (*TrailerContext) IsTrailerContext() {}

func NewTrailerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailerContext {
	var p = new(TrailerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_trailer

	return p
}

func (s *TrailerContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailerContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *TrailerContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *TrailerContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *TrailerContext) OPEN_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACK, 0)
}

func (s *TrailerContext) Subscriptlist() ISubscriptlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriptlistContext)
}

func (s *TrailerContext) CLOSE_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACK, 0)
}

func (s *TrailerContext) DOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, 0)
}

func (s *TrailerContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *TrailerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TrailerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTrailer(s)
	}
}

func (s *TrailerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTrailer(s)
	}
}




func (p *Python3Parser) Trailer() (localctx ITrailerContext) {
	localctx = NewTrailerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Python3ParserRULE_trailer)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(928)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(917)
			p.Match(Python3ParserOPEN_PAREN)
		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserSTAR - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserPOWER - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
			{
				p.SetState(918)
				p.Arglist()
			}

		}
		{
			p.SetState(921)
			p.Match(Python3ParserCLOSE_PAREN)
		}


	case Python3ParserOPEN_BRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(922)
			p.Match(Python3ParserOPEN_BRACK)
		}
		{
			p.SetState(923)
			p.Subscriptlist()
		}
		{
			p.SetState(924)
			p.Match(Python3ParserCLOSE_BRACK)
		}


	case Python3ParserDOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(926)
			p.Match(Python3ParserDOT)
		}
		{
			p.SetState(927)
			p.Match(Python3ParserNAME)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ISubscriptlistContext is an interface to support dynamic dispatch.
type ISubscriptlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptlistContext differentiates from other interfaces.
	IsSubscriptlistContext()
}

type SubscriptlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptlistContext() *SubscriptlistContext {
	var p = new(SubscriptlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_subscriptlist
	return p
}

func (*SubscriptlistContext) IsSubscriptlistContext() {}

func NewSubscriptlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptlistContext {
	var p = new(SubscriptlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subscriptlist

	return p
}

func (s *SubscriptlistContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptlistContext) AllSubscript_() []ISubscript_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscript_Context)(nil)).Elem())
	var tst = make([]ISubscript_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscript_Context)
		}
	}

	return tst
}

func (s *SubscriptlistContext) Subscript_(i int) ISubscript_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscript_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscript_Context)
}

func (s *SubscriptlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *SubscriptlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *SubscriptlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubscriptlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSubscriptlist(s)
	}
}




func (p *Python3Parser) Subscriptlist() (localctx ISubscriptlistContext) {
	localctx = NewSubscriptlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Python3ParserRULE_subscriptlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.Subscript_()
	}
	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(931)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(932)
				p.Subscript_()
			}


		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserCOMMA {
		{
			p.SetState(938)
			p.Match(Python3ParserCOMMA)
		}

	}



	return localctx
}


// ISubscript_Context is an interface to support dynamic dispatch.
type ISubscript_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscript_Context differentiates from other interfaces.
	IsSubscript_Context()
}

type Subscript_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscript_Context() *Subscript_Context {
	var p = new(Subscript_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_subscript_
	return p
}

func (*Subscript_Context) IsSubscript_Context() {}

func NewSubscript_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subscript_Context {
	var p = new(Subscript_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subscript_

	return p
}

func (s *Subscript_Context) GetParser() antlr.Parser { return s.parser }

func (s *Subscript_Context) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Subscript_Context) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Subscript_Context) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Subscript_Context) Sliceop() ISliceopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISliceopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISliceopContext)
}

func (s *Subscript_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subscript_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Subscript_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSubscript_(s)
	}
}

func (s *Subscript_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSubscript_(s)
	}
}




func (p *Python3Parser) Subscript_() (localctx ISubscript_Context) {
	localctx = NewSubscript_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Python3ParserRULE_subscript_)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(941)
			p.Test()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(943)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
			{
				p.SetState(942)
				p.Test()
			}

		}
		{
			p.SetState(945)
			p.Match(Python3ParserCOLON)
		}
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
			{
				p.SetState(946)
				p.Test()
			}

		}
		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserCOLON {
			{
				p.SetState(949)
				p.Sliceop()
			}

		}

	}


	return localctx
}


// ISliceopContext is an interface to support dynamic dispatch.
type ISliceopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSliceopContext differentiates from other interfaces.
	IsSliceopContext()
}

type SliceopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceopContext() *SliceopContext {
	var p = new(SliceopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_sliceop
	return p
}

func (*SliceopContext) IsSliceopContext() {}

func NewSliceopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceopContext {
	var p = new(SliceopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_sliceop

	return p
}

func (s *SliceopContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceopContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *SliceopContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SliceopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SliceopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSliceop(s)
	}
}

func (s *SliceopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSliceop(s)
	}
}




func (p *Python3Parser) Sliceop() (localctx ISliceopContext) {
	localctx = NewSliceopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Python3ParserRULE_sliceop)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)
		p.Match(Python3ParserCOLON)
	}
	p.SetState(956)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
		{
			p.SetState(955)
			p.Test()
		}

	}



	return localctx
}


// IExprlistContext is an interface to support dynamic dispatch.
type IExprlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprlistContext differentiates from other interfaces.
	IsExprlistContext()
}

type ExprlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprlistContext() *ExprlistContext {
	var p = new(ExprlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_exprlist
	return p
}

func (*ExprlistContext) IsExprlistContext() {}

func NewExprlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprlistContext {
	var p = new(ExprlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_exprlist

	return p
}

func (s *ExprlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprlistContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprlistContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprlistContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *ExprlistContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *ExprlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *ExprlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *ExprlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExprlist(s)
	}
}

func (s *ExprlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExprlist(s)
	}
}




func (p *Python3Parser) Exprlist() (localctx IExprlistContext) {
	localctx = NewExprlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Python3ParserRULE_exprlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(960)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(958)
			p.Expr()
		}


	case Python3ParserSTAR:
		{
			p.SetState(959)
			p.Star_expr()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(962)
				p.Match(Python3ParserCOMMA)
			}
			p.SetState(965)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
				{
					p.SetState(963)
					p.Expr()
				}


			case Python3ParserSTAR:
				{
					p.SetState(964)
					p.Star_expr()
				}



			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}


		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}
	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserCOMMA {
		{
			p.SetState(972)
			p.Match(Python3ParserCOMMA)
		}

	}



	return localctx
}


// ITestlistContext is an interface to support dynamic dispatch.
type ITestlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlistContext differentiates from other interfaces.
	IsTestlistContext()
}

type TestlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlistContext() *TestlistContext {
	var p = new(TestlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist
	return p
}

func (*TestlistContext) IsTestlistContext() {}

func NewTestlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestlistContext {
	var p = new(TestlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist

	return p
}

func (s *TestlistContext) GetParser() antlr.Parser { return s.parser }

func (s *TestlistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *TestlistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *TestlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *TestlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TestlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTestlist(s)
	}
}

func (s *TestlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTestlist(s)
	}
}




func (p *Python3Parser) Testlist() (localctx ITestlistContext) {
	localctx = NewTestlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Python3ParserRULE_testlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(975)
		p.Test()
	}
	p.SetState(980)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(976)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(977)
				p.Test()
			}


		}
		p.SetState(982)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserCOMMA {
		{
			p.SetState(983)
			p.Match(Python3ParserCOMMA)
		}

	}



	return localctx
}


// IDictorsetmakerContext is an interface to support dynamic dispatch.
type IDictorsetmakerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictorsetmakerContext differentiates from other interfaces.
	IsDictorsetmakerContext()
}

type DictorsetmakerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictorsetmakerContext() *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_dictorsetmaker
	return p
}

func (*DictorsetmakerContext) IsDictorsetmakerContext() {}

func NewDictorsetmakerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dictorsetmaker

	return p
}

func (s *DictorsetmakerContext) GetParser() antlr.Parser { return s.parser }

func (s *DictorsetmakerContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *DictorsetmakerContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *DictorsetmakerContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *DictorsetmakerContext) AllPOWER() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserPOWER)
}

func (s *DictorsetmakerContext) POWER(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, i)
}

func (s *DictorsetmakerContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DictorsetmakerContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *DictorsetmakerContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *DictorsetmakerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *DictorsetmakerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *DictorsetmakerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictorsetmakerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DictorsetmakerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDictorsetmaker(s)
	}
}




func (p *Python3Parser) Dictorsetmaker() (localctx IDictorsetmakerContext) {
	localctx = NewDictorsetmakerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Python3ParserRULE_dictorsetmaker)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) {
	case 1:
		p.SetState(992)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(986)
				p.Test()
			}
			{
				p.SetState(987)
				p.Match(Python3ParserCOLON)
			}
			{
				p.SetState(988)
				p.Test()
			}


		case Python3ParserPOWER:
			{
				p.SetState(990)
				p.Match(Python3ParserPOWER)
			}
			{
				p.SetState(991)
				p.Expr()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(1012)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserFOR, Python3ParserASYNC:
			{
				p.SetState(994)
				p.Comp_for()
			}


		case Python3ParserCOMMA, Python3ParserCLOSE_BRACE:
			p.SetState(1006)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(995)
						p.Match(Python3ParserCOMMA)
					}
					p.SetState(1002)
					p.GetErrorHandler().Sync(p)

					switch p.GetTokenStream().LA(1) {
					case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
						{
							p.SetState(996)
							p.Test()
						}
						{
							p.SetState(997)
							p.Match(Python3ParserCOLON)
						}
						{
							p.SetState(998)
							p.Test()
						}


					case Python3ParserPOWER:
						{
							p.SetState(1000)
							p.Match(Python3ParserPOWER)
						}
						{
							p.SetState(1001)
							p.Expr()
						}



					default:
						panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					}


				}
				p.SetState(1008)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext())
			}
			p.SetState(1010)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python3ParserCOMMA {
				{
					p.SetState(1009)
					p.Match(Python3ParserCOMMA)
				}

			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}



	case 2:
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(1014)
				p.Test()
			}


		case Python3ParserSTAR:
			{
				p.SetState(1015)
				p.Star_expr()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserFOR, Python3ParserASYNC:
			{
				p.SetState(1018)
				p.Comp_for()
			}


		case Python3ParserCOMMA, Python3ParserCLOSE_BRACE:
			p.SetState(1026)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1019)
						p.Match(Python3ParserCOMMA)
					}
					p.SetState(1022)
					p.GetErrorHandler().Sync(p)

					switch p.GetTokenStream().LA(1) {
					case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
						{
							p.SetState(1020)
							p.Test()
						}


					case Python3ParserSTAR:
						{
							p.SetState(1021)
							p.Star_expr()
						}



					default:
						panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					}


				}
				p.SetState(1028)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())
			}
			p.SetState(1030)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python3ParserCOMMA {
				{
					p.SetState(1029)
					p.Match(Python3ParserCOMMA)
				}

			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}


	}



	return localctx
}


// IClassdefContext is an interface to support dynamic dispatch.
type IClassdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassdefContext differentiates from other interfaces.
	IsClassdefContext()
}

type ClassdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassdefContext() *ClassdefContext {
	var p = new(ClassdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_classdef
	return p
}

func (*ClassdefContext) IsClassdefContext() {}

func NewClassdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassdefContext {
	var p = new(ClassdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_classdef

	return p
}

func (s *ClassdefContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassdefContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLASS, 0)
}

func (s *ClassdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *ClassdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *ClassdefContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *ClassdefContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *ClassdefContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *ClassdefContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *ClassdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ClassdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterClassdef(s)
	}
}

func (s *ClassdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitClassdef(s)
	}
}




func (p *Python3Parser) Classdef() (localctx IClassdefContext) {
	localctx = NewClassdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Python3ParserRULE_classdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1036)
		p.Match(Python3ParserCLASS)
	}
	{
		p.SetState(1037)
		p.Match(Python3ParserNAME)
	}
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserOPEN_PAREN {
		{
			p.SetState(1038)
			p.Match(Python3ParserOPEN_PAREN)
		}
		p.SetState(1040)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserSTAR - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserPOWER - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
			{
				p.SetState(1039)
				p.Arglist()
			}

		}
		{
			p.SetState(1042)
			p.Match(Python3ParserCLOSE_PAREN)
		}

	}
	{
		p.SetState(1045)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(1046)
		p.Suite()
	}



	return localctx
}


// IArglistContext is an interface to support dynamic dispatch.
type IArglistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArglistContext differentiates from other interfaces.
	IsArglistContext()
}

type ArglistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArglistContext() *ArglistContext {
	var p = new(ArglistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_arglist
	return p
}

func (*ArglistContext) IsArglistContext() {}

func NewArglistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArglistContext {
	var p = new(ArglistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_arglist

	return p
}

func (s *ArglistContext) GetParser() antlr.Parser { return s.parser }

func (s *ArglistContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *ArglistContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArglistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *ArglistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *ArglistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArglistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArglistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterArglist(s)
	}
}

func (s *ArglistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitArglist(s)
	}
}




func (p *Python3Parser) Arglist() (localctx IArglistContext) {
	localctx = NewArglistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Python3ParserRULE_arglist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1048)
		p.Argument()
	}
	p.SetState(1053)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1049)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(1050)
				p.Argument()
			}


		}
		p.SetState(1055)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext())
	}
	p.SetState(1057)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserCOMMA {
		{
			p.SetState(1056)
			p.Match(Python3ParserCOMMA)
		}

	}



	return localctx
}


// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *ArgumentContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArgumentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, 0)
}

func (s *ArgumentContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *ArgumentContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *ArgumentContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitArgument(s)
	}
}




func (p *Python3Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Python3ParserRULE_argument)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1071)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1059)
			p.Test()
		}
		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python3ParserFOR || _la == Python3ParserASYNC {
			{
				p.SetState(1060)
				p.Comp_for()
			}

		}


	case 2:
		{
			p.SetState(1063)
			p.Test()
		}
		{
			p.SetState(1064)
			p.Match(Python3ParserASSIGN)
		}
		{
			p.SetState(1065)
			p.Test()
		}


	case 3:
		{
			p.SetState(1067)
			p.Match(Python3ParserPOWER)
		}
		{
			p.SetState(1068)
			p.Test()
		}


	case 4:
		{
			p.SetState(1069)
			p.Match(Python3ParserSTAR)
		}
		{
			p.SetState(1070)
			p.Test()
		}

	}



	return localctx
}


// IComp_iterContext is an interface to support dynamic dispatch.
type IComp_iterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_iterContext differentiates from other interfaces.
	IsComp_iterContext()
}

type Comp_iterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_iterContext() *Comp_iterContext {
	var p = new(Comp_iterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_iter
	return p
}

func (*Comp_iterContext) IsComp_iterContext() {}

func NewComp_iterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_iterContext {
	var p = new(Comp_iterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_iter

	return p
}

func (s *Comp_iterContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_iterContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Comp_iterContext) Comp_if() IComp_ifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_ifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_ifContext)
}

func (s *Comp_iterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_iterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_iterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComp_iter(s)
	}
}

func (s *Comp_iterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComp_iter(s)
	}
}




func (p *Python3Parser) Comp_iter() (localctx IComp_iterContext) {
	localctx = NewComp_iterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Python3ParserRULE_comp_iter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1075)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFOR, Python3ParserASYNC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1073)
			p.Comp_for()
		}


	case Python3ParserIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1074)
			p.Comp_if()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IComp_forContext is an interface to support dynamic dispatch.
type IComp_forContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_forContext differentiates from other interfaces.
	IsComp_forContext()
}

type Comp_forContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_forContext() *Comp_forContext {
	var p = new(Comp_forContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_for
	return p
}

func (*Comp_forContext) IsComp_forContext() {}

func NewComp_forContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_forContext {
	var p = new(Comp_forContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_for

	return p
}

func (s *Comp_forContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_forContext) FOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserFOR, 0)
}

func (s *Comp_forContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Comp_forContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *Comp_forContext) Or_test() IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Comp_forContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *Comp_forContext) Comp_iter() IComp_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_forContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_forContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_forContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComp_for(s)
	}
}

func (s *Comp_forContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComp_for(s)
	}
}




func (p *Python3Parser) Comp_for() (localctx IComp_forContext) {
	localctx = NewComp_forContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Python3ParserRULE_comp_for)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python3ParserASYNC {
		{
			p.SetState(1077)
			p.Match(Python3ParserASYNC)
		}

	}
	{
		p.SetState(1080)
		p.Match(Python3ParserFOR)
	}
	{
		p.SetState(1081)
		p.Exprlist()
	}
	{
		p.SetState(1082)
		p.Match(Python3ParserIN)
	}
	{
		p.SetState(1083)
		p.Or_test()
	}
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 15)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 15))) & ((1 << (Python3ParserIF - 15)) | (1 << (Python3ParserFOR - 15)) | (1 << (Python3ParserASYNC - 15)))) != 0) {
		{
			p.SetState(1084)
			p.Comp_iter()
		}

	}



	return localctx
}


// IComp_ifContext is an interface to support dynamic dispatch.
type IComp_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_ifContext differentiates from other interfaces.
	IsComp_ifContext()
}

type Comp_ifContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_ifContext() *Comp_ifContext {
	var p = new(Comp_ifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_if
	return p
}

func (*Comp_ifContext) IsComp_ifContext() {}

func NewComp_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_ifContext {
	var p = new(Comp_ifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_if

	return p
}

func (s *Comp_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_ifContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *Comp_ifContext) Test_nocond() ITest_nocondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITest_nocondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITest_nocondContext)
}

func (s *Comp_ifContext) Comp_iter() IComp_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComp_if(s)
	}
}

func (s *Comp_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComp_if(s)
	}
}




func (p *Python3Parser) Comp_if() (localctx IComp_ifContext) {
	localctx = NewComp_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Python3ParserRULE_comp_if)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1087)
		p.Match(Python3ParserIF)
	}
	{
		p.SetState(1088)
		p.Test_nocond()
	}
	p.SetState(1090)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 15)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 15))) & ((1 << (Python3ParserIF - 15)) | (1 << (Python3ParserFOR - 15)) | (1 << (Python3ParserASYNC - 15)))) != 0) {
		{
			p.SetState(1089)
			p.Comp_iter()
		}

	}



	return localctx
}


// IEncoding_declContext is an interface to support dynamic dispatch.
type IEncoding_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncoding_declContext differentiates from other interfaces.
	IsEncoding_declContext()
}

type Encoding_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncoding_declContext() *Encoding_declContext {
	var p = new(Encoding_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_encoding_decl
	return p
}

func (*Encoding_declContext) IsEncoding_declContext() {}

func NewEncoding_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Encoding_declContext {
	var p = new(Encoding_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_encoding_decl

	return p
}

func (s *Encoding_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Encoding_declContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *Encoding_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Encoding_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Encoding_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterEncoding_decl(s)
	}
}

func (s *Encoding_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitEncoding_decl(s)
	}
}




func (p *Python3Parser) Encoding_decl() (localctx IEncoding_declContext) {
	localctx = NewEncoding_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Python3ParserRULE_encoding_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1092)
		p.Match(Python3ParserNAME)
	}



	return localctx
}


// IYield_exprContext is an interface to support dynamic dispatch.
type IYield_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_exprContext differentiates from other interfaces.
	IsYield_exprContext()
}

type Yield_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_exprContext() *Yield_exprContext {
	var p = new(Yield_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_expr
	return p
}

func (*Yield_exprContext) IsYield_exprContext() {}

func NewYield_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_exprContext {
	var p = new(Yield_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_expr

	return p
}

func (s *Yield_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_exprContext) YIELD() antlr.TerminalNode {
	return s.GetToken(Python3ParserYIELD, 0)
}

func (s *Yield_exprContext) Yield_arg() IYield_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_argContext)
}

func (s *Yield_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Yield_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterYield_expr(s)
	}
}

func (s *Yield_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitYield_expr(s)
	}
}




func (p *Python3Parser) Yield_expr() (localctx IYield_exprContext) {
	localctx = NewYield_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Python3ParserRULE_yield_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.Match(Python3ParserYIELD)
	}
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python3ParserSTRING) | (1 << Python3ParserNUMBER) | (1 << Python3ParserFROM) | (1 << Python3ParserLAMBDA) | (1 << Python3ParserNOT) | (1 << Python3ParserNONE) | (1 << Python3ParserTRUE))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (Python3ParserFALSE - 32)) | (1 << (Python3ParserAWAIT - 32)) | (1 << (Python3ParserNAME - 32)) | (1 << (Python3ParserELLIPSIS - 32)) | (1 << (Python3ParserOPEN_PAREN - 32)) | (1 << (Python3ParserOPEN_BRACK - 32)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (Python3ParserADD - 68)) | (1 << (Python3ParserMINUS - 68)) | (1 << (Python3ParserNOT_OP - 68)) | (1 << (Python3ParserOPEN_BRACE - 68)))) != 0) {
		{
			p.SetState(1095)
			p.Yield_arg()
		}

	}



	return localctx
}


// IYield_argContext is an interface to support dynamic dispatch.
type IYield_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_argContext differentiates from other interfaces.
	IsYield_argContext()
}

type Yield_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_argContext() *Yield_argContext {
	var p = new(Yield_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_arg
	return p
}

func (*Yield_argContext) IsYield_argContext() {}

func NewYield_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_argContext {
	var p = new(Yield_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_arg

	return p
}

func (s *Yield_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_argContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Yield_argContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Yield_argContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Yield_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Yield_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterYield_arg(s)
	}
}

func (s *Yield_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitYield_arg(s)
	}
}




func (p *Python3Parser) Yield_arg() (localctx IYield_argContext) {
	localctx = NewYield_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Python3ParserRULE_yield_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1101)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFROM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1098)
			p.Match(Python3ParserFROM)
		}
		{
			p.SetState(1099)
			p.Test()
		}


	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1100)
			p.Testlist()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


