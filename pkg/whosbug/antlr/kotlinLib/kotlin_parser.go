// Code generated from D:/Desktop/Whosbug_antlr_go/antlr4_kotlin/ast_kotlin\KotlinParser.g4 by ANTLR 4.9.1. DO NOT EDIT.
package kotlinLib // KotlinParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 172, 2640,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 3, 2, 7, 2, 296, 10, 2, 12, 2, 14, 2, 299, 11, 2, 3, 2, 3, 2, 7,
	2, 303, 10, 2, 12, 2, 14, 2, 306, 11, 2, 3, 2, 3, 2, 6, 2, 310, 10, 2,
	13, 2, 14, 2, 311, 3, 2, 5, 2, 315, 10, 2, 7, 2, 317, 10, 2, 12, 2, 14,
	2, 320, 11, 2, 5, 2, 322, 10, 2, 3, 2, 3, 2, 3, 3, 7, 3, 327, 10, 3, 12,
	3, 14, 3, 330, 11, 3, 3, 3, 3, 3, 7, 3, 334, 10, 3, 12, 3, 14, 3, 337,
	11, 3, 3, 3, 3, 3, 6, 3, 341, 10, 3, 13, 3, 14, 3, 342, 3, 3, 5, 3, 346,
	10, 3, 7, 3, 348, 10, 3, 12, 3, 14, 3, 351, 11, 3, 5, 3, 353, 10, 3, 3,
	3, 3, 3, 3, 4, 5, 4, 358, 10, 4, 3, 4, 3, 4, 3, 4, 3, 5, 6, 5, 364, 10,
	5, 13, 5, 14, 5, 365, 3, 6, 3, 6, 3, 6, 3, 6, 6, 6, 372, 10, 6, 13, 6,
	14, 6, 373, 3, 6, 3, 6, 3, 6, 5, 6, 379, 10, 6, 3, 6, 5, 6, 382, 10, 6,
	6, 6, 384, 10, 6, 13, 6, 14, 6, 385, 3, 7, 5, 7, 389, 10, 7, 3, 7, 3, 7,
	3, 7, 5, 7, 394, 10, 7, 5, 7, 396, 10, 7, 3, 8, 7, 8, 399, 10, 8, 12, 8,
	14, 8, 402, 11, 8, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 409, 10, 9, 3, 9,
	5, 9, 412, 10, 9, 3, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11,
	5, 11, 422, 10, 11, 3, 12, 5, 12, 425, 10, 12, 3, 12, 3, 12, 7, 12, 429,
	10, 12, 12, 12, 14, 12, 432, 11, 12, 3, 12, 3, 12, 7, 12, 436, 10, 12,
	12, 12, 14, 12, 439, 11, 12, 3, 12, 5, 12, 442, 10, 12, 3, 12, 7, 12, 445,
	10, 12, 12, 12, 14, 12, 448, 11, 12, 3, 12, 5, 12, 451, 10, 12, 3, 12,
	7, 12, 454, 10, 12, 12, 12, 14, 12, 457, 11, 12, 3, 12, 3, 12, 7, 12, 461,
	10, 12, 12, 12, 14, 12, 464, 11, 12, 3, 12, 5, 12, 467, 10, 12, 3, 12,
	7, 12, 470, 10, 12, 12, 12, 14, 12, 473, 11, 12, 3, 12, 5, 12, 476, 10,
	12, 3, 12, 7, 12, 479, 10, 12, 12, 12, 14, 12, 482, 11, 12, 3, 12, 3, 12,
	7, 12, 486, 10, 12, 12, 12, 14, 12, 489, 11, 12, 3, 12, 5, 12, 492, 10,
	12, 3, 13, 5, 13, 495, 10, 13, 3, 13, 3, 13, 7, 13, 499, 10, 13, 12, 13,
	14, 13, 502, 11, 13, 5, 13, 504, 10, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3,
	14, 3, 14, 7, 14, 512, 10, 14, 12, 14, 14, 14, 515, 11, 14, 5, 14, 517,
	10, 14, 3, 14, 3, 14, 3, 15, 5, 15, 522, 10, 15, 3, 15, 5, 15, 525, 10,
	15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 532, 10, 15, 3, 16, 7, 16,
	535, 10, 16, 12, 16, 14, 16, 538, 11, 16, 3, 16, 3, 16, 7, 16, 542, 10,
	16, 12, 16, 14, 16, 545, 11, 16, 3, 16, 3, 16, 7, 16, 549, 10, 16, 12,
	16, 14, 16, 552, 11, 16, 3, 16, 7, 16, 555, 10, 16, 12, 16, 14, 16, 558,
	11, 16, 3, 17, 3, 17, 3, 17, 5, 17, 563, 10, 17, 3, 18, 3, 18, 3, 18, 3,
	19, 3, 19, 7, 19, 570, 10, 19, 12, 19, 14, 19, 573, 11, 19, 3, 19, 3, 19,
	7, 19, 577, 10, 19, 12, 19, 14, 19, 580, 11, 19, 3, 19, 3, 19, 3, 20, 3,
	20, 7, 20, 586, 10, 20, 12, 20, 14, 20, 589, 11, 20, 3, 20, 7, 20, 592,
	10, 20, 12, 20, 14, 20, 595, 11, 20, 3, 20, 7, 20, 598, 10, 20, 12, 20,
	14, 20, 601, 11, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 5, 21, 613, 10, 21, 3, 21, 6, 21, 616, 10, 21, 13, 21,
	14, 21, 617, 3, 22, 3, 22, 7, 22, 622, 10, 22, 12, 22, 14, 22, 625, 11,
	22, 3, 22, 3, 22, 3, 23, 5, 23, 630, 10, 23, 3, 23, 3, 23, 7, 23, 634,
	10, 23, 12, 23, 14, 23, 637, 11, 23, 3, 23, 3, 23, 7, 23, 641, 10, 23,
	12, 23, 14, 23, 644, 11, 23, 3, 23, 3, 23, 7, 23, 648, 10, 23, 12, 23,
	14, 23, 651, 11, 23, 3, 23, 5, 23, 654, 10, 23, 3, 23, 7, 23, 657, 10,
	23, 12, 23, 14, 23, 660, 11, 23, 3, 23, 5, 23, 663, 10, 23, 3, 24, 3, 24,
	7, 24, 667, 10, 24, 12, 24, 14, 24, 670, 11, 24, 3, 24, 3, 24, 3, 24, 7,
	24, 675, 10, 24, 12, 24, 14, 24, 678, 11, 24, 3, 24, 5, 24, 681, 10, 24,
	3, 25, 3, 25, 7, 25, 685, 10, 25, 12, 25, 14, 25, 688, 11, 25, 3, 25, 5,
	25, 691, 10, 25, 3, 25, 7, 25, 694, 10, 25, 12, 25, 14, 25, 697, 11, 25,
	3, 25, 3, 25, 7, 25, 701, 10, 25, 12, 25, 14, 25, 704, 11, 25, 3, 25, 7,
	25, 707, 10, 25, 12, 25, 14, 25, 710, 11, 25, 5, 25, 712, 10, 25, 3, 25,
	7, 25, 715, 10, 25, 12, 25, 14, 25, 718, 11, 25, 3, 25, 3, 25, 3, 26, 3,
	26, 7, 26, 724, 10, 26, 12, 26, 14, 26, 727, 11, 26, 6, 26, 729, 10, 26,
	13, 26, 14, 26, 730, 3, 26, 5, 26, 734, 10, 26, 3, 27, 3, 27, 7, 27, 738,
	10, 27, 12, 27, 14, 27, 741, 11, 27, 3, 27, 5, 27, 744, 10, 27, 3, 27,
	7, 27, 747, 10, 27, 12, 27, 14, 27, 750, 11, 27, 3, 27, 5, 27, 753, 10,
	27, 3, 27, 7, 27, 756, 10, 27, 12, 27, 14, 27, 759, 11, 27, 3, 27, 5, 27,
	762, 10, 27, 3, 28, 5, 28, 765, 10, 28, 3, 28, 3, 28, 7, 28, 769, 10, 28,
	12, 28, 14, 28, 772, 11, 28, 3, 28, 3, 28, 7, 28, 776, 10, 28, 12, 28,
	14, 28, 779, 11, 28, 3, 28, 3, 28, 5, 28, 783, 10, 28, 3, 28, 7, 28, 786,
	10, 28, 12, 28, 14, 28, 789, 11, 28, 3, 28, 5, 28, 792, 10, 28, 3, 28,
	7, 28, 795, 10, 28, 12, 28, 14, 28, 798, 11, 28, 3, 28, 5, 28, 801, 10,
	28, 3, 28, 7, 28, 804, 10, 28, 12, 28, 14, 28, 807, 11, 28, 3, 28, 3, 28,
	7, 28, 811, 10, 28, 12, 28, 14, 28, 814, 11, 28, 3, 28, 3, 28, 7, 28, 818,
	10, 28, 12, 28, 14, 28, 821, 11, 28, 3, 28, 5, 28, 824, 10, 28, 3, 28,
	7, 28, 827, 10, 28, 12, 28, 14, 28, 830, 11, 28, 3, 28, 5, 28, 833, 10,
	28, 3, 28, 7, 28, 836, 10, 28, 12, 28, 14, 28, 839, 11, 28, 3, 28, 5, 28,
	842, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 848, 10, 29, 12, 29, 14,
	29, 851, 11, 29, 5, 29, 853, 10, 29, 3, 29, 3, 29, 3, 30, 5, 30, 858, 10,
	30, 3, 30, 3, 30, 3, 30, 5, 30, 863, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31,
	3, 32, 3, 32, 3, 32, 7, 32, 872, 10, 32, 12, 32, 14, 32, 875, 11, 32, 3,
	32, 5, 32, 878, 10, 32, 3, 33, 5, 33, 881, 10, 33, 3, 33, 3, 33, 7, 33,
	885, 10, 33, 12, 33, 14, 33, 888, 11, 33, 3, 33, 3, 33, 7, 33, 892, 10,
	33, 12, 33, 14, 33, 895, 11, 33, 3, 33, 5, 33, 898, 10, 33, 3, 33, 7, 33,
	901, 10, 33, 12, 33, 14, 33, 904, 11, 33, 3, 33, 3, 33, 7, 33, 908, 10,
	33, 12, 33, 14, 33, 911, 11, 33, 3, 33, 5, 33, 914, 10, 33, 3, 33, 7, 33,
	917, 10, 33, 12, 33, 14, 33, 920, 11, 33, 3, 33, 5, 33, 923, 10, 33, 3,
	34, 5, 34, 926, 10, 34, 3, 34, 3, 34, 7, 34, 930, 10, 34, 12, 34, 14, 34,
	933, 11, 34, 3, 34, 5, 34, 936, 10, 34, 3, 34, 3, 34, 7, 34, 940, 10, 34,
	12, 34, 14, 34, 943, 11, 34, 3, 34, 5, 34, 946, 10, 34, 3, 34, 7, 34, 949,
	10, 34, 12, 34, 14, 34, 952, 11, 34, 3, 34, 3, 34, 7, 34, 956, 10, 34,
	12, 34, 14, 34, 959, 11, 34, 3, 34, 5, 34, 962, 10, 34, 3, 34, 7, 34, 965,
	10, 34, 12, 34, 14, 34, 968, 11, 34, 3, 34, 5, 34, 971, 10, 34, 3, 35,
	5, 35, 974, 10, 35, 3, 35, 3, 35, 7, 35, 978, 10, 35, 12, 35, 14, 35, 981,
	11, 35, 3, 35, 5, 35, 984, 10, 35, 3, 35, 7, 35, 987, 10, 35, 12, 35, 14,
	35, 990, 11, 35, 3, 35, 3, 35, 7, 35, 994, 10, 35, 12, 35, 14, 35, 997,
	11, 35, 3, 35, 3, 35, 5, 35, 1001, 10, 35, 3, 35, 7, 35, 1004, 10, 35,
	12, 35, 14, 35, 1007, 11, 35, 3, 35, 3, 35, 5, 35, 1011, 10, 35, 3, 35,
	7, 35, 1014, 10, 35, 12, 35, 14, 35, 1017, 11, 35, 3, 35, 5, 35, 1020,
	10, 35, 3, 35, 7, 35, 1023, 10, 35, 12, 35, 14, 35, 1026, 11, 35, 3, 35,
	3, 35, 7, 35, 1030, 10, 35, 12, 35, 14, 35, 1033, 11, 35, 3, 35, 5, 35,
	1036, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 1042, 10, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 5, 35, 1048, 10, 35, 5, 35, 1050, 10, 35, 3, 36, 3, 36,
	3, 36, 3, 36, 7, 36, 1056, 10, 36, 12, 36, 14, 36, 1059, 11, 36, 3, 36,
	3, 36, 3, 37, 3, 37, 3, 37, 5, 37, 1066, 10, 37, 3, 38, 5, 38, 1069, 10,
	38, 3, 38, 3, 38, 5, 38, 1073, 10, 38, 3, 38, 3, 38, 7, 38, 1077, 10, 38,
	12, 38, 14, 38, 1080, 11, 38, 3, 38, 3, 38, 3, 38, 7, 38, 1085, 10, 38,
	12, 38, 14, 38, 1088, 11, 38, 3, 38, 3, 38, 7, 38, 1092, 10, 38, 12, 38,
	14, 38, 1095, 11, 38, 3, 38, 5, 38, 1098, 10, 38, 3, 38, 7, 38, 1101, 10,
	38, 12, 38, 14, 38, 1104, 11, 38, 3, 38, 3, 38, 3, 38, 7, 38, 1109, 10,
	38, 12, 38, 14, 38, 1112, 11, 38, 3, 38, 5, 38, 1115, 10, 38, 5, 38, 1117,
	10, 38, 3, 39, 5, 39, 1120, 10, 39, 3, 39, 3, 39, 5, 39, 1124, 10, 39,
	3, 39, 3, 39, 7, 39, 1128, 10, 39, 12, 39, 14, 39, 1131, 11, 39, 3, 39,
	3, 39, 3, 39, 7, 39, 1136, 10, 39, 12, 39, 14, 39, 1139, 11, 39, 3, 39,
	3, 39, 5, 39, 1143, 10, 39, 3, 39, 3, 39, 7, 39, 1147, 10, 39, 12, 39,
	14, 39, 1150, 11, 39, 3, 39, 3, 39, 5, 39, 1154, 10, 39, 3, 40, 5, 40,
	1157, 10, 40, 3, 40, 3, 40, 7, 40, 1161, 10, 40, 12, 40, 14, 40, 1164,
	11, 40, 3, 40, 3, 40, 7, 40, 1168, 10, 40, 12, 40, 14, 40, 1171, 11, 40,
	3, 40, 5, 40, 1174, 10, 40, 3, 40, 7, 40, 1177, 10, 40, 12, 40, 14, 40,
	1180, 11, 40, 3, 40, 3, 40, 7, 40, 1184, 10, 40, 12, 40, 14, 40, 1187,
	11, 40, 3, 40, 3, 40, 3, 41, 3, 41, 7, 41, 1193, 10, 41, 12, 41, 14, 41,
	1196, 11, 41, 3, 41, 3, 41, 7, 41, 1200, 10, 41, 12, 41, 14, 41, 1203,
	11, 41, 3, 41, 3, 41, 7, 41, 1207, 10, 41, 12, 41, 14, 41, 1210, 11, 41,
	3, 41, 7, 41, 1213, 10, 41, 12, 41, 14, 41, 1216, 11, 41, 3, 41, 7, 41,
	1219, 10, 41, 12, 41, 14, 41, 1222, 11, 41, 3, 41, 3, 41, 3, 42, 5, 42,
	1227, 10, 42, 3, 42, 7, 42, 1230, 10, 42, 12, 42, 14, 42, 1233, 11, 42,
	3, 42, 3, 42, 7, 42, 1237, 10, 42, 12, 42, 14, 42, 1240, 11, 42, 3, 42,
	3, 42, 7, 42, 1244, 10, 42, 12, 42, 14, 42, 1247, 11, 42, 3, 42, 5, 42,
	1250, 10, 42, 3, 43, 5, 43, 1253, 10, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5,
	43, 1259, 10, 43, 3, 44, 3, 44, 3, 44, 7, 44, 1264, 10, 44, 12, 44, 14,
	44, 1267, 11, 44, 6, 44, 1269, 10, 44, 13, 44, 14, 44, 1270, 3, 45, 3,
	45, 3, 45, 3, 45, 3, 46, 3, 46, 5, 46, 1279, 10, 46, 3, 46, 7, 46, 1282,
	10, 46, 12, 46, 14, 46, 1285, 11, 46, 3, 46, 6, 46, 1288, 10, 46, 13, 46,
	14, 46, 1289, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 1298, 10,
	47, 3, 48, 3, 48, 7, 48, 1302, 10, 48, 12, 48, 14, 48, 1305, 11, 48, 3,
	48, 3, 48, 7, 48, 1309, 10, 48, 12, 48, 14, 48, 1312, 11, 48, 5, 48, 1314,
	10, 48, 3, 48, 3, 48, 7, 48, 1318, 10, 48, 12, 48, 14, 48, 1321, 11, 48,
	3, 48, 3, 48, 7, 48, 1325, 10, 48, 12, 48, 14, 48, 1328, 11, 48, 3, 48,
	3, 48, 3, 49, 3, 49, 3, 49, 5, 49, 1335, 10, 49, 3, 50, 3, 50, 7, 50, 1339,
	10, 50, 12, 50, 14, 50, 1342, 11, 50, 3, 50, 3, 50, 7, 50, 1346, 10, 50,
	12, 50, 14, 50, 1349, 11, 50, 3, 50, 7, 50, 1352, 10, 50, 12, 50, 14, 50,
	1355, 11, 50, 3, 51, 3, 51, 7, 51, 1359, 10, 51, 12, 51, 14, 51, 1362,
	11, 51, 3, 51, 5, 51, 1365, 10, 51, 3, 52, 3, 52, 3, 52, 5, 52, 1370, 10,
	52, 3, 52, 3, 52, 3, 52, 5, 52, 1375, 10, 52, 7, 52, 1377, 10, 52, 12,
	52, 14, 52, 1380, 11, 52, 3, 52, 3, 52, 3, 53, 3, 53, 7, 53, 1386, 10,
	53, 12, 53, 14, 53, 1389, 11, 53, 3, 53, 3, 53, 7, 53, 1393, 10, 53, 12,
	53, 14, 53, 1396, 11, 53, 3, 53, 3, 53, 7, 53, 1400, 10, 53, 12, 53, 14,
	53, 1403, 11, 53, 3, 53, 7, 53, 1406, 10, 53, 12, 53, 14, 53, 1409, 11,
	53, 3, 54, 7, 54, 1412, 10, 54, 12, 54, 14, 54, 1415, 11, 54, 3, 54, 3,
	54, 7, 54, 1419, 10, 54, 12, 54, 14, 54, 1422, 11, 54, 3, 54, 3, 54, 7,
	54, 1426, 10, 54, 12, 54, 14, 54, 1429, 11, 54, 3, 54, 3, 54, 3, 55, 3,
	55, 3, 55, 3, 55, 3, 56, 7, 56, 1438, 10, 56, 12, 56, 14, 56, 1441, 11,
	56, 3, 56, 3, 56, 6, 56, 1445, 10, 56, 13, 56, 14, 56, 1446, 3, 56, 5,
	56, 1450, 10, 56, 7, 56, 1452, 10, 56, 12, 56, 14, 56, 1455, 11, 56, 5,
	56, 1457, 10, 56, 3, 57, 3, 57, 5, 57, 1461, 10, 57, 3, 58, 7, 58, 1464,
	10, 58, 12, 58, 14, 58, 1467, 11, 58, 3, 58, 7, 58, 1470, 10, 58, 12, 58,
	14, 58, 1473, 11, 58, 3, 58, 3, 58, 3, 59, 7, 59, 1478, 10, 59, 12, 59,
	14, 59, 1481, 11, 59, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 1487, 10, 59,
	3, 60, 3, 60, 3, 60, 3, 60, 7, 60, 1493, 10, 60, 12, 60, 14, 60, 1496,
	11, 60, 3, 61, 3, 61, 7, 61, 1500, 10, 61, 12, 61, 14, 61, 1503, 11, 61,
	3, 61, 3, 61, 7, 61, 1507, 10, 61, 12, 61, 14, 61, 1510, 11, 61, 3, 61,
	7, 61, 1513, 10, 61, 12, 61, 14, 61, 1516, 11, 61, 3, 62, 3, 62, 7, 62,
	1520, 10, 62, 12, 62, 14, 62, 1523, 11, 62, 3, 62, 3, 62, 7, 62, 1527,
	10, 62, 12, 62, 14, 62, 1530, 11, 62, 3, 62, 7, 62, 1533, 10, 62, 12, 62,
	14, 62, 1536, 11, 62, 3, 63, 3, 63, 3, 63, 7, 63, 1541, 10, 63, 12, 63,
	14, 63, 1544, 11, 63, 3, 63, 3, 63, 7, 63, 1548, 10, 63, 12, 63, 14, 63,
	1551, 11, 63, 3, 64, 3, 64, 3, 64, 7, 64, 1556, 10, 64, 12, 64, 14, 64,
	1559, 11, 64, 3, 64, 3, 64, 5, 64, 1563, 10, 64, 3, 65, 3, 65, 3, 65, 7,
	65, 1568, 10, 65, 12, 65, 14, 65, 1571, 11, 65, 3, 65, 3, 65, 6, 65, 1575,
	10, 65, 13, 65, 14, 65, 1576, 3, 65, 3, 65, 7, 65, 1581, 10, 65, 12, 65,
	14, 65, 1584, 11, 65, 3, 65, 3, 65, 5, 65, 1588, 10, 65, 3, 66, 3, 66,
	7, 66, 1592, 10, 66, 12, 66, 14, 66, 1595, 11, 66, 3, 66, 3, 66, 7, 66,
	1599, 10, 66, 12, 66, 14, 66, 1602, 11, 66, 3, 66, 7, 66, 1605, 10, 66,
	12, 66, 14, 66, 1608, 11, 66, 3, 67, 3, 67, 3, 67, 7, 67, 1613, 10, 67,
	12, 67, 14, 67, 1616, 11, 67, 3, 67, 3, 67, 7, 67, 1620, 10, 67, 12, 67,
	14, 67, 1623, 11, 67, 3, 68, 3, 68, 3, 68, 7, 68, 1628, 10, 68, 12, 68,
	14, 68, 1631, 11, 68, 3, 68, 7, 68, 1634, 10, 68, 12, 68, 14, 68, 1637,
	11, 68, 3, 69, 3, 69, 3, 69, 7, 69, 1642, 10, 69, 12, 69, 14, 69, 1645,
	11, 69, 3, 69, 3, 69, 7, 69, 1649, 10, 69, 12, 69, 14, 69, 1652, 11, 69,
	3, 70, 3, 70, 3, 70, 7, 70, 1657, 10, 70, 12, 70, 14, 70, 1660, 11, 70,
	3, 70, 3, 70, 7, 70, 1664, 10, 70, 12, 70, 14, 70, 1667, 11, 70, 3, 71,
	3, 71, 7, 71, 1671, 10, 71, 12, 71, 14, 71, 1674, 11, 71, 3, 71, 3, 71,
	3, 71, 7, 71, 1679, 10, 71, 12, 71, 14, 71, 1682, 11, 71, 3, 72, 7, 72,
	1685, 10, 72, 12, 72, 14, 72, 1688, 11, 72, 3, 72, 3, 72, 3, 73, 3, 73,
	5, 73, 1694, 10, 73, 3, 73, 7, 73, 1697, 10, 73, 12, 73, 14, 73, 1700,
	11, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 3, 74, 5, 74, 1714, 10, 74, 3, 75, 3, 75, 3, 75, 3, 75, 3,
	76, 3, 76, 5, 76, 1722, 10, 76, 3, 76, 7, 76, 1725, 10, 76, 12, 76, 14,
	76, 1728, 11, 76, 3, 76, 3, 76, 7, 76, 1732, 10, 76, 12, 76, 14, 76, 1735,
	11, 76, 3, 76, 6, 76, 1738, 10, 76, 13, 76, 14, 76, 1739, 5, 76, 1742,
	10, 76, 3, 77, 7, 77, 1745, 10, 77, 12, 77, 14, 77, 1748, 11, 77, 3, 77,
	5, 77, 1751, 10, 77, 3, 77, 7, 77, 1754, 10, 77, 12, 77, 14, 77, 1757,
	11, 77, 3, 77, 3, 77, 3, 78, 3, 78, 3, 78, 3, 78, 7, 78, 1765, 10, 78,
	12, 78, 14, 78, 1768, 11, 78, 5, 78, 1770, 10, 78, 3, 78, 3, 78, 3, 79,
	3, 79, 3, 79, 3, 79, 7, 79, 1778, 10, 79, 12, 79, 14, 79, 1781, 11, 79,
	5, 79, 1783, 10, 79, 3, 79, 3, 79, 3, 80, 3, 80, 7, 80, 1789, 10, 80, 12,
	80, 14, 80, 1792, 11, 80, 3, 80, 3, 80, 7, 80, 1796, 10, 80, 12, 80, 14,
	80, 1799, 11, 80, 3, 80, 3, 80, 7, 80, 1803, 10, 80, 12, 80, 14, 80, 1806,
	11, 80, 3, 80, 7, 80, 1809, 10, 80, 12, 80, 14, 80, 1812, 11, 80, 3, 80,
	3, 80, 3, 81, 5, 81, 1817, 10, 81, 3, 81, 3, 81, 5, 81, 1821, 10, 81, 3,
	82, 6, 82, 1824, 10, 82, 13, 82, 14, 82, 1825, 3, 83, 3, 83, 7, 83, 1830,
	10, 83, 12, 83, 14, 83, 1833, 11, 83, 3, 83, 3, 83, 7, 83, 1837, 10, 83,
	12, 83, 14, 83, 1840, 11, 83, 5, 83, 1842, 10, 83, 3, 83, 5, 83, 1845,
	10, 83, 3, 83, 7, 83, 1848, 10, 83, 12, 83, 14, 83, 1851, 11, 83, 3, 83,
	3, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 5,
	84, 1864, 10, 84, 3, 85, 3, 85, 5, 85, 1868, 10, 85, 3, 86, 3, 86, 3, 86,
	7, 86, 1873, 10, 86, 12, 86, 14, 86, 1876, 11, 86, 3, 86, 3, 86, 3, 87,
	3, 87, 3, 87, 3, 87, 3, 87, 7, 87, 1885, 10, 87, 12, 87, 14, 87, 1888,
	11, 87, 3, 87, 3, 87, 3, 88, 3, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 90,
	3, 90, 3, 91, 3, 91, 3, 91, 3, 91, 3, 92, 7, 92, 1905, 10, 92, 12, 92,
	14, 92, 1908, 11, 92, 3, 92, 3, 92, 7, 92, 1912, 10, 92, 12, 92, 14, 92,
	1915, 11, 92, 3, 92, 3, 92, 7, 92, 1919, 10, 92, 12, 92, 14, 92, 1922,
	11, 92, 3, 92, 3, 92, 3, 92, 3, 92, 7, 92, 1928, 10, 92, 12, 92, 14, 92,
	1931, 11, 92, 3, 92, 3, 92, 7, 92, 1935, 10, 92, 12, 92, 14, 92, 1938,
	11, 92, 3, 92, 3, 92, 7, 92, 1942, 10, 92, 12, 92, 14, 92, 1945, 11, 92,
	3, 92, 3, 92, 7, 92, 1949, 10, 92, 12, 92, 14, 92, 1952, 11, 92, 3, 92,
	3, 92, 5, 92, 1956, 10, 92, 3, 93, 5, 93, 1959, 10, 93, 3, 93, 7, 93, 1962,
	10, 93, 12, 93, 14, 93, 1965, 11, 93, 3, 93, 3, 93, 7, 93, 1969, 10, 93,
	12, 93, 14, 93, 1972, 11, 93, 3, 93, 7, 93, 1975, 10, 93, 12, 93, 14, 93,
	1978, 11, 93, 3, 94, 3, 94, 3, 94, 7, 94, 1983, 10, 94, 12, 94, 14, 94,
	1986, 11, 94, 3, 94, 3, 94, 7, 94, 1990, 10, 94, 12, 94, 14, 94, 1993,
	11, 94, 3, 94, 5, 94, 1996, 10, 94, 5, 94, 1998, 10, 94, 3, 95, 3, 95,
	7, 95, 2002, 10, 95, 12, 95, 14, 95, 2005, 11, 95, 3, 95, 3, 95, 7, 95,
	2009, 10, 95, 12, 95, 14, 95, 2012, 11, 95, 3, 95, 5, 95, 2015, 10, 95,
	3, 95, 7, 95, 2018, 10, 95, 12, 95, 14, 95, 2021, 11, 95, 3, 95, 3, 95,
	3, 96, 3, 96, 5, 96, 2027, 10, 96, 3, 96, 3, 96, 7, 96, 2031, 10, 96, 12,
	96, 14, 96, 2034, 11, 96, 3, 96, 3, 96, 3, 97, 3, 97, 5, 97, 2040, 10,
	97, 3, 98, 3, 98, 3, 98, 7, 98, 2045, 10, 98, 12, 98, 14, 98, 2048, 11,
	98, 3, 98, 3, 98, 7, 98, 2052, 10, 98, 12, 98, 14, 98, 2055, 11, 98, 3,
	98, 3, 98, 5, 98, 2059, 10, 98, 3, 98, 5, 98, 2062, 10, 98, 3, 99, 3, 99,
	5, 99, 2066, 10, 99, 3, 100, 3, 100, 7, 100, 2070, 10, 100, 12, 100, 14,
	100, 2073, 11, 100, 3, 100, 3, 100, 3, 100, 3, 100, 7, 100, 2079, 10, 100,
	12, 100, 14, 100, 2082, 11, 100, 3, 100, 5, 100, 2085, 10, 100, 3, 100,
	5, 100, 2088, 10, 100, 3, 100, 7, 100, 2091, 10, 100, 12, 100, 14, 100,
	2094, 11, 100, 3, 100, 3, 100, 7, 100, 2098, 10, 100, 12, 100, 14, 100,
	2101, 11, 100, 3, 100, 5, 100, 2104, 10, 100, 5, 100, 2106, 10, 100, 3,
	101, 3, 101, 5, 101, 2110, 10, 101, 3, 102, 3, 102, 7, 102, 2114, 10, 102,
	12, 102, 14, 102, 2117, 11, 102, 3, 102, 3, 102, 3, 102, 3, 102, 5, 102,
	2123, 10, 102, 3, 102, 7, 102, 2126, 10, 102, 12, 102, 14, 102, 2129, 11,
	102, 3, 102, 3, 102, 7, 102, 2133, 10, 102, 12, 102, 14, 102, 2136, 11,
	102, 3, 102, 3, 102, 7, 102, 2140, 10, 102, 12, 102, 14, 102, 2143, 11,
	102, 7, 102, 2145, 10, 102, 12, 102, 14, 102, 2148, 11, 102, 3, 102, 7,
	102, 2151, 10, 102, 12, 102, 14, 102, 2154, 11, 102, 3, 102, 3, 102, 3,
	103, 3, 103, 7, 103, 2160, 10, 103, 12, 103, 14, 103, 2163, 11, 103, 3,
	103, 3, 103, 7, 103, 2167, 10, 103, 12, 103, 14, 103, 2170, 11, 103, 3,
	103, 7, 103, 2173, 10, 103, 12, 103, 14, 103, 2176, 11, 103, 3, 103, 7,
	103, 2179, 10, 103, 12, 103, 14, 103, 2182, 11, 103, 3, 103, 3, 103, 7,
	103, 2186, 10, 103, 12, 103, 14, 103, 2189, 11, 103, 3, 103, 3, 103, 5,
	103, 2193, 10, 103, 3, 103, 3, 103, 7, 103, 2197, 10, 103, 12, 103, 14,
	103, 2200, 11, 103, 3, 103, 3, 103, 7, 103, 2204, 10, 103, 12, 103, 14,
	103, 2207, 11, 103, 3, 103, 5, 103, 2210, 10, 103, 3, 104, 3, 104, 3, 104,
	5, 104, 2215, 10, 104, 3, 105, 3, 105, 7, 105, 2219, 10, 105, 12, 105,
	14, 105, 2222, 11, 105, 3, 105, 3, 105, 3, 106, 3, 106, 7, 106, 2228, 10,
	106, 12, 106, 14, 106, 2231, 11, 106, 3, 106, 3, 106, 3, 107, 3, 107, 7,
	107, 2237, 10, 107, 12, 107, 14, 107, 2240, 11, 107, 3, 107, 3, 107, 7,
	107, 2244, 10, 107, 12, 107, 14, 107, 2247, 11, 107, 3, 107, 7, 107, 2250,
	10, 107, 12, 107, 14, 107, 2253, 11, 107, 3, 107, 7, 107, 2256, 10, 107,
	12, 107, 14, 107, 2259, 11, 107, 3, 107, 5, 107, 2262, 10, 107, 3, 108,
	3, 108, 7, 108, 2266, 10, 108, 12, 108, 14, 108, 2269, 11, 108, 3, 108,
	3, 108, 7, 108, 2273, 10, 108, 12, 108, 14, 108, 2276, 11, 108, 3, 108,
	3, 108, 3, 108, 3, 108, 3, 108, 7, 108, 2283, 10, 108, 12, 108, 14, 108,
	2286, 11, 108, 3, 108, 3, 108, 3, 109, 3, 109, 7, 109, 2292, 10, 109, 12,
	109, 14, 109, 2295, 11, 109, 3, 109, 3, 109, 3, 110, 3, 110, 3, 110, 5,
	110, 2302, 10, 110, 3, 111, 3, 111, 7, 111, 2306, 10, 111, 12, 111, 14,
	111, 2309, 11, 111, 3, 111, 3, 111, 7, 111, 2313, 10, 111, 12, 111, 14,
	111, 2316, 11, 111, 3, 111, 3, 111, 5, 111, 2320, 10, 111, 3, 111, 3, 111,
	3, 111, 3, 111, 7, 111, 2326, 10, 111, 12, 111, 14, 111, 2329, 11, 111,
	3, 111, 5, 111, 2332, 10, 111, 3, 112, 3, 112, 7, 112, 2336, 10, 112, 12,
	112, 14, 112, 2339, 11, 112, 3, 112, 3, 112, 3, 112, 3, 112, 7, 112, 2345,
	10, 112, 12, 112, 14, 112, 2348, 11, 112, 3, 112, 5, 112, 2351, 10, 112,
	3, 113, 3, 113, 7, 113, 2355, 10, 113, 12, 113, 14, 113, 2358, 11, 113,
	3, 113, 5, 113, 2361, 10, 113, 3, 113, 7, 113, 2364, 10, 113, 12, 113,
	14, 113, 2367, 11, 113, 3, 113, 3, 113, 7, 113, 2371, 10, 113, 12, 113,
	14, 113, 2374, 11, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 114, 3, 114,
	7, 114, 2382, 10, 114, 12, 114, 14, 114, 2385, 11, 114, 3, 114, 3, 114,
	3, 114, 5, 114, 2390, 10, 114, 3, 114, 3, 114, 3, 114, 3, 114, 5, 114,
	2396, 10, 114, 3, 115, 3, 115, 3, 115, 7, 115, 2401, 10, 115, 12, 115,
	14, 115, 2404, 11, 115, 7, 115, 2406, 10, 115, 12, 115, 14, 115, 2409,
	11, 115, 5, 115, 2411, 10, 115, 3, 115, 7, 115, 2414, 10, 115, 12, 115,
	14, 115, 2417, 11, 115, 3, 115, 3, 115, 7, 115, 2421, 10, 115, 12, 115,
	14, 115, 2424, 11, 115, 3, 115, 3, 115, 5, 115, 2428, 10, 115, 3, 116,
	3, 116, 3, 117, 3, 117, 3, 118, 3, 118, 3, 119, 3, 119, 3, 120, 3, 120,
	3, 121, 3, 121, 3, 122, 3, 122, 3, 123, 3, 123, 3, 124, 3, 124, 3, 124,
	3, 124, 3, 124, 3, 124, 3, 124, 5, 124, 2453, 10, 124, 3, 125, 3, 125,
	3, 125, 3, 125, 3, 125, 3, 125, 3, 125, 7, 125, 2462, 10, 125, 12, 125,
	14, 125, 2465, 11, 125, 3, 125, 3, 125, 3, 125, 5, 125, 2470, 10, 125,
	3, 126, 3, 126, 3, 126, 5, 126, 2475, 10, 126, 3, 127, 3, 127, 6, 127,
	2479, 10, 127, 13, 127, 14, 127, 2480, 3, 128, 3, 128, 3, 128, 3, 128,
	3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 5, 128, 2492, 10, 128, 3, 128,
	7, 128, 2495, 10, 128, 12, 128, 14, 128, 2498, 11, 128, 3, 129, 3, 129,
	3, 130, 3, 130, 3, 131, 3, 131, 3, 132, 3, 132, 3, 133, 3, 133, 3, 134,
	3, 134, 3, 135, 3, 135, 3, 136, 3, 136, 3, 137, 3, 137, 3, 138, 3, 138,
	7, 138, 2520, 10, 138, 12, 138, 14, 138, 2523, 11, 138, 3, 139, 3, 139,
	5, 139, 2527, 10, 139, 3, 139, 7, 139, 2530, 10, 139, 12, 139, 14, 139,
	2533, 11, 139, 3, 140, 3, 140, 7, 140, 2537, 10, 140, 12, 140, 14, 140,
	2540, 11, 140, 3, 140, 3, 140, 7, 140, 2544, 10, 140, 12, 140, 14, 140,
	2547, 11, 140, 3, 140, 3, 140, 3, 140, 3, 140, 7, 140, 2553, 10, 140, 12,
	140, 14, 140, 2556, 11, 140, 3, 140, 5, 140, 2559, 10, 140, 3, 140, 7,
	140, 2562, 10, 140, 12, 140, 14, 140, 2565, 11, 140, 3, 140, 5, 140, 2568,
	10, 140, 5, 140, 2570, 10, 140, 3, 141, 3, 141, 3, 141, 3, 141, 6, 141,
	2576, 10, 141, 13, 141, 14, 141, 2577, 3, 141, 3, 141, 3, 141, 3, 141,
	3, 141, 6, 141, 2585, 10, 141, 13, 141, 14, 141, 2586, 3, 141, 3, 141,
	5, 141, 2591, 10, 141, 3, 142, 3, 142, 3, 143, 3, 143, 5, 143, 2597, 10,
	143, 3, 143, 5, 143, 2600, 10, 143, 3, 144, 3, 144, 7, 144, 2604, 10, 144,
	12, 144, 14, 144, 2607, 11, 144, 3, 144, 3, 144, 7, 144, 2611, 10, 144,
	12, 144, 14, 144, 2614, 11, 144, 3, 145, 3, 145, 3, 146, 6, 146, 2619,
	10, 146, 13, 146, 14, 146, 2620, 3, 146, 7, 146, 2624, 10, 146, 12, 146,
	14, 146, 2627, 11, 146, 3, 146, 3, 146, 7, 146, 2631, 10, 146, 12, 146,
	14, 146, 2634, 11, 146, 5, 146, 2636, 10, 146, 3, 147, 3, 147, 3, 147,
	2, 2, 148, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
	34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68,
	70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
	106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
	136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
	166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194,
	196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,
	226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254,
	256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284,
	286, 288, 290, 292, 2, 27, 3, 2, 61, 62, 3, 2, 65, 66, 4, 2, 29, 29, 69,
	69, 3, 2, 158, 160, 3, 2, 164, 166, 4, 2, 55, 55, 86, 86, 3, 2, 38, 39,
	3, 2, 29, 34, 4, 2, 49, 50, 52, 53, 3, 2, 45, 48, 4, 2, 91, 91, 93, 93,
	4, 2, 90, 90, 92, 92, 3, 2, 20, 21, 3, 2, 17, 19, 5, 2, 27, 27, 51, 51,
	89, 89, 3, 2, 110, 114, 4, 2, 121, 121, 126, 126, 3, 2, 106, 109, 4, 2,
	91, 91, 94, 94, 3, 2, 115, 120, 3, 2, 122, 124, 3, 2, 127, 129, 5, 2, 58,
	58, 95, 98, 101, 104, 10, 2, 60, 60, 68, 71, 75, 75, 80, 81, 94, 94, 99,
	100, 105, 130, 142, 142, 4, 2, 7, 7, 28, 28, 2, 2953, 2, 297, 3, 2, 2,
	2, 4, 328, 3, 2, 2, 2, 6, 357, 3, 2, 2, 2, 8, 363, 3, 2, 2, 2, 10, 383,
	3, 2, 2, 2, 12, 395, 3, 2, 2, 2, 14, 400, 3, 2, 2, 2, 16, 403, 3, 2, 2,
	2, 18, 413, 3, 2, 2, 2, 20, 421, 3, 2, 2, 2, 22, 424, 3, 2, 2, 2, 24, 494,
	3, 2, 2, 2, 26, 507, 3, 2, 2, 2, 28, 521, 3, 2, 2, 2, 30, 536, 3, 2, 2,
	2, 32, 562, 3, 2, 2, 2, 34, 564, 3, 2, 2, 2, 36, 567, 3, 2, 2, 2, 38, 583,
	3, 2, 2, 2, 40, 612, 3, 2, 2, 2, 42, 619, 3, 2, 2, 2, 44, 629, 3, 2, 2,
	2, 46, 680, 3, 2, 2, 2, 48, 682, 3, 2, 2, 2, 50, 728, 3, 2, 2, 2, 52, 735,
	3, 2, 2, 2, 54, 764, 3, 2, 2, 2, 56, 843, 3, 2, 2, 2, 58, 857, 3, 2, 2,
	2, 60, 864, 3, 2, 2, 2, 62, 877, 3, 2, 2, 2, 64, 880, 3, 2, 2, 2, 66, 925,
	3, 2, 2, 2, 68, 973, 3, 2, 2, 2, 70, 1051, 3, 2, 2, 2, 72, 1062, 3, 2,
	2, 2, 74, 1116, 3, 2, 2, 2, 76, 1153, 3, 2, 2, 2, 78, 1156, 3, 2, 2, 2,
	80, 1190, 3, 2, 2, 2, 82, 1226, 3, 2, 2, 2, 84, 1252, 3, 2, 2, 2, 86, 1268,
	3, 2, 2, 2, 88, 1272, 3, 2, 2, 2, 90, 1278, 3, 2, 2, 2, 92, 1297, 3, 2,
	2, 2, 94, 1313, 3, 2, 2, 2, 96, 1334, 3, 2, 2, 2, 98, 1336, 3, 2, 2, 2,
	100, 1356, 3, 2, 2, 2, 102, 1366, 3, 2, 2, 2, 104, 1383, 3, 2, 2, 2, 106,
	1413, 3, 2, 2, 2, 108, 1432, 3, 2, 2, 2, 110, 1439, 3, 2, 2, 2, 112, 1460,
	3, 2, 2, 2, 114, 1465, 3, 2, 2, 2, 116, 1479, 3, 2, 2, 2, 118, 1488, 3,
	2, 2, 2, 120, 1497, 3, 2, 2, 2, 122, 1517, 3, 2, 2, 2, 124, 1537, 3, 2,
	2, 2, 126, 1552, 3, 2, 2, 2, 128, 1564, 3, 2, 2, 2, 130, 1589, 3, 2, 2,
	2, 132, 1609, 3, 2, 2, 2, 134, 1624, 3, 2, 2, 2, 136, 1638, 3, 2, 2, 2,
	138, 1653, 3, 2, 2, 2, 140, 1668, 3, 2, 2, 2, 142, 1686, 3, 2, 2, 2, 144,
	1693, 3, 2, 2, 2, 146, 1713, 3, 2, 2, 2, 148, 1715, 3, 2, 2, 2, 150, 1741,
	3, 2, 2, 2, 152, 1746, 3, 2, 2, 2, 154, 1760, 3, 2, 2, 2, 156, 1773, 3,
	2, 2, 2, 158, 1786, 3, 2, 2, 2, 160, 1820, 3, 2, 2, 2, 162, 1823, 3, 2,
	2, 2, 164, 1841, 3, 2, 2, 2, 166, 1863, 3, 2, 2, 2, 168, 1867, 3, 2, 2,
	2, 170, 1869, 3, 2, 2, 2, 172, 1879, 3, 2, 2, 2, 174, 1891, 3, 2, 2, 2,
	176, 1893, 3, 2, 2, 2, 178, 1897, 3, 2, 2, 2, 180, 1899, 3, 2, 2, 2, 182,
	1906, 3, 2, 2, 2, 184, 1958, 3, 2, 2, 2, 186, 1997, 3, 2, 2, 2, 188, 1999,
	3, 2, 2, 2, 190, 2024, 3, 2, 2, 2, 192, 2037, 3, 2, 2, 2, 194, 2041, 3,
	2, 2, 2, 196, 2065, 3, 2, 2, 2, 198, 2067, 3, 2, 2, 2, 200, 2109, 3, 2,
	2, 2, 202, 2111, 3, 2, 2, 2, 204, 2209, 3, 2, 2, 2, 206, 2214, 3, 2, 2,
	2, 208, 2216, 3, 2, 2, 2, 210, 2225, 3, 2, 2, 2, 212, 2234, 3, 2, 2, 2,
	214, 2263, 3, 2, 2, 2, 216, 2289, 3, 2, 2, 2, 218, 2301, 3, 2, 2, 2, 220,
	2303, 3, 2, 2, 2, 222, 2333, 3, 2, 2, 2, 224, 2352, 3, 2, 2, 2, 226, 2395,
	3, 2, 2, 2, 228, 2410, 3, 2, 2, 2, 230, 2429, 3, 2, 2, 2, 232, 2431, 3,
	2, 2, 2, 234, 2433, 3, 2, 2, 2, 236, 2435, 3, 2, 2, 2, 238, 2437, 3, 2,
	2, 2, 240, 2439, 3, 2, 2, 2, 242, 2441, 3, 2, 2, 2, 244, 2443, 3, 2, 2,
	2, 246, 2452, 3, 2, 2, 2, 248, 2469, 3, 2, 2, 2, 250, 2474, 3, 2, 2, 2,
	252, 2478, 3, 2, 2, 2, 254, 2491, 3, 2, 2, 2, 256, 2499, 3, 2, 2, 2, 258,
	2501, 3, 2, 2, 2, 260, 2503, 3, 2, 2, 2, 262, 2505, 3, 2, 2, 2, 264, 2507,
	3, 2, 2, 2, 266, 2509, 3, 2, 2, 2, 268, 2511, 3, 2, 2, 2, 270, 2513, 3,
	2, 2, 2, 272, 2515, 3, 2, 2, 2, 274, 2517, 3, 2, 2, 2, 276, 2526, 3, 2,
	2, 2, 278, 2569, 3, 2, 2, 2, 280, 2590, 3, 2, 2, 2, 282, 2592, 3, 2, 2,
	2, 284, 2594, 3, 2, 2, 2, 286, 2601, 3, 2, 2, 2, 288, 2615, 3, 2, 2, 2,
	290, 2635, 3, 2, 2, 2, 292, 2637, 3, 2, 2, 2, 294, 296, 7, 7, 2, 2, 295,
	294, 3, 2, 2, 2, 296, 299, 3, 2, 2, 2, 297, 295, 3, 2, 2, 2, 297, 298,
	3, 2, 2, 2, 298, 300, 3, 2, 2, 2, 299, 297, 3, 2, 2, 2, 300, 304, 5, 6,
	4, 2, 301, 303, 5, 292, 147, 2, 302, 301, 3, 2, 2, 2, 303, 306, 3, 2, 2,
	2, 304, 302, 3, 2, 2, 2, 304, 305, 3, 2, 2, 2, 305, 321, 3, 2, 2, 2, 306,
	304, 3, 2, 2, 2, 307, 318, 5, 20, 11, 2, 308, 310, 5, 292, 147, 2, 309,
	308, 3, 2, 2, 2, 310, 311, 3, 2, 2, 2, 311, 309, 3, 2, 2, 2, 311, 312,
	3, 2, 2, 2, 312, 314, 3, 2, 2, 2, 313, 315, 5, 20, 11, 2, 314, 313, 3,
	2, 2, 2, 314, 315, 3, 2, 2, 2, 315, 317, 3, 2, 2, 2, 316, 309, 3, 2, 2,
	2, 317, 320, 3, 2, 2, 2, 318, 316, 3, 2, 2, 2, 318, 319, 3, 2, 2, 2, 319,
	322, 3, 2, 2, 2, 320, 318, 3, 2, 2, 2, 321, 307, 3, 2, 2, 2, 321, 322,
	3, 2, 2, 2, 322, 323, 3, 2, 2, 2, 323, 324, 7, 2, 2, 3, 324, 3, 3, 2, 2,
	2, 325, 327, 7, 7, 2, 2, 326, 325, 3, 2, 2, 2, 327, 330, 3, 2, 2, 2, 328,
	326, 3, 2, 2, 2, 328, 329, 3, 2, 2, 2, 329, 331, 3, 2, 2, 2, 330, 328,
	3, 2, 2, 2, 331, 335, 5, 6, 4, 2, 332, 334, 5, 292, 147, 2, 333, 332, 3,
	2, 2, 2, 334, 337, 3, 2, 2, 2, 335, 333, 3, 2, 2, 2, 335, 336, 3, 2, 2,
	2, 336, 352, 3, 2, 2, 2, 337, 335, 3, 2, 2, 2, 338, 349, 5, 118, 60, 2,
	339, 341, 5, 292, 147, 2, 340, 339, 3, 2, 2, 2, 341, 342, 3, 2, 2, 2, 342,
	340, 3, 2, 2, 2, 342, 343, 3, 2, 2, 2, 343, 345, 3, 2, 2, 2, 344, 346,
	5, 118, 60, 2, 345, 344, 3, 2, 2, 2, 345, 346, 3, 2, 2, 2, 346, 348, 3,
	2, 2, 2, 347, 340, 3, 2, 2, 2, 348, 351, 3, 2, 2, 2, 349, 347, 3, 2, 2,
	2, 349, 350, 3, 2, 2, 2, 350, 353, 3, 2, 2, 2, 351, 349, 3, 2, 2, 2, 352,
	338, 3, 2, 2, 2, 352, 353, 3, 2, 2, 2, 353, 354, 3, 2, 2, 2, 354, 355,
	7, 2, 2, 3, 355, 5, 3, 2, 2, 2, 356, 358, 5, 8, 5, 2, 357, 356, 3, 2, 2,
	2, 357, 358, 3, 2, 2, 2, 358, 359, 3, 2, 2, 2, 359, 360, 5, 12, 7, 2, 360,
	361, 5, 14, 8, 2, 361, 7, 3, 2, 2, 2, 362, 364, 5, 10, 6, 2, 363, 362,
	3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 363, 3, 2, 2, 2, 365, 366, 3, 2,
	2, 2, 366, 9, 3, 2, 2, 2, 367, 368, 7, 58, 2, 2, 368, 378, 7, 27, 2, 2,
	369, 371, 7, 13, 2, 2, 370, 372, 5, 284, 143, 2, 371, 370, 3, 2, 2, 2,
	372, 373, 3, 2, 2, 2, 373, 371, 3, 2, 2, 2, 373, 374, 3, 2, 2, 2, 374,
	375, 3, 2, 2, 2, 375, 376, 7, 14, 2, 2, 376, 379, 3, 2, 2, 2, 377, 379,
	5, 284, 143, 2, 378, 369, 3, 2, 2, 2, 378, 377, 3, 2, 2, 2, 379, 381, 3,
	2, 2, 2, 380, 382, 5, 290, 146, 2, 381, 380, 3, 2, 2, 2, 381, 382, 3, 2,
	2, 2, 382, 384, 3, 2, 2, 2, 383, 367, 3, 2, 2, 2, 384, 385, 3, 2, 2, 2,
	385, 383, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 11, 3, 2, 2, 2, 387, 389,
	5, 252, 127, 2, 388, 387, 3, 2, 2, 2, 388, 389, 3, 2, 2, 2, 389, 390, 3,
	2, 2, 2, 390, 391, 7, 59, 2, 2, 391, 393, 5, 286, 144, 2, 392, 394, 5,
	290, 146, 2, 393, 392, 3, 2, 2, 2, 393, 394, 3, 2, 2, 2, 394, 396, 3, 2,
	2, 2, 395, 388, 3, 2, 2, 2, 395, 396, 3, 2, 2, 2, 396, 13, 3, 2, 2, 2,
	397, 399, 5, 16, 9, 2, 398, 397, 3, 2, 2, 2, 399, 402, 3, 2, 2, 2, 400,
	398, 3, 2, 2, 2, 400, 401, 3, 2, 2, 2, 401, 15, 3, 2, 2, 2, 402, 400, 3,
	2, 2, 2, 403, 404, 7, 60, 2, 2, 404, 408, 5, 286, 144, 2, 405, 406, 7,
	9, 2, 2, 406, 409, 7, 17, 2, 2, 407, 409, 5, 18, 10, 2, 408, 405, 3, 2,
	2, 2, 408, 407, 3, 2, 2, 2, 408, 409, 3, 2, 2, 2, 409, 411, 3, 2, 2, 2,
	410, 412, 5, 290, 146, 2, 411, 410, 3, 2, 2, 2, 411, 412, 3, 2, 2, 2, 412,
	17, 3, 2, 2, 2, 413, 414, 7, 89, 2, 2, 414, 415, 5, 288, 145, 2, 415, 19,
	3, 2, 2, 2, 416, 422, 5, 22, 12, 2, 417, 422, 5, 64, 33, 2, 418, 422, 5,
	54, 28, 2, 419, 422, 5, 68, 35, 2, 420, 422, 5, 78, 40, 2, 421, 416, 3,
	2, 2, 2, 421, 417, 3, 2, 2, 2, 421, 418, 3, 2, 2, 2, 421, 419, 3, 2, 2,
	2, 421, 420, 3, 2, 2, 2, 422, 21, 3, 2, 2, 2, 423, 425, 5, 252, 127, 2,
	424, 423, 3, 2, 2, 2, 424, 425, 3, 2, 2, 2, 425, 426, 3, 2, 2, 2, 426,
	430, 9, 2, 2, 2, 427, 429, 7, 7, 2, 2, 428, 427, 3, 2, 2, 2, 429, 432,
	3, 2, 2, 2, 430, 428, 3, 2, 2, 2, 430, 431, 3, 2, 2, 2, 431, 433, 3, 2,
	2, 2, 432, 430, 3, 2, 2, 2, 433, 441, 5, 288, 145, 2, 434, 436, 7, 7, 2,
	2, 435, 434, 3, 2, 2, 2, 436, 439, 3, 2, 2, 2, 437, 435, 3, 2, 2, 2, 437,
	438, 3, 2, 2, 2, 438, 440, 3, 2, 2, 2, 439, 437, 3, 2, 2, 2, 440, 442,
	5, 80, 41, 2, 441, 437, 3, 2, 2, 2, 441, 442, 3, 2, 2, 2, 442, 450, 3,
	2, 2, 2, 443, 445, 7, 7, 2, 2, 444, 443, 3, 2, 2, 2, 445, 448, 3, 2, 2,
	2, 446, 444, 3, 2, 2, 2, 446, 447, 3, 2, 2, 2, 447, 449, 3, 2, 2, 2, 448,
	446, 3, 2, 2, 2, 449, 451, 5, 24, 13, 2, 450, 446, 3, 2, 2, 2, 450, 451,
	3, 2, 2, 2, 451, 466, 3, 2, 2, 2, 452, 454, 7, 7, 2, 2, 453, 452, 3, 2,
	2, 2, 454, 457, 3, 2, 2, 2, 455, 453, 3, 2, 2, 2, 455, 456, 3, 2, 2, 2,
	456, 458, 3, 2, 2, 2, 457, 455, 3, 2, 2, 2, 458, 462, 7, 27, 2, 2, 459,
	461, 7, 7, 2, 2, 460, 459, 3, 2, 2, 2, 461, 464, 3, 2, 2, 2, 462, 460,
	3, 2, 2, 2, 462, 463, 3, 2, 2, 2, 463, 465, 3, 2, 2, 2, 464, 462, 3, 2,
	2, 2, 465, 467, 5, 30, 16, 2, 466, 455, 3, 2, 2, 2, 466, 467, 3, 2, 2,
	2, 467, 475, 3, 2, 2, 2, 468, 470, 7, 7, 2, 2, 469, 468, 3, 2, 2, 2, 470,
	473, 3, 2, 2, 2, 471, 469, 3, 2, 2, 2, 471, 472, 3, 2, 2, 2, 472, 474,
	3, 2, 2, 2, 473, 471, 3, 2, 2, 2, 474, 476, 5, 104, 53, 2, 475, 471, 3,
	2, 2, 2, 475, 476, 3, 2, 2, 2, 476, 491, 3, 2, 2, 2, 477, 479, 7, 7, 2,
	2, 478, 477, 3, 2, 2, 2, 479, 482, 3, 2, 2, 2, 480, 478, 3, 2, 2, 2, 480,
	481, 3, 2, 2, 2, 481, 483, 3, 2, 2, 2, 482, 480, 3, 2, 2, 2, 483, 492,
	5, 38, 20, 2, 484, 486, 7, 7, 2, 2, 485, 484, 3, 2, 2, 2, 486, 489, 3,
	2, 2, 2, 487, 485, 3, 2, 2, 2, 487, 488, 3, 2, 2, 2, 488, 490, 3, 2, 2,
	2, 489, 487, 3, 2, 2, 2, 490, 492, 5, 48, 25, 2, 491, 480, 3, 2, 2, 2,
	491, 487, 3, 2, 2, 2, 491, 492, 3, 2, 2, 2, 492, 23, 3, 2, 2, 2, 493, 495,
	5, 252, 127, 2, 494, 493, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 503, 3,
	2, 2, 2, 496, 500, 7, 68, 2, 2, 497, 499, 7, 7, 2, 2, 498, 497, 3, 2, 2,
	2, 499, 502, 3, 2, 2, 2, 500, 498, 3, 2, 2, 2, 500, 501, 3, 2, 2, 2, 501,
	504, 3, 2, 2, 2, 502, 500, 3, 2, 2, 2, 503, 496, 3, 2, 2, 2, 503, 504,
	3, 2, 2, 2, 504, 505, 3, 2, 2, 2, 505, 506, 5, 26, 14, 2, 506, 25, 3, 2,
	2, 2, 507, 516, 7, 11, 2, 2, 508, 513, 5, 28, 15, 2, 509, 510, 7, 10, 2,
	2, 510, 512, 5, 28, 15, 2, 511, 509, 3, 2, 2, 2, 512, 515, 3, 2, 2, 2,
	513, 511, 3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 514, 517, 3, 2, 2, 2, 515,
	513, 3, 2, 2, 2, 516, 508, 3, 2, 2, 2, 516, 517, 3, 2, 2, 2, 517, 518,
	3, 2, 2, 2, 518, 519, 7, 12, 2, 2, 519, 27, 3, 2, 2, 2, 520, 522, 5, 252,
	127, 2, 521, 520, 3, 2, 2, 2, 521, 522, 3, 2, 2, 2, 522, 524, 3, 2, 2,
	2, 523, 525, 9, 3, 2, 2, 524, 523, 3, 2, 2, 2, 524, 525, 3, 2, 2, 2, 525,
	526, 3, 2, 2, 2, 526, 527, 5, 288, 145, 2, 527, 528, 7, 27, 2, 2, 528,
	531, 5, 84, 43, 2, 529, 530, 7, 29, 2, 2, 530, 532, 5, 118, 60, 2, 531,
	529, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 29, 3, 2, 2, 2, 533, 535, 5,
	276, 139, 2, 534, 533, 3, 2, 2, 2, 535, 538, 3, 2, 2, 2, 536, 534, 3, 2,
	2, 2, 536, 537, 3, 2, 2, 2, 537, 539, 3, 2, 2, 2, 538, 536, 3, 2, 2, 2,
	539, 556, 5, 32, 17, 2, 540, 542, 7, 7, 2, 2, 541, 540, 3, 2, 2, 2, 542,
	545, 3, 2, 2, 2, 543, 541, 3, 2, 2, 2, 543, 544, 3, 2, 2, 2, 544, 546,
	3, 2, 2, 2, 545, 543, 3, 2, 2, 2, 546, 550, 7, 10, 2, 2, 547, 549, 7, 7,
	2, 2, 548, 547, 3, 2, 2, 2, 549, 552, 3, 2, 2, 2, 550, 548, 3, 2, 2, 2,
	550, 551, 3, 2, 2, 2, 551, 553, 3, 2, 2, 2, 552, 550, 3, 2, 2, 2, 553,
	555, 5, 32, 17, 2, 554, 543, 3, 2, 2, 2, 555, 558, 3, 2, 2, 2, 556, 554,
	3, 2, 2, 2, 556, 557, 3, 2, 2, 2, 557, 31, 3, 2, 2, 2, 558, 556, 3, 2,
	2, 2, 559, 563, 5, 34, 18, 2, 560, 563, 5, 98, 50, 2, 561, 563, 5, 36,
	19, 2, 562, 559, 3, 2, 2, 2, 562, 560, 3, 2, 2, 2, 562, 561, 3, 2, 2, 2,
	563, 33, 3, 2, 2, 2, 564, 565, 5, 98, 50, 2, 565, 566, 5, 150, 76, 2, 566,
	35, 3, 2, 2, 2, 567, 571, 5, 98, 50, 2, 568, 570, 7, 7, 2, 2, 569, 568,
	3, 2, 2, 2, 570, 573, 3, 2, 2, 2, 571, 569, 3, 2, 2, 2, 571, 572, 3, 2,
	2, 2, 572, 574, 3, 2, 2, 2, 573, 571, 3, 2, 2, 2, 574, 578, 7, 69, 2, 2,
	575, 577, 7, 7, 2, 2, 576, 575, 3, 2, 2, 2, 577, 580, 3, 2, 2, 2, 578,
	576, 3, 2, 2, 2, 578, 579, 3, 2, 2, 2, 579, 581, 3, 2, 2, 2, 580, 578,
	3, 2, 2, 2, 581, 582, 5, 118, 60, 2, 582, 37, 3, 2, 2, 2, 583, 587, 7,
	15, 2, 2, 584, 586, 7, 7, 2, 2, 585, 584, 3, 2, 2, 2, 586, 589, 3, 2, 2,
	2, 587, 585, 3, 2, 2, 2, 587, 588, 3, 2, 2, 2, 588, 593, 3, 2, 2, 2, 589,
	587, 3, 2, 2, 2, 590, 592, 5, 40, 21, 2, 591, 590, 3, 2, 2, 2, 592, 595,
	3, 2, 2, 2, 593, 591, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 599, 3, 2,
	2, 2, 595, 593, 3, 2, 2, 2, 596, 598, 7, 7, 2, 2, 597, 596, 3, 2, 2, 2,
	598, 601, 3, 2, 2, 2, 599, 597, 3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600,
	602, 3, 2, 2, 2, 601, 599, 3, 2, 2, 2, 602, 603, 7, 16, 2, 2, 603, 39,
	3, 2, 2, 2, 604, 613, 5, 22, 12, 2, 605, 613, 5, 54, 28, 2, 606, 613, 5,
	64, 33, 2, 607, 613, 5, 66, 34, 2, 608, 613, 5, 68, 35, 2, 609, 613, 5,
	42, 22, 2, 610, 613, 5, 44, 23, 2, 611, 613, 5, 78, 40, 2, 612, 604, 3,
	2, 2, 2, 612, 605, 3, 2, 2, 2, 612, 606, 3, 2, 2, 2, 612, 607, 3, 2, 2,
	2, 612, 608, 3, 2, 2, 2, 612, 609, 3, 2, 2, 2, 612, 610, 3, 2, 2, 2, 612,
	611, 3, 2, 2, 2, 613, 615, 3, 2, 2, 2, 614, 616, 5, 292, 147, 2, 615, 614,
	3, 2, 2, 2, 616, 617, 3, 2, 2, 2, 617, 615, 3, 2, 2, 2, 617, 618, 3, 2,
	2, 2, 618, 41, 3, 2, 2, 2, 619, 623, 7, 71, 2, 2, 620, 622, 7, 7, 2, 2,
	621, 620, 3, 2, 2, 2, 622, 625, 3, 2, 2, 2, 623, 621, 3, 2, 2, 2, 623,
	624, 3, 2, 2, 2, 624, 626, 3, 2, 2, 2, 625, 623, 3, 2, 2, 2, 626, 627,
	5, 108, 55, 2, 627, 43, 3, 2, 2, 2, 628, 630, 5, 252, 127, 2, 629, 628,
	3, 2, 2, 2, 629, 630, 3, 2, 2, 2, 630, 631, 3, 2, 2, 2, 631, 635, 7, 68,
	2, 2, 632, 634, 7, 7, 2, 2, 633, 632, 3, 2, 2, 2, 634, 637, 3, 2, 2, 2,
	635, 633, 3, 2, 2, 2, 635, 636, 3, 2, 2, 2, 636, 638, 3, 2, 2, 2, 637,
	635, 3, 2, 2, 2, 638, 653, 5, 56, 29, 2, 639, 641, 7, 7, 2, 2, 640, 639,
	3, 2, 2, 2, 641, 644, 3, 2, 2, 2, 642, 640, 3, 2, 2, 2, 642, 643, 3, 2,
	2, 2, 643, 645, 3, 2, 2, 2, 644, 642, 3, 2, 2, 2, 645, 649, 7, 27, 2, 2,
	646, 648, 7, 7, 2, 2, 647, 646, 3, 2, 2, 2, 648, 651, 3, 2, 2, 2, 649,
	647, 3, 2, 2, 2, 649, 650, 3, 2, 2, 2, 650, 652, 3, 2, 2, 2, 651, 649,
	3, 2, 2, 2, 652, 654, 5, 46, 24, 2, 653, 642, 3, 2, 2, 2, 653, 654, 3,
	2, 2, 2, 654, 658, 3, 2, 2, 2, 655, 657, 7, 7, 2, 2, 656, 655, 3, 2, 2,
	2, 657, 660, 3, 2, 2, 2, 658, 656, 3, 2, 2, 2, 658, 659, 3, 2, 2, 2, 659,
	662, 3, 2, 2, 2, 660, 658, 3, 2, 2, 2, 661, 663, 5, 108, 55, 2, 662, 661,
	3, 2, 2, 2, 662, 663, 3, 2, 2, 2, 663, 45, 3, 2, 2, 2, 664, 668, 7, 72,
	2, 2, 665, 667, 7, 7, 2, 2, 666, 665, 3, 2, 2, 2, 667, 670, 3, 2, 2, 2,
	668, 666, 3, 2, 2, 2, 668, 669, 3, 2, 2, 2, 669, 671, 3, 2, 2, 2, 670,
	668, 3, 2, 2, 2, 671, 681, 5, 156, 79, 2, 672, 676, 7, 73, 2, 2, 673, 675,
	7, 7, 2, 2, 674, 673, 3, 2, 2, 2, 675, 678, 3, 2, 2, 2, 676, 674, 3, 2,
	2, 2, 676, 677, 3, 2, 2, 2, 677, 679, 3, 2, 2, 2, 678, 676, 3, 2, 2, 2,
	679, 681, 5, 156, 79, 2, 680, 664, 3, 2, 2, 2, 680, 672, 3, 2, 2, 2, 681,
	47, 3, 2, 2, 2, 682, 686, 7, 15, 2, 2, 683, 685, 7, 7, 2, 2, 684, 683,
	3, 2, 2, 2, 685, 688, 3, 2, 2, 2, 686, 684, 3, 2, 2, 2, 686, 687, 3, 2,
	2, 2, 687, 690, 3, 2, 2, 2, 688, 686, 3, 2, 2, 2, 689, 691, 5, 50, 26,
	2, 690, 689, 3, 2, 2, 2, 690, 691, 3, 2, 2, 2, 691, 711, 3, 2, 2, 2, 692,
	694, 7, 7, 2, 2, 693, 692, 3, 2, 2, 2, 694, 697, 3, 2, 2, 2, 695, 693,
	3, 2, 2, 2, 695, 696, 3, 2, 2, 2, 696, 698, 3, 2, 2, 2, 697, 695, 3, 2,
	2, 2, 698, 702, 7, 28, 2, 2, 699, 701, 7, 7, 2, 2, 700, 699, 3, 2, 2, 2,
	701, 704, 3, 2, 2, 2, 702, 700, 3, 2, 2, 2, 702, 703, 3, 2, 2, 2, 703,
	708, 3, 2, 2, 2, 704, 702, 3, 2, 2, 2, 705, 707, 5, 40, 21, 2, 706, 705,
	3, 2, 2, 2, 707, 710, 3, 2, 2, 2, 708, 706, 3, 2, 2, 2, 708, 709, 3, 2,
	2, 2, 709, 712, 3, 2, 2, 2, 710, 708, 3, 2, 2, 2, 711, 695, 3, 2, 2, 2,
	711, 712, 3, 2, 2, 2, 712, 716, 3, 2, 2, 2, 713, 715, 7, 7, 2, 2, 714,
	713, 3, 2, 2, 2, 715, 718, 3, 2, 2, 2, 716, 714, 3, 2, 2, 2, 716, 717,
	3, 2, 2, 2, 717, 719, 3, 2, 2, 2, 718, 716, 3, 2, 2, 2, 719, 720, 7, 16,
	2, 2, 720, 49, 3, 2, 2, 2, 721, 725, 5, 52, 27, 2, 722, 724, 7, 7, 2, 2,
	723, 722, 3, 2, 2, 2, 724, 727, 3, 2, 2, 2, 725, 723, 3, 2, 2, 2, 725,
	726, 3, 2, 2, 2, 726, 729, 3, 2, 2, 2, 727, 725, 3, 2, 2, 2, 728, 721,
	3, 2, 2, 2, 729, 730, 3, 2, 2, 2, 730, 728, 3, 2, 2, 2, 730, 731, 3, 2,
	2, 2, 731, 733, 3, 2, 2, 2, 732, 734, 7, 28, 2, 2, 733, 732, 3, 2, 2, 2,
	733, 734, 3, 2, 2, 2, 734, 51, 3, 2, 2, 2, 735, 743, 5, 288, 145, 2, 736,
	738, 7, 7, 2, 2, 737, 736, 3, 2, 2, 2, 738, 741, 3, 2, 2, 2, 739, 737,
	3, 2, 2, 2, 739, 740, 3, 2, 2, 2, 740, 742, 3, 2, 2, 2, 741, 739, 3, 2,
	2, 2, 742, 744, 5, 156, 79, 2, 743, 739, 3, 2, 2, 2, 743, 744, 3, 2, 2,
	2, 744, 752, 3, 2, 2, 2, 745, 747, 7, 7, 2, 2, 746, 745, 3, 2, 2, 2, 747,
	750, 3, 2, 2, 2, 748, 746, 3, 2, 2, 2, 748, 749, 3, 2, 2, 2, 749, 751,
	3, 2, 2, 2, 750, 748, 3, 2, 2, 2, 751, 753, 5, 38, 20, 2, 752, 748, 3,
	2, 2, 2, 752, 753, 3, 2, 2, 2, 753, 761, 3, 2, 2, 2, 754, 756, 7, 7, 2,
	2, 755, 754, 3, 2, 2, 2, 756, 759, 3, 2, 2, 2, 757, 755, 3, 2, 2, 2, 757,
	758, 3, 2, 2, 2, 758, 760, 3, 2, 2, 2, 759, 757, 3, 2, 2, 2, 760, 762,
	7, 10, 2, 2, 761, 757, 3, 2, 2, 2, 761, 762, 3, 2, 2, 2, 762, 53, 3, 2,
	2, 2, 763, 765, 5, 252, 127, 2, 764, 763, 3, 2, 2, 2, 764, 765, 3, 2, 2,
	2, 765, 766, 3, 2, 2, 2, 766, 782, 7, 63, 2, 2, 767, 769, 7, 7, 2, 2, 768,
	767, 3, 2, 2, 2, 769, 772, 3, 2, 2, 2, 770, 768, 3, 2, 2, 2, 770, 771,
	3, 2, 2, 2, 771, 773, 3, 2, 2, 2, 772, 770, 3, 2, 2, 2, 773, 777, 5, 84,
	43, 2, 774, 776, 7, 7, 2, 2, 775, 774, 3, 2, 2, 2, 776, 779, 3, 2, 2, 2,
	777, 775, 3, 2, 2, 2, 777, 778, 3, 2, 2, 2, 778, 780, 3, 2, 2, 2, 779,
	777, 3, 2, 2, 2, 780, 781, 7, 9, 2, 2, 781, 783, 3, 2, 2, 2, 782, 770,
	3, 2, 2, 2, 782, 783, 3, 2, 2, 2, 783, 791, 3, 2, 2, 2, 784, 786, 7, 7,
	2, 2, 785, 784, 3, 2, 2, 2, 786, 789, 3, 2, 2, 2, 787, 785, 3, 2, 2, 2,
	787, 788, 3, 2, 2, 2, 788, 790, 3, 2, 2, 2, 789, 787, 3, 2, 2, 2, 790,
	792, 5, 80, 41, 2, 791, 787, 3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792, 800,
	3, 2, 2, 2, 793, 795, 7, 7, 2, 2, 794, 793, 3, 2, 2, 2, 795, 798, 3, 2,
	2, 2, 796, 794, 3, 2, 2, 2, 796, 797, 3, 2, 2, 2, 797, 799, 3, 2, 2, 2,
	798, 796, 3, 2, 2, 2, 799, 801, 5, 286, 144, 2, 800, 796, 3, 2, 2, 2, 800,
	801, 3, 2, 2, 2, 801, 805, 3, 2, 2, 2, 802, 804, 7, 7, 2, 2, 803, 802,
	3, 2, 2, 2, 804, 807, 3, 2, 2, 2, 805, 803, 3, 2, 2, 2, 805, 806, 3, 2,
	2, 2, 806, 808, 3, 2, 2, 2, 807, 805, 3, 2, 2, 2, 808, 823, 5, 56, 29,
	2, 809, 811, 7, 7, 2, 2, 810, 809, 3, 2, 2, 2, 811, 814, 3, 2, 2, 2, 812,
	810, 3, 2, 2, 2, 812, 813, 3, 2, 2, 2, 813, 815, 3, 2, 2, 2, 814, 812,
	3, 2, 2, 2, 815, 819, 7, 27, 2, 2, 816, 818, 7, 7, 2, 2, 817, 816, 3, 2,
	2, 2, 818, 821, 3, 2, 2, 2, 819, 817, 3, 2, 2, 2, 819, 820, 3, 2, 2, 2,
	820, 822, 3, 2, 2, 2, 821, 819, 3, 2, 2, 2, 822, 824, 5, 84, 43, 2, 823,
	812, 3, 2, 2, 2, 823, 824, 3, 2, 2, 2, 824, 832, 3, 2, 2, 2, 825, 827,
	7, 7, 2, 2, 826, 825, 3, 2, 2, 2, 827, 830, 3, 2, 2, 2, 828, 826, 3, 2,
	2, 2, 828, 829, 3, 2, 2, 2, 829, 831, 3, 2, 2, 2, 830, 828, 3, 2, 2, 2,
	831, 833, 5, 104, 53, 2, 832, 828, 3, 2, 2, 2, 832, 833, 3, 2, 2, 2, 833,
	841, 3, 2, 2, 2, 834, 836, 7, 7, 2, 2, 835, 834, 3, 2, 2, 2, 836, 839,
	3, 2, 2, 2, 837, 835, 3, 2, 2, 2, 837, 838, 3, 2, 2, 2, 838, 840, 3, 2,
	2, 2, 839, 837, 3, 2, 2, 2, 840, 842, 5, 62, 32, 2, 841, 837, 3, 2, 2,
	2, 841, 842, 3, 2, 2, 2, 842, 55, 3, 2, 2, 2, 843, 852, 7, 11, 2, 2, 844,
	849, 5, 58, 30, 2, 845, 846, 7, 10, 2, 2, 846, 848, 5, 58, 30, 2, 847,
	845, 3, 2, 2, 2, 848, 851, 3, 2, 2, 2, 849, 847, 3, 2, 2, 2, 849, 850,
	3, 2, 2, 2, 850, 853, 3, 2, 2, 2, 851, 849, 3, 2, 2, 2, 852, 844, 3, 2,
	2, 2, 852, 853, 3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854, 855, 7, 12, 2, 2,
	855, 57, 3, 2, 2, 2, 856, 858, 5, 252, 127, 2, 857, 856, 3, 2, 2, 2, 857,
	858, 3, 2, 2, 2, 858, 859, 3, 2, 2, 2, 859, 862, 5, 60, 31, 2, 860, 861,
	7, 29, 2, 2, 861, 863, 5, 118, 60, 2, 862, 860, 3, 2, 2, 2, 862, 863, 3,
	2, 2, 2, 863, 59, 3, 2, 2, 2, 864, 865, 5, 288, 145, 2, 865, 866, 7, 27,
	2, 2, 866, 867, 5, 84, 43, 2, 867, 61, 3, 2, 2, 2, 868, 878, 5, 108, 55,
	2, 869, 873, 7, 29, 2, 2, 870, 872, 7, 7, 2, 2, 871, 870, 3, 2, 2, 2, 872,
	875, 3, 2, 2, 2, 873, 871, 3, 2, 2, 2, 873, 874, 3, 2, 2, 2, 874, 876,
	3, 2, 2, 2, 875, 873, 3, 2, 2, 2, 876, 878, 5, 118, 60, 2, 877, 868, 3,
	2, 2, 2, 877, 869, 3, 2, 2, 2, 878, 63, 3, 2, 2, 2, 879, 881, 5, 252, 127,
	2, 880, 879, 3, 2, 2, 2, 880, 881, 3, 2, 2, 2, 881, 882, 3, 2, 2, 2, 882,
	886, 7, 64, 2, 2, 883, 885, 7, 7, 2, 2, 884, 883, 3, 2, 2, 2, 885, 888,
	3, 2, 2, 2, 886, 884, 3, 2, 2, 2, 886, 887, 3, 2, 2, 2, 887, 889, 3, 2,
	2, 2, 888, 886, 3, 2, 2, 2, 889, 897, 5, 288, 145, 2, 890, 892, 7, 7, 2,
	2, 891, 890, 3, 2, 2, 2, 892, 895, 3, 2, 2, 2, 893, 891, 3, 2, 2, 2, 893,
	894, 3, 2, 2, 2, 894, 896, 3, 2, 2, 2, 895, 893, 3, 2, 2, 2, 896, 898,
	5, 24, 13, 2, 897, 893, 3, 2, 2, 2, 897, 898, 3, 2, 2, 2, 898, 913, 3,
	2, 2, 2, 899, 901, 7, 7, 2, 2, 900, 899, 3, 2, 2, 2, 901, 904, 3, 2, 2,
	2, 902, 900, 3, 2, 2, 2, 902, 903, 3, 2, 2, 2, 903, 905, 3, 2, 2, 2, 904,
	902, 3, 2, 2, 2, 905, 909, 7, 27, 2, 2, 906, 908, 7, 7, 2, 2, 907, 906,
	3, 2, 2, 2, 908, 911, 3, 2, 2, 2, 909, 907, 3, 2, 2, 2, 909, 910, 3, 2,
	2, 2, 910, 912, 3, 2, 2, 2, 911, 909, 3, 2, 2, 2, 912, 914, 5, 30, 16,
	2, 913, 902, 3, 2, 2, 2, 913, 914, 3, 2, 2, 2, 914, 922, 3, 2, 2, 2, 915,
	917, 7, 7, 2, 2, 916, 915, 3, 2, 2, 2, 917, 920, 3, 2, 2, 2, 918, 916,
	3, 2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 921, 3, 2, 2, 2, 920, 918, 3, 2,
	2, 2, 921, 923, 5, 38, 20, 2, 922, 918, 3, 2, 2, 2, 922, 923, 3, 2, 2,
	2, 923, 65, 3, 2, 2, 2, 924, 926, 5, 252, 127, 2, 925, 924, 3, 2, 2, 2,
	925, 926, 3, 2, 2, 2, 926, 927, 3, 2, 2, 2, 927, 931, 7, 70, 2, 2, 928,
	930, 7, 7, 2, 2, 929, 928, 3, 2, 2, 2, 930, 933, 3, 2, 2, 2, 931, 929,
	3, 2, 2, 2, 931, 932, 3, 2, 2, 2, 932, 935, 3, 2, 2, 2, 933, 931, 3, 2,
	2, 2, 934, 936, 5, 252, 127, 2, 935, 934, 3, 2, 2, 2, 935, 936, 3, 2, 2,
	2, 936, 937, 3, 2, 2, 2, 937, 945, 7, 64, 2, 2, 938, 940, 7, 7, 2, 2, 939,
	938, 3, 2, 2, 2, 940, 943, 3, 2, 2, 2, 941, 939, 3, 2, 2, 2, 941, 942,
	3, 2, 2, 2, 942, 944, 3, 2, 2, 2, 943, 941, 3, 2, 2, 2, 944, 946, 5, 288,
	145, 2, 945, 941, 3, 2, 2, 2, 945, 946, 3, 2, 2, 2, 946, 961, 3, 2, 2,
	2, 947, 949, 7, 7, 2, 2, 948, 947, 3, 2, 2, 2, 949, 952, 3, 2, 2, 2, 950,
	948, 3, 2, 2, 2, 950, 951, 3, 2, 2, 2, 951, 953, 3, 2, 2, 2, 952, 950,
	3, 2, 2, 2, 953, 957, 7, 27, 2, 2, 954, 956, 7, 7, 2, 2, 955, 954, 3, 2,
	2, 2, 956, 959, 3, 2, 2, 2, 957, 955, 3, 2, 2, 2, 957, 958, 3, 2, 2, 2,
	958, 960, 3, 2, 2, 2, 959, 957, 3, 2, 2, 2, 960, 962, 5, 30, 16, 2, 961,
	950, 3, 2, 2, 2, 961, 962, 3, 2, 2, 2, 962, 970, 3, 2, 2, 2, 963, 965,
	7, 7, 2, 2, 964, 963, 3, 2, 2, 2, 965, 968, 3, 2, 2, 2, 966, 964, 3, 2,
	2, 2, 966, 967, 3, 2, 2, 2, 967, 969, 3, 2, 2, 2, 968, 966, 3, 2, 2, 2,
	969, 971, 5, 38, 20, 2, 970, 966, 3, 2, 2, 2, 970, 971, 3, 2, 2, 2, 971,
	67, 3, 2, 2, 2, 972, 974, 5, 252, 127, 2, 973, 972, 3, 2, 2, 2, 973, 974,
	3, 2, 2, 2, 974, 975, 3, 2, 2, 2, 975, 983, 9, 3, 2, 2, 976, 978, 7, 7,
	2, 2, 977, 976, 3, 2, 2, 2, 978, 981, 3, 2, 2, 2, 979, 977, 3, 2, 2, 2,
	979, 980, 3, 2, 2, 2, 980, 982, 3, 2, 2, 2, 981, 979, 3, 2, 2, 2, 982,
	984, 5, 80, 41, 2, 983, 979, 3, 2, 2, 2, 983, 984, 3, 2, 2, 2, 984, 1000,
	3, 2, 2, 2, 985, 987, 7, 7, 2, 2, 986, 985, 3, 2, 2, 2, 987, 990, 3, 2,
	2, 2, 988, 986, 3, 2, 2, 2, 988, 989, 3, 2, 2, 2, 989, 991, 3, 2, 2, 2,
	990, 988, 3, 2, 2, 2, 991, 995, 5, 84, 43, 2, 992, 994, 7, 7, 2, 2, 993,
	992, 3, 2, 2, 2, 994, 997, 3, 2, 2, 2, 995, 993, 3, 2, 2, 2, 995, 996,
	3, 2, 2, 2, 996, 998, 3, 2, 2, 2, 997, 995, 3, 2, 2, 2, 998, 999, 7, 9,
	2, 2, 999, 1001, 3, 2, 2, 2, 1000, 988, 3, 2, 2, 2, 1000, 1001, 3, 2, 2,
	2, 1001, 1005, 3, 2, 2, 2, 1002, 1004, 7, 7, 2, 2, 1003, 1002, 3, 2, 2,
	2, 1004, 1007, 3, 2, 2, 2, 1005, 1003, 3, 2, 2, 2, 1005, 1006, 3, 2, 2,
	2, 1006, 1010, 3, 2, 2, 2, 1007, 1005, 3, 2, 2, 2, 1008, 1011, 5, 70, 36,
	2, 1009, 1011, 5, 72, 37, 2, 1010, 1008, 3, 2, 2, 2, 1010, 1009, 3, 2,
	2, 2, 1011, 1019, 3, 2, 2, 2, 1012, 1014, 7, 7, 2, 2, 1013, 1012, 3, 2,
	2, 2, 1014, 1017, 3, 2, 2, 2, 1015, 1013, 3, 2, 2, 2, 1015, 1016, 3, 2,
	2, 2, 1016, 1018, 3, 2, 2, 2, 1017, 1015, 3, 2, 2, 2, 1018, 1020, 5, 104,
	53, 2, 1019, 1015, 3, 2, 2, 2, 1019, 1020, 3, 2, 2, 2, 1020, 1035, 3, 2,
	2, 2, 1021, 1023, 7, 7, 2, 2, 1022, 1021, 3, 2, 2, 2, 1023, 1026, 3, 2,
	2, 2, 1024, 1022, 3, 2, 2, 2, 1024, 1025, 3, 2, 2, 2, 1025, 1027, 3, 2,
	2, 2, 1026, 1024, 3, 2, 2, 2, 1027, 1031, 9, 4, 2, 2, 1028, 1030, 7, 7,
	2, 2, 1029, 1028, 3, 2, 2, 2, 1030, 1033, 3, 2, 2, 2, 1031, 1029, 3, 2,
	2, 2, 1031, 1032, 3, 2, 2, 2, 1032, 1034, 3, 2, 2, 2, 1033, 1031, 3, 2,
	2, 2, 1034, 1036, 5, 118, 60, 2, 1035, 1024, 3, 2, 2, 2, 1035, 1036, 3,
	2, 2, 2, 1036, 1049, 3, 2, 2, 2, 1037, 1041, 5, 74, 38, 2, 1038, 1039,
	5, 290, 146, 2, 1039, 1040, 5, 76, 39, 2, 1040, 1042, 3, 2, 2, 2, 1041,
	1038, 3, 2, 2, 2, 1041, 1042, 3, 2, 2, 2, 1042, 1050, 3, 2, 2, 2, 1043,
	1047, 5, 76, 39, 2, 1044, 1045, 5, 290, 146, 2, 1045, 1046, 5, 74, 38,
	2, 1046, 1048, 3, 2, 2, 2, 1047, 1044, 3, 2, 2, 2, 1047, 1048, 3, 2, 2,
	2, 1048, 1050, 3, 2, 2, 2, 1049, 1037, 3, 2, 2, 2, 1049, 1043, 3, 2, 2,
	2, 1049, 1050, 3, 2, 2, 2, 1050, 69, 3, 2, 2, 2, 1051, 1052, 7, 11, 2,
	2, 1052, 1057, 5, 72, 37, 2, 1053, 1054, 7, 10, 2, 2, 1054, 1056, 5, 72,
	37, 2, 1055, 1053, 3, 2, 2, 2, 1056, 1059, 3, 2, 2, 2, 1057, 1055, 3, 2,
	2, 2, 1057, 1058, 3, 2, 2, 2, 1058, 1060, 3, 2, 2, 2, 1059, 1057, 3, 2,
	2, 2, 1060, 1061, 7, 12, 2, 2, 1061, 71, 3, 2, 2, 2, 1062, 1065, 5, 288,
	145, 2, 1063, 1064, 7, 27, 2, 2, 1064, 1066, 5, 84, 43, 2, 1065, 1063,
	3, 2, 2, 2, 1065, 1066, 3, 2, 2, 2, 1066, 73, 3, 2, 2, 2, 1067, 1069, 5,
	252, 127, 2, 1068, 1067, 3, 2, 2, 2, 1068, 1069, 3, 2, 2, 2, 1069, 1070,
	3, 2, 2, 2, 1070, 1117, 7, 99, 2, 2, 1071, 1073, 5, 252, 127, 2, 1072,
	1071, 3, 2, 2, 2, 1072, 1073, 3, 2, 2, 2, 1073, 1074, 3, 2, 2, 2, 1074,
	1078, 7, 99, 2, 2, 1075, 1077, 7, 7, 2, 2, 1076, 1075, 3, 2, 2, 2, 1077,
	1080, 3, 2, 2, 2, 1078, 1076, 3, 2, 2, 2, 1078, 1079, 3, 2, 2, 2, 1079,
	1081, 3, 2, 2, 2, 1080, 1078, 3, 2, 2, 2, 1081, 1082, 7, 11, 2, 2, 1082,
	1097, 7, 12, 2, 2, 1083, 1085, 7, 7, 2, 2, 1084, 1083, 3, 2, 2, 2, 1085,
	1088, 3, 2, 2, 2, 1086, 1084, 3, 2, 2, 2, 1086, 1087, 3, 2, 2, 2, 1087,
	1089, 3, 2, 2, 2, 1088, 1086, 3, 2, 2, 2, 1089, 1093, 7, 27, 2, 2, 1090,
	1092, 7, 7, 2, 2, 1091, 1090, 3, 2, 2, 2, 1092, 1095, 3, 2, 2, 2, 1093,
	1091, 3, 2, 2, 2, 1093, 1094, 3, 2, 2, 2, 1094, 1096, 3, 2, 2, 2, 1095,
	1093, 3, 2, 2, 2, 1096, 1098, 5, 84, 43, 2, 1097, 1086, 3, 2, 2, 2, 1097,
	1098, 3, 2, 2, 2, 1098, 1102, 3, 2, 2, 2, 1099, 1101, 7, 7, 2, 2, 1100,
	1099, 3, 2, 2, 2, 1101, 1104, 3, 2, 2, 2, 1102, 1100, 3, 2, 2, 2, 1102,
	1103, 3, 2, 2, 2, 1103, 1114, 3, 2, 2, 2, 1104, 1102, 3, 2, 2, 2, 1105,
	1115, 5, 108, 55, 2, 1106, 1110, 7, 29, 2, 2, 1107, 1109, 7, 7, 2, 2, 1108,
	1107, 3, 2, 2, 2, 1109, 1112, 3, 2, 2, 2, 1110, 1108, 3, 2, 2, 2, 1110,
	1111, 3, 2, 2, 2, 1111, 1113, 3, 2, 2, 2, 1112, 1110, 3, 2, 2, 2, 1113,
	1115, 5, 118, 60, 2, 1114, 1105, 3, 2, 2, 2, 1114, 1106, 3, 2, 2, 2, 1115,
	1117, 3, 2, 2, 2, 1116, 1068, 3, 2, 2, 2, 1116, 1072, 3, 2, 2, 2, 1117,
	75, 3, 2, 2, 2, 1118, 1120, 5, 252, 127, 2, 1119, 1118, 3, 2, 2, 2, 1119,
	1120, 3, 2, 2, 2, 1120, 1121, 3, 2, 2, 2, 1121, 1154, 7, 100, 2, 2, 1122,
	1124, 5, 252, 127, 2, 1123, 1122, 3, 2, 2, 2, 1123, 1124, 3, 2, 2, 2, 1124,
	1125, 3, 2, 2, 2, 1125, 1129, 7, 100, 2, 2, 1126, 1128, 7, 7, 2, 2, 1127,
	1126, 3, 2, 2, 2, 1128, 1131, 3, 2, 2, 2, 1129, 1127, 3, 2, 2, 2, 1129,
	1130, 3, 2, 2, 2, 1130, 1132, 3, 2, 2, 2, 1131, 1129, 3, 2, 2, 2, 1132,
	1137, 7, 11, 2, 2, 1133, 1136, 5, 276, 139, 2, 1134, 1136, 5, 270, 136,
	2, 1135, 1133, 3, 2, 2, 2, 1135, 1134, 3, 2, 2, 2, 1136, 1139, 3, 2, 2,
	2, 1137, 1135, 3, 2, 2, 2, 1137, 1138, 3, 2, 2, 2, 1138, 1142, 3, 2, 2,
	2, 1139, 1137, 3, 2, 2, 2, 1140, 1143, 5, 288, 145, 2, 1141, 1143, 5, 60,
	31, 2, 1142, 1140, 3, 2, 2, 2, 1142, 1141, 3, 2, 2, 2, 1143, 1144, 3, 2,
	2, 2, 1144, 1148, 7, 12, 2, 2, 1145, 1147, 7, 7, 2, 2, 1146, 1145, 3, 2,
	2, 2, 1147, 1150, 3, 2, 2, 2, 1148, 1146, 3, 2, 2, 2, 1148, 1149, 3, 2,
	2, 2, 1149, 1151, 3, 2, 2, 2, 1150, 1148, 3, 2, 2, 2, 1151, 1152, 5, 62,
	32, 2, 1152, 1154, 3, 2, 2, 2, 1153, 1119, 3, 2, 2, 2, 1153, 1123, 3, 2,
	2, 2, 1154, 77, 3, 2, 2, 2, 1155, 1157, 5, 252, 127, 2, 1156, 1155, 3,
	2, 2, 2, 1156, 1157, 3, 2, 2, 2, 1157, 1158, 3, 2, 2, 2, 1158, 1162, 7,
	67, 2, 2, 1159, 1161, 7, 7, 2, 2, 1160, 1159, 3, 2, 2, 2, 1161, 1164, 3,
	2, 2, 2, 1162, 1160, 3, 2, 2, 2, 1162, 1163, 3, 2, 2, 2, 1163, 1165, 3,
	2, 2, 2, 1164, 1162, 3, 2, 2, 2, 1165, 1173, 5, 288, 145, 2, 1166, 1168,
	7, 7, 2, 2, 1167, 1166, 3, 2, 2, 2, 1168, 1171, 3, 2, 2, 2, 1169, 1167,
	3, 2, 2, 2, 1169, 1170, 3, 2, 2, 2, 1170, 1172, 3, 2, 2, 2, 1171, 1169,
	3, 2, 2, 2, 1172, 1174, 5, 80, 41, 2, 1173, 1169, 3, 2, 2, 2, 1173, 1174,
	3, 2, 2, 2, 1174, 1178, 3, 2, 2, 2, 1175, 1177, 7, 7, 2, 2, 1176, 1175,
	3, 2, 2, 2, 1177, 1180, 3, 2, 2, 2, 1178, 1176, 3, 2, 2, 2, 1178, 1179,
	3, 2, 2, 2, 1179, 1181, 3, 2, 2, 2, 1180, 1178, 3, 2, 2, 2, 1181, 1185,
	7, 29, 2, 2, 1182, 1184, 7, 7, 2, 2, 1183, 1182, 3, 2, 2, 2, 1184, 1187,
	3, 2, 2, 2, 1185, 1183, 3, 2, 2, 2, 1185, 1186, 3, 2, 2, 2, 1186, 1188,
	3, 2, 2, 2, 1187, 1185, 3, 2, 2, 2, 1188, 1189, 5, 84, 43, 2, 1189, 79,
	3, 2, 2, 2, 1190, 1194, 7, 45, 2, 2, 1191, 1193, 7, 7, 2, 2, 1192, 1191,
	3, 2, 2, 2, 1193, 1196, 3, 2, 2, 2, 1194, 1192, 3, 2, 2, 2, 1194, 1195,
	3, 2, 2, 2, 1195, 1197, 3, 2, 2, 2, 1196, 1194, 3, 2, 2, 2, 1197, 1214,
	5, 82, 42, 2, 1198, 1200, 7, 7, 2, 2, 1199, 1198, 3, 2, 2, 2, 1200, 1203,
	3, 2, 2, 2, 1201, 1199, 3, 2, 2, 2, 1201, 1202, 3, 2, 2, 2, 1202, 1204,
	3, 2, 2, 2, 1203, 1201, 3, 2, 2, 2, 1204, 1208, 7, 10, 2, 2, 1205, 1207,
	7, 7, 2, 2, 1206, 1205, 3, 2, 2, 2, 1207, 1210, 3, 2, 2, 2, 1208, 1206,
	3, 2, 2, 2, 1208, 1209, 3, 2, 2, 2, 1209, 1211, 3, 2, 2, 2, 1210, 1208,
	3, 2, 2, 2, 1211, 1213, 5, 82, 42, 2, 1212, 1201, 3, 2, 2, 2, 1213, 1216,
	3, 2, 2, 2, 1214, 1212, 3, 2, 2, 2, 1214, 1215, 3, 2, 2, 2, 1215, 1220,
	3, 2, 2, 2, 1216, 1214, 3, 2, 2, 2, 1217, 1219, 7, 7, 2, 2, 1218, 1217,
	3, 2, 2, 2, 1219, 1222, 3, 2, 2, 2, 1220, 1218, 3, 2, 2, 2, 1220, 1221,
	3, 2, 2, 2, 1221, 1223, 3, 2, 2, 2, 1222, 1220, 3, 2, 2, 2, 1223, 1224,
	7, 46, 2, 2, 1224, 81, 3, 2, 2, 2, 1225, 1227, 5, 252, 127, 2, 1226, 1225,
	3, 2, 2, 2, 1226, 1227, 3, 2, 2, 2, 1227, 1231, 3, 2, 2, 2, 1228, 1230,
	7, 7, 2, 2, 1229, 1228, 3, 2, 2, 2, 1230, 1233, 3, 2, 2, 2, 1231, 1229,
	3, 2, 2, 2, 1231, 1232, 3, 2, 2, 2, 1232, 1234, 3, 2, 2, 2, 1233, 1231,
	3, 2, 2, 2, 1234, 1249, 5, 288, 145, 2, 1235, 1237, 7, 7, 2, 2, 1236, 1235,
	3, 2, 2, 2, 1237, 1240, 3, 2, 2, 2, 1238, 1236, 3, 2, 2, 2, 1238, 1239,
	3, 2, 2, 2, 1239, 1241, 3, 2, 2, 2, 1240, 1238, 3, 2, 2, 2, 1241, 1245,
	7, 27, 2, 2, 1242, 1244, 7, 7, 2, 2, 1243, 1242, 3, 2, 2, 2, 1244, 1247,
	3, 2, 2, 2, 1245, 1243, 3, 2, 2, 2, 1245, 1246, 3, 2, 2, 2, 1246, 1248,
	3, 2, 2, 2, 1247, 1245, 3, 2, 2, 2, 1248, 1250, 5, 84, 43, 2, 1249, 1238,
	3, 2, 2, 2, 1249, 1250, 3, 2, 2, 2, 1250, 83, 3, 2, 2, 2, 1251, 1253, 5,
	86, 44, 2, 1252, 1251, 3, 2, 2, 2, 1252, 1253, 3, 2, 2, 2, 1253, 1258,
	3, 2, 2, 2, 1254, 1259, 5, 94, 48, 2, 1255, 1259, 5, 88, 45, 2, 1256, 1259,
	5, 90, 46, 2, 1257, 1259, 5, 92, 47, 2, 1258, 1254, 3, 2, 2, 2, 1258, 1255,
	3, 2, 2, 2, 1258, 1256, 3, 2, 2, 2, 1258, 1257, 3, 2, 2, 2, 1259, 85, 3,
	2, 2, 2, 1260, 1269, 5, 276, 139, 2, 1261, 1265, 7, 120, 2, 2, 1262, 1264,
	7, 7, 2, 2, 1263, 1262, 3, 2, 2, 2, 1264, 1267, 3, 2, 2, 2, 1265, 1263,
	3, 2, 2, 2, 1265, 1266, 3, 2, 2, 2, 1266, 1269, 3, 2, 2, 2, 1267, 1265,
	3, 2, 2, 2, 1268, 1260, 3, 2, 2, 2, 1268, 1261, 3, 2, 2, 2, 1269, 1270,
	3, 2, 2, 2, 1270, 1268, 3, 2, 2, 2, 1270, 1271, 3, 2, 2, 2, 1271, 87, 3,
	2, 2, 2, 1272, 1273, 7, 11, 2, 2, 1273, 1274, 5, 84, 43, 2, 1274, 1275,
	7, 12, 2, 2, 1275, 89, 3, 2, 2, 2, 1276, 1279, 5, 92, 47, 2, 1277, 1279,
	5, 88, 45, 2, 1278, 1276, 3, 2, 2, 2, 1278, 1277, 3, 2, 2, 2, 1279, 1283,
	3, 2, 2, 2, 1280, 1282, 7, 7, 2, 2, 1281, 1280, 3, 2, 2, 2, 1282, 1285,
	3, 2, 2, 2, 1283, 1281, 3, 2, 2, 2, 1283, 1284, 3, 2, 2, 2, 1284, 1287,
	3, 2, 2, 2, 1285, 1283, 3, 2, 2, 2, 1286, 1288, 7, 43, 2, 2, 1287, 1286,
	3, 2, 2, 2, 1288, 1289, 3, 2, 2, 2, 1289, 1287, 3, 2, 2, 2, 1289, 1290,
	3, 2, 2, 2, 1290, 91, 3, 2, 2, 2, 1291, 1292, 7, 11, 2, 2, 1292, 1293,
	5, 92, 47, 2, 1293, 1294, 7, 12, 2, 2, 1294, 1298, 3, 2, 2, 2, 1295, 1298,
	5, 98, 50, 2, 1296, 1298, 7, 105, 2, 2, 1297, 1291, 3, 2, 2, 2, 1297, 1295,
	3, 2, 2, 2, 1297, 1296, 3, 2, 2, 2, 1298, 93, 3, 2, 2, 2, 1299, 1303, 5,
	96, 49, 2, 1300, 1302, 7, 7, 2, 2, 1301, 1300, 3, 2, 2, 2, 1302, 1305,
	3, 2, 2, 2, 1303, 1301, 3, 2, 2, 2, 1303, 1304, 3, 2, 2, 2, 1304, 1306,
	3, 2, 2, 2, 1305, 1303, 3, 2, 2, 2, 1306, 1310, 7, 9, 2, 2, 1307, 1309,
	7, 7, 2, 2, 1308, 1307, 3, 2, 2, 2, 1309, 1312, 3, 2, 2, 2, 1310, 1308,
	3, 2, 2, 2, 1310, 1311, 3, 2, 2, 2, 1311, 1314, 3, 2, 2, 2, 1312, 1310,
	3, 2, 2, 2, 1313, 1299, 3, 2, 2, 2, 1313, 1314, 3, 2, 2, 2, 1314, 1315,
	3, 2, 2, 2, 1315, 1319, 5, 102, 52, 2, 1316, 1318, 7, 7, 2, 2, 1317, 1316,
	3, 2, 2, 2, 1318, 1321, 3, 2, 2, 2, 1319, 1317, 3, 2, 2, 2, 1319, 1320,
	3, 2, 2, 2, 1320, 1322, 3, 2, 2, 2, 1321, 1319, 3, 2, 2, 2, 1322, 1326,
	7, 35, 2, 2, 1323, 1325, 7, 7, 2, 2, 1324, 1323, 3, 2, 2, 2, 1325, 1328,
	3, 2, 2, 2, 1326, 1324, 3, 2, 2, 2, 1326, 1327, 3, 2, 2, 2, 1327, 1329,
	3, 2, 2, 2, 1328, 1326, 3, 2, 2, 2, 1329, 1330, 5, 84, 43, 2, 1330, 95,
	3, 2, 2, 2, 1331, 1335, 5, 88, 45, 2, 1332, 1335, 5, 90, 46, 2, 1333, 1335,
	5, 92, 47, 2, 1334, 1331, 3, 2, 2, 2, 1334, 1332, 3, 2, 2, 2, 1334, 1333,
	3, 2, 2, 2, 1335, 97, 3, 2, 2, 2, 1336, 1353, 5, 100, 51, 2, 1337, 1339,
	7, 7, 2, 2, 1338, 1337, 3, 2, 2, 2, 1339, 1342, 3, 2, 2, 2, 1340, 1338,
	3, 2, 2, 2, 1340, 1341, 3, 2, 2, 2, 1341, 1343, 3, 2, 2, 2, 1342, 1340,
	3, 2, 2, 2, 1343, 1347, 7, 9, 2, 2, 1344, 1346, 7, 7, 2, 2, 1345, 1344,
	3, 2, 2, 2, 1346, 1349, 3, 2, 2, 2, 1347, 1345, 3, 2, 2, 2, 1347, 1348,
	3, 2, 2, 2, 1348, 1350, 3, 2, 2, 2, 1349, 1347, 3, 2, 2, 2, 1350, 1352,
	5, 100, 51, 2, 1351, 1340, 3, 2, 2, 2, 1352, 1355, 3, 2, 2, 2, 1353, 1351,
	3, 2, 2, 2, 1353, 1354, 3, 2, 2, 2, 1354, 99, 3, 2, 2, 2, 1355, 1353, 3,
	2, 2, 2, 1356, 1364, 5, 288, 145, 2, 1357, 1359, 7, 7, 2, 2, 1358, 1357,
	3, 2, 2, 2, 1359, 1362, 3, 2, 2, 2, 1360, 1358, 3, 2, 2, 2, 1360, 1361,
	3, 2, 2, 2, 1361, 1363, 3, 2, 2, 2, 1362, 1360, 3, 2, 2, 2, 1363, 1365,
	5, 158, 80, 2, 1364, 1360, 3, 2, 2, 2, 1364, 1365, 3, 2, 2, 2, 1365, 101,
	3, 2, 2, 2, 1366, 1369, 7, 11, 2, 2, 1367, 1370, 5, 60, 31, 2, 1368, 1370,
	5, 84, 43, 2, 1369, 1367, 3, 2, 2, 2, 1369, 1368, 3, 2, 2, 2, 1369, 1370,
	3, 2, 2, 2, 1370, 1378, 3, 2, 2, 2, 1371, 1374, 7, 10, 2, 2, 1372, 1375,
	5, 60, 31, 2, 1373, 1375, 5, 84, 43, 2, 1374, 1372, 3, 2, 2, 2, 1374, 1373,
	3, 2, 2, 2, 1375, 1377, 3, 2, 2, 2, 1376, 1371, 3, 2, 2, 2, 1377, 1380,
	3, 2, 2, 2, 1378, 1376, 3, 2, 2, 2, 1378, 1379, 3, 2, 2, 2, 1379, 1381,
	3, 2, 2, 2, 1380, 1378, 3, 2, 2, 2, 1381, 1382, 7, 12, 2, 2, 1382, 103,
	3, 2, 2, 2, 1383, 1387, 7, 75, 2, 2, 1384, 1386, 7, 7, 2, 2, 1385, 1384,
	3, 2, 2, 2, 1386, 1389, 3, 2, 2, 2, 1387, 1385, 3, 2, 2, 2, 1387, 1388,
	3, 2, 2, 2, 1388, 1390, 3, 2, 2, 2, 1389, 1387, 3, 2, 2, 2, 1390, 1407,
	5, 106, 54, 2, 1391, 1393, 7, 7, 2, 2, 1392, 1391, 3, 2, 2, 2, 1393, 1396,
	3, 2, 2, 2, 1394, 1392, 3, 2, 2, 2, 1394, 1395, 3, 2, 2, 2, 1395, 1397,
	3, 2, 2, 2, 1396, 1394, 3, 2, 2, 2, 1397, 1401, 7, 10, 2, 2, 1398, 1400,
	7, 7, 2, 2, 1399, 1398, 3, 2, 2, 2, 1400, 1403, 3, 2, 2, 2, 1401, 1399,
	3, 2, 2, 2, 1401, 1402, 3, 2, 2, 2, 1402, 1404, 3, 2, 2, 2, 1403, 1401,
	3, 2, 2, 2, 1404, 1406, 5, 106, 54, 2, 1405, 1394, 3, 2, 2, 2, 1406, 1409,
	3, 2, 2, 2, 1407, 1405, 3, 2, 2, 2, 1407, 1408, 3, 2, 2, 2, 1408, 105,
	3, 2, 2, 2, 1409, 1407, 3, 2, 2, 2, 1410, 1412, 5, 276, 139, 2, 1411, 1410,
	3, 2, 2, 2, 1412, 1415, 3, 2, 2, 2, 1413, 1411, 3, 2, 2, 2, 1413, 1414,
	3, 2, 2, 2, 1414, 1416, 3, 2, 2, 2, 1415, 1413, 3, 2, 2, 2, 1416, 1420,
	5, 288, 145, 2, 1417, 1419, 7, 7, 2, 2, 1418, 1417, 3, 2, 2, 2, 1419, 1422,
	3, 2, 2, 2, 1420, 1418, 3, 2, 2, 2, 1420, 1421, 3, 2, 2, 2, 1421, 1423,
	3, 2, 2, 2, 1422, 1420, 3, 2, 2, 2, 1423, 1427, 7, 27, 2, 2, 1424, 1426,
	7, 7, 2, 2, 1425, 1424, 3, 2, 2, 2, 1426, 1429, 3, 2, 2, 2, 1427, 1425,
	3, 2, 2, 2, 1427, 1428, 3, 2, 2, 2, 1428, 1430, 3, 2, 2, 2, 1429, 1427,
	3, 2, 2, 2, 1430, 1431, 5, 84, 43, 2, 1431, 107, 3, 2, 2, 2, 1432, 1433,
	7, 15, 2, 2, 1433, 1434, 5, 110, 56, 2, 1434, 1435, 7, 16, 2, 2, 1435,
	109, 3, 2, 2, 2, 1436, 1438, 5, 292, 147, 2, 1437, 1436, 3, 2, 2, 2, 1438,
	1441, 3, 2, 2, 2, 1439, 1437, 3, 2, 2, 2, 1439, 1440, 3, 2, 2, 2, 1440,
	1456, 3, 2, 2, 2, 1441, 1439, 3, 2, 2, 2, 1442, 1453, 5, 112, 57, 2, 1443,
	1445, 5, 292, 147, 2, 1444, 1443, 3, 2, 2, 2, 1445, 1446, 3, 2, 2, 2, 1446,
	1444, 3, 2, 2, 2, 1446, 1447, 3, 2, 2, 2, 1447, 1449, 3, 2, 2, 2, 1448,
	1450, 5, 112, 57, 2, 1449, 1448, 3, 2, 2, 2, 1449, 1450, 3, 2, 2, 2, 1450,
	1452, 3, 2, 2, 2, 1451, 1444, 3, 2, 2, 2, 1452, 1455, 3, 2, 2, 2, 1453,
	1451, 3, 2, 2, 2, 1453, 1454, 3, 2, 2, 2, 1454, 1457, 3, 2, 2, 2, 1455,
	1453, 3, 2, 2, 2, 1456, 1442, 3, 2, 2, 2, 1456, 1457, 3, 2, 2, 2, 1457,
	111, 3, 2, 2, 2, 1458, 1461, 5, 116, 59, 2, 1459, 1461, 5, 114, 58, 2,
	1460, 1458, 3, 2, 2, 2, 1460, 1459, 3, 2, 2, 2, 1461, 113, 3, 2, 2, 2,
	1462, 1464, 5, 276, 139, 2, 1463, 1462, 3, 2, 2, 2, 1464, 1467, 3, 2, 2,
	2, 1465, 1463, 3, 2, 2, 2, 1465, 1466, 3, 2, 2, 2, 1466, 1471, 3, 2, 2,
	2, 1467, 1465, 3, 2, 2, 2, 1468, 1470, 7, 7, 2, 2, 1469, 1468, 3, 2, 2,
	2, 1470, 1473, 3, 2, 2, 2, 1471, 1469, 3, 2, 2, 2, 1471, 1472, 3, 2, 2,
	2, 1472, 1474, 3, 2, 2, 2, 1473, 1471, 3, 2, 2, 2, 1474, 1475, 5, 118,
	60, 2, 1475, 115, 3, 2, 2, 2, 1476, 1478, 5, 274, 138, 2, 1477, 1476, 3,
	2, 2, 2, 1478, 1481, 3, 2, 2, 2, 1479, 1477, 3, 2, 2, 2, 1479, 1480, 3,
	2, 2, 2, 1480, 1486, 3, 2, 2, 2, 1481, 1479, 3, 2, 2, 2, 1482, 1487, 5,
	22, 12, 2, 1483, 1487, 5, 54, 28, 2, 1484, 1487, 5, 68, 35, 2, 1485, 1487,
	5, 78, 40, 2, 1486, 1482, 3, 2, 2, 2, 1486, 1483, 3, 2, 2, 2, 1486, 1484,
	3, 2, 2, 2, 1486, 1485, 3, 2, 2, 2, 1487, 117, 3, 2, 2, 2, 1488, 1494,
	5, 120, 61, 2, 1489, 1490, 5, 230, 116, 2, 1490, 1491, 5, 120, 61, 2, 1491,
	1493, 3, 2, 2, 2, 1492, 1489, 3, 2, 2, 2, 1493, 1496, 3, 2, 2, 2, 1494,
	1492, 3, 2, 2, 2, 1494, 1495, 3, 2, 2, 2, 1495, 119, 3, 2, 2, 2, 1496,
	1494, 3, 2, 2, 2, 1497, 1514, 5, 122, 62, 2, 1498, 1500, 7, 7, 2, 2, 1499,
	1498, 3, 2, 2, 2, 1500, 1503, 3, 2, 2, 2, 1501, 1499, 3, 2, 2, 2, 1501,
	1502, 3, 2, 2, 2, 1502, 1504, 3, 2, 2, 2, 1503, 1501, 3, 2, 2, 2, 1504,
	1508, 7, 25, 2, 2, 1505, 1507, 7, 7, 2, 2, 1506, 1505, 3, 2, 2, 2, 1507,
	1510, 3, 2, 2, 2, 1508, 1506, 3, 2, 2, 2, 1508, 1509, 3, 2, 2, 2, 1509,
	1511, 3, 2, 2, 2, 1510, 1508, 3, 2, 2, 2, 1511, 1513, 5, 122, 62, 2, 1512,
	1501, 3, 2, 2, 2, 1513, 1516, 3, 2, 2, 2, 1514, 1512, 3, 2, 2, 2, 1514,
	1515, 3, 2, 2, 2, 1515, 121, 3, 2, 2, 2, 1516, 1514, 3, 2, 2, 2, 1517,
	1534, 5, 124, 63, 2, 1518, 1520, 7, 7, 2, 2, 1519, 1518, 3, 2, 2, 2, 1520,
	1523, 3, 2, 2, 2, 1521, 1519, 3, 2, 2, 2, 1521, 1522, 3, 2, 2, 2, 1522,
	1524, 3, 2, 2, 2, 1523, 1521, 3, 2, 2, 2, 1524, 1528, 7, 24, 2, 2, 1525,
	1527, 7, 7, 2, 2, 1526, 1525, 3, 2, 2, 2, 1527, 1530, 3, 2, 2, 2, 1528,
	1526, 3, 2, 2, 2, 1528, 1529, 3, 2, 2, 2, 1529, 1531, 3, 2, 2, 2, 1530,
	1528, 3, 2, 2, 2, 1531, 1533, 5, 124, 63, 2, 1532, 1521, 3, 2, 2, 2, 1533,
	1536, 3, 2, 2, 2, 1534, 1532, 3, 2, 2, 2, 1534, 1535, 3, 2, 2, 2, 1535,
	123, 3, 2, 2, 2, 1536, 1534, 3, 2, 2, 2, 1537, 1549, 5, 126, 64, 2, 1538,
	1542, 5, 232, 117, 2, 1539, 1541, 7, 7, 2, 2, 1540, 1539, 3, 2, 2, 2, 1541,
	1544, 3, 2, 2, 2, 1542, 1540, 3, 2, 2, 2, 1542, 1543, 3, 2, 2, 2, 1543,
	1545, 3, 2, 2, 2, 1544, 1542, 3, 2, 2, 2, 1545, 1546, 5, 126, 64, 2, 1546,
	1548, 3, 2, 2, 2, 1547, 1538, 3, 2, 2, 2, 1548, 1551, 3, 2, 2, 2, 1549,
	1547, 3, 2, 2, 2, 1549, 1550, 3, 2, 2, 2, 1550, 125, 3, 2, 2, 2, 1551,
	1549, 3, 2, 2, 2, 1552, 1562, 5, 128, 65, 2, 1553, 1557, 5, 234, 118, 2,
	1554, 1556, 7, 7, 2, 2, 1555, 1554, 3, 2, 2, 2, 1556, 1559, 3, 2, 2, 2,
	1557, 1555, 3, 2, 2, 2, 1557, 1558, 3, 2, 2, 2, 1558, 1560, 3, 2, 2, 2,
	1559, 1557, 3, 2, 2, 2, 1560, 1561, 5, 128, 65, 2, 1561, 1563, 3, 2, 2,
	2, 1562, 1553, 3, 2, 2, 2, 1562, 1563, 3, 2, 2, 2, 1563, 127, 3, 2, 2,
	2, 1564, 1587, 5, 130, 66, 2, 1565, 1569, 5, 236, 119, 2, 1566, 1568, 7,
	7, 2, 2, 1567, 1566, 3, 2, 2, 2, 1568, 1571, 3, 2, 2, 2, 1569, 1567, 3,
	2, 2, 2, 1569, 1570, 3, 2, 2, 2, 1570, 1572, 3, 2, 2, 2, 1571, 1569, 3,
	2, 2, 2, 1572, 1573, 5, 130, 66, 2, 1573, 1575, 3, 2, 2, 2, 1574, 1565,
	3, 2, 2, 2, 1575, 1576, 3, 2, 2, 2, 1576, 1574, 3, 2, 2, 2, 1576, 1577,
	3, 2, 2, 2, 1577, 1588, 3, 2, 2, 2, 1578, 1582, 5, 238, 120, 2, 1579, 1581,
	7, 7, 2, 2, 1580, 1579, 3, 2, 2, 2, 1581, 1584, 3, 2, 2, 2, 1582, 1580,
	3, 2, 2, 2, 1582, 1583, 3, 2, 2, 2, 1583, 1585, 3, 2, 2, 2, 1584, 1582,
	3, 2, 2, 2, 1585, 1586, 5, 84, 43, 2, 1586, 1588, 3, 2, 2, 2, 1587, 1574,
	3, 2, 2, 2, 1587, 1578, 3, 2, 2, 2, 1587, 1588, 3, 2, 2, 2, 1588, 129,
	3, 2, 2, 2, 1589, 1606, 5, 132, 67, 2, 1590, 1592, 7, 7, 2, 2, 1591, 1590,
	3, 2, 2, 2, 1592, 1595, 3, 2, 2, 2, 1593, 1591, 3, 2, 2, 2, 1593, 1594,
	3, 2, 2, 2, 1594, 1596, 3, 2, 2, 2, 1595, 1593, 3, 2, 2, 2, 1596, 1600,
	7, 44, 2, 2, 1597, 1599, 7, 7, 2, 2, 1598, 1597, 3, 2, 2, 2, 1599, 1602,
	3, 2, 2, 2, 1600, 1598, 3, 2, 2, 2, 1600, 1601, 3, 2, 2, 2, 1601, 1603,
	3, 2, 2, 2, 1602, 1600, 3, 2, 2, 2, 1603, 1605, 5, 132, 67, 2, 1604, 1593,
	3, 2, 2, 2, 1605, 1608, 3, 2, 2, 2, 1606, 1604, 3, 2, 2, 2, 1606, 1607,
	3, 2, 2, 2, 1607, 131, 3, 2, 2, 2, 1608, 1606, 3, 2, 2, 2, 1609, 1621,
	5, 134, 68, 2, 1610, 1614, 5, 288, 145, 2, 1611, 1613, 7, 7, 2, 2, 1612,
	1611, 3, 2, 2, 2, 1613, 1616, 3, 2, 2, 2, 1614, 1612, 3, 2, 2, 2, 1614,
	1615, 3, 2, 2, 2, 1615, 1617, 3, 2, 2, 2, 1616, 1614, 3, 2, 2, 2, 1617,
	1618, 5, 134, 68, 2, 1618, 1620, 3, 2, 2, 2, 1619, 1610, 3, 2, 2, 2, 1620,
	1623, 3, 2, 2, 2, 1621, 1619, 3, 2, 2, 2, 1621, 1622, 3, 2, 2, 2, 1622,
	133, 3, 2, 2, 2, 1623, 1621, 3, 2, 2, 2, 1624, 1635, 5, 136, 69, 2, 1625,
	1629, 7, 37, 2, 2, 1626, 1628, 7, 7, 2, 2, 1627, 1626, 3, 2, 2, 2, 1628,
	1631, 3, 2, 2, 2, 1629, 1627, 3, 2, 2, 2, 1629, 1630, 3, 2, 2, 2, 1630,
	1632, 3, 2, 2, 2, 1631, 1629, 3, 2, 2, 2, 1632, 1634, 5, 136, 69, 2, 1633,
	1625, 3, 2, 2, 2, 1634, 1637, 3, 2, 2, 2, 1635, 1633, 3, 2, 2, 2, 1635,
	1636, 3, 2, 2, 2, 1636, 135, 3, 2, 2, 2, 1637, 1635, 3, 2, 2, 2, 1638,
	1650, 5, 138, 70, 2, 1639, 1643, 5, 240, 121, 2, 1640, 1642, 7, 7, 2, 2,
	1641, 1640, 3, 2, 2, 2, 1642, 1645, 3, 2, 2, 2, 1643, 1641, 3, 2, 2, 2,
	1643, 1644, 3, 2, 2, 2, 1644, 1646, 3, 2, 2, 2, 1645, 1643, 3, 2, 2, 2,
	1646, 1647, 5, 138, 70, 2, 1647, 1649, 3, 2, 2, 2, 1648, 1639, 3, 2, 2,
	2, 1649, 1652, 3, 2, 2, 2, 1650, 1648, 3, 2, 2, 2, 1650, 1651, 3, 2, 2,
	2, 1651, 137, 3, 2, 2, 2, 1652, 1650, 3, 2, 2, 2, 1653, 1665, 5, 140, 71,
	2, 1654, 1658, 5, 242, 122, 2, 1655, 1657, 7, 7, 2, 2, 1656, 1655, 3, 2,
	2, 2, 1657, 1660, 3, 2, 2, 2, 1658, 1656, 3, 2, 2, 2, 1658, 1659, 3, 2,
	2, 2, 1659, 1661, 3, 2, 2, 2, 1660, 1658, 3, 2, 2, 2, 1661, 1662, 5, 140,
	71, 2, 1662, 1664, 3, 2, 2, 2, 1663, 1654, 3, 2, 2, 2, 1664, 1667, 3, 2,
	2, 2, 1665, 1663, 3, 2, 2, 2, 1665, 1666, 3, 2, 2, 2, 1666, 139, 3, 2,
	2, 2, 1667, 1665, 3, 2, 2, 2, 1668, 1680, 5, 142, 72, 2, 1669, 1671, 7,
	7, 2, 2, 1670, 1669, 3, 2, 2, 2, 1671, 1674, 3, 2, 2, 2, 1672, 1670, 3,
	2, 2, 2, 1672, 1673, 3, 2, 2, 2, 1673, 1675, 3, 2, 2, 2, 1674, 1672, 3,
	2, 2, 2, 1675, 1676, 5, 244, 123, 2, 1676, 1677, 5, 142, 72, 2, 1677, 1679,
	3, 2, 2, 2, 1678, 1672, 3, 2, 2, 2, 1679, 1682, 3, 2, 2, 2, 1680, 1678,
	3, 2, 2, 2, 1680, 1681, 3, 2, 2, 2, 1681, 141, 3, 2, 2, 2, 1682, 1680,
	3, 2, 2, 2, 1683, 1685, 5, 246, 124, 2, 1684, 1683, 3, 2, 2, 2, 1685, 1688,
	3, 2, 2, 2, 1686, 1684, 3, 2, 2, 2, 1686, 1687, 3, 2, 2, 2, 1687, 1689,
	3, 2, 2, 2, 1688, 1686, 3, 2, 2, 2, 1689, 1690, 5, 144, 73, 2, 1690, 143,
	3, 2, 2, 2, 1691, 1694, 5, 146, 74, 2, 1692, 1694, 5, 228, 115, 2, 1693,
	1691, 3, 2, 2, 2, 1693, 1692, 3, 2, 2, 2, 1694, 1698, 3, 2, 2, 2, 1695,
	1697, 5, 248, 125, 2, 1696, 1695, 3, 2, 2, 2, 1697, 1700, 3, 2, 2, 2, 1698,
	1696, 3, 2, 2, 2, 1698, 1699, 3, 2, 2, 2, 1699, 145, 3, 2, 2, 2, 1700,
	1698, 3, 2, 2, 2, 1701, 1714, 5, 148, 75, 2, 1702, 1714, 5, 166, 84, 2,
	1703, 1714, 5, 182, 92, 2, 1704, 1714, 5, 192, 97, 2, 1705, 1714, 5, 194,
	98, 2, 1706, 1714, 5, 196, 99, 2, 1707, 1714, 5, 212, 107, 2, 1708, 1714,
	5, 188, 95, 2, 1709, 1714, 5, 226, 114, 2, 1710, 1714, 5, 218, 110, 2,
	1711, 1714, 5, 190, 96, 2, 1712, 1714, 5, 288, 145, 2, 1713, 1701, 3, 2,
	2, 2, 1713, 1702, 3, 2, 2, 2, 1713, 1703, 3, 2, 2, 2, 1713, 1704, 3, 2,
	2, 2, 1713, 1705, 3, 2, 2, 2, 1713, 1706, 3, 2, 2, 2, 1713, 1707, 3, 2,
	2, 2, 1713, 1708, 3, 2, 2, 2, 1713, 1709, 3, 2, 2, 2, 1713, 1710, 3, 2,
	2, 2, 1713, 1711, 3, 2, 2, 2, 1713, 1712, 3, 2, 2, 2, 1714, 147, 3, 2,
	2, 2, 1715, 1716, 7, 11, 2, 2, 1716, 1717, 5, 118, 60, 2, 1717, 1718, 7,
	12, 2, 2, 1718, 149, 3, 2, 2, 2, 1719, 1721, 5, 158, 80, 2, 1720, 1722,
	5, 156, 79, 2, 1721, 1720, 3, 2, 2, 2, 1721, 1722, 3, 2, 2, 2, 1722, 1726,
	3, 2, 2, 2, 1723, 1725, 5, 152, 77, 2, 1724, 1723, 3, 2, 2, 2, 1725, 1728,
	3, 2, 2, 2, 1726, 1724, 3, 2, 2, 2, 1726, 1727, 3, 2, 2, 2, 1727, 1742,
	3, 2, 2, 2, 1728, 1726, 3, 2, 2, 2, 1729, 1733, 5, 156, 79, 2, 1730, 1732,
	5, 152, 77, 2, 1731, 1730, 3, 2, 2, 2, 1732, 1735, 3, 2, 2, 2, 1733, 1731,
	3, 2, 2, 2, 1733, 1734, 3, 2, 2, 2, 1734, 1742, 3, 2, 2, 2, 1735, 1733,
	3, 2, 2, 2, 1736, 1738, 5, 152, 77, 2, 1737, 1736, 3, 2, 2, 2, 1738, 1739,
	3, 2, 2, 2, 1739, 1737, 3, 2, 2, 2, 1739, 1740, 3, 2, 2, 2, 1740, 1742,
	3, 2, 2, 2, 1741, 1719, 3, 2, 2, 2, 1741, 1729, 3, 2, 2, 2, 1741, 1737,
	3, 2, 2, 2, 1742, 151, 3, 2, 2, 2, 1743, 1745, 5, 284, 143, 2, 1744, 1743,
	3, 2, 2, 2, 1745, 1748, 3, 2, 2, 2, 1746, 1744, 3, 2, 2, 2, 1746, 1747,
	3, 2, 2, 2, 1747, 1750, 3, 2, 2, 2, 1748, 1746, 3, 2, 2, 2, 1749, 1751,
	7, 144, 2, 2, 1750, 1749, 3, 2, 2, 2, 1750, 1751, 3, 2, 2, 2, 1751, 1755,
	3, 2, 2, 2, 1752, 1754, 7, 7, 2, 2, 1753, 1752, 3, 2, 2, 2, 1754, 1757,
	3, 2, 2, 2, 1755, 1753, 3, 2, 2, 2, 1755, 1756, 3, 2, 2, 2, 1756, 1758,
	3, 2, 2, 2, 1757, 1755, 3, 2, 2, 2, 1758, 1759, 5, 182, 92, 2, 1759, 153,
	3, 2, 2, 2, 1760, 1769, 7, 13, 2, 2, 1761, 1766, 5, 118, 60, 2, 1762, 1763,
	7, 10, 2, 2, 1763, 1765, 5, 118, 60, 2, 1764, 1762, 3, 2, 2, 2, 1765, 1768,
	3, 2, 2, 2, 1766, 1764, 3, 2, 2, 2, 1766, 1767, 3, 2, 2, 2, 1767, 1770,
	3, 2, 2, 2, 1768, 1766, 3, 2, 2, 2, 1769, 1761, 3, 2, 2, 2, 1769, 1770,
	3, 2, 2, 2, 1770, 1771, 3, 2, 2, 2, 1771, 1772, 7, 14, 2, 2, 1772, 155,
	3, 2, 2, 2, 1773, 1782, 7, 11, 2, 2, 1774, 1779, 5, 164, 83, 2, 1775, 1776,
	7, 10, 2, 2, 1776, 1778, 5, 164, 83, 2, 1777, 1775, 3, 2, 2, 2, 1778, 1781,
	3, 2, 2, 2, 1779, 1777, 3, 2, 2, 2, 1779, 1780, 3, 2, 2, 2, 1780, 1783,
	3, 2, 2, 2, 1781, 1779, 3, 2, 2, 2, 1782, 1774, 3, 2, 2, 2, 1782, 1783,
	3, 2, 2, 2, 1783, 1784, 3, 2, 2, 2, 1784, 1785, 7, 12, 2, 2, 1785, 157,
	3, 2, 2, 2, 1786, 1790, 7, 45, 2, 2, 1787, 1789, 7, 7, 2, 2, 1788, 1787,
	3, 2, 2, 2, 1789, 1792, 3, 2, 2, 2, 1790, 1788, 3, 2, 2, 2, 1790, 1791,
	3, 2, 2, 2, 1791, 1793, 3, 2, 2, 2, 1792, 1790, 3, 2, 2, 2, 1793, 1804,
	5, 160, 81, 2, 1794, 1796, 7, 7, 2, 2, 1795, 1794, 3, 2, 2, 2, 1796, 1799,
	3, 2, 2, 2, 1797, 1795, 3, 2, 2, 2, 1797, 1798, 3, 2, 2, 2, 1798, 1800,
	3, 2, 2, 2, 1799, 1797, 3, 2, 2, 2, 1800, 1801, 7, 10, 2, 2, 1801, 1803,
	5, 160, 81, 2, 1802, 1797, 3, 2, 2, 2, 1803, 1806, 3, 2, 2, 2, 1804, 1802,
	3, 2, 2, 2, 1804, 1805, 3, 2, 2, 2, 1805, 1810, 3, 2, 2, 2, 1806, 1804,
	3, 2, 2, 2, 1807, 1809, 7, 7, 2, 2, 1808, 1807, 3, 2, 2, 2, 1809, 1812,
	3, 2, 2, 2, 1810, 1808, 3, 2, 2, 2, 1810, 1811, 3, 2, 2, 2, 1811, 1813,
	3, 2, 2, 2, 1812, 1810, 3, 2, 2, 2, 1813, 1814, 7, 46, 2, 2, 1814, 159,
	3, 2, 2, 2, 1815, 1817, 5, 162, 82, 2, 1816, 1815, 3, 2, 2, 2, 1816, 1817,
	3, 2, 2, 2, 1817, 1818, 3, 2, 2, 2, 1818, 1821, 5, 84, 43, 2, 1819, 1821,
	7, 17, 2, 2, 1820, 1816, 3, 2, 2, 2, 1820, 1819, 3, 2, 2, 2, 1821, 161,
	3, 2, 2, 2, 1822, 1824, 5, 262, 132, 2, 1823, 1822, 3, 2, 2, 2, 1824, 1825,
	3, 2, 2, 2, 1825, 1823, 3, 2, 2, 2, 1825, 1826, 3, 2, 2, 2, 1826, 163,
	3, 2, 2, 2, 1827, 1831, 5, 288, 145, 2, 1828, 1830, 7, 7, 2, 2, 1829, 1828,
	3, 2, 2, 2, 1830, 1833, 3, 2, 2, 2, 1831, 1829, 3, 2, 2, 2, 1831, 1832,
	3, 2, 2, 2, 1832, 1834, 3, 2, 2, 2, 1833, 1831, 3, 2, 2, 2, 1834, 1838,
	7, 29, 2, 2, 1835, 1837, 7, 7, 2, 2, 1836, 1835, 3, 2, 2, 2, 1837, 1840,
	3, 2, 2, 2, 1838, 1836, 3, 2, 2, 2, 1838, 1839, 3, 2, 2, 2, 1839, 1842,
	3, 2, 2, 2, 1840, 1838, 3, 2, 2, 2, 1841, 1827, 3, 2, 2, 2, 1841, 1842,
	3, 2, 2, 2, 1842, 1844, 3, 2, 2, 2, 1843, 1845, 7, 17, 2, 2, 1844, 1843,
	3, 2, 2, 2, 1844, 1845, 3, 2, 2, 2, 1845, 1849, 3, 2, 2, 2, 1846, 1848,
	7, 7, 2, 2, 1847, 1846, 3, 2, 2, 2, 1848, 1851, 3, 2, 2, 2, 1849, 1847,
	3, 2, 2, 2, 1849, 1850, 3, 2, 2, 2, 1850, 1852, 3, 2, 2, 2, 1851, 1849,
	3, 2, 2, 2, 1852, 1853, 5, 118, 60, 2, 1853, 165, 3, 2, 2, 2, 1854, 1864,
	7, 140, 2, 2, 1855, 1864, 7, 137, 2, 2, 1856, 1864, 5, 168, 85, 2, 1857,
	1864, 7, 138, 2, 2, 1858, 1864, 7, 139, 2, 2, 1859, 1864, 7, 146, 2, 2,
	1860, 1864, 7, 133, 2, 2, 1861, 1864, 7, 141, 2, 2, 1862, 1864, 7, 136,
	2, 2, 1863, 1854, 3, 2, 2, 2, 1863, 1855, 3, 2, 2, 2, 1863, 1856, 3, 2,
	2, 2, 1863, 1857, 3, 2, 2, 2, 1863, 1858, 3, 2, 2, 2, 1863, 1859, 3, 2,
	2, 2, 1863, 1860, 3, 2, 2, 2, 1863, 1861, 3, 2, 2, 2, 1863, 1862, 3, 2,
	2, 2, 1864, 167, 3, 2, 2, 2, 1865, 1868, 5, 170, 86, 2, 1866, 1868, 5,
	172, 87, 2, 1867, 1865, 3, 2, 2, 2, 1867, 1866, 3, 2, 2, 2, 1868, 169,
	3, 2, 2, 2, 1869, 1874, 7, 131, 2, 2, 1870, 1873, 5, 174, 88, 2, 1871,
	1873, 5, 176, 89, 2, 1872, 1870, 3, 2, 2, 2, 1872, 1871, 3, 2, 2, 2, 1873,
	1876, 3, 2, 2, 2, 1874, 1872, 3, 2, 2, 2, 1874, 1875, 3, 2, 2, 2, 1875,
	1877, 3, 2, 2, 2, 1876, 1874, 3, 2, 2, 2, 1877, 1878, 7, 157, 2, 2, 1878,
	171, 3, 2, 2, 2, 1879, 1886, 7, 132, 2, 2, 1880, 1885, 5, 178, 90, 2, 1881,
	1885, 5, 180, 91, 2, 1882, 1885, 5, 170, 86, 2, 1883, 1885, 7, 163, 2,
	2, 1884, 1880, 3, 2, 2, 2, 1884, 1881, 3, 2, 2, 2, 1884, 1882, 3, 2, 2,
	2, 1884, 1883, 3, 2, 2, 2, 1885, 1888, 3, 2, 2, 2, 1886, 1884, 3, 2, 2,
	2, 1886, 1887, 3, 2, 2, 2, 1887, 1889, 3, 2, 2, 2, 1888, 1886, 3, 2, 2,
	2, 1889, 1890, 7, 162, 2, 2, 1890, 173, 3, 2, 2, 2, 1891, 1892, 9, 5, 2,
	2, 1892, 175, 3, 2, 2, 2, 1893, 1894, 7, 161, 2, 2, 1894, 1895, 5, 118,
	60, 2, 1895, 1896, 7, 16, 2, 2, 1896, 177, 3, 2, 2, 2, 1897, 1898, 9, 6,
	2, 2, 1898, 179, 3, 2, 2, 2, 1899, 1900, 7, 167, 2, 2, 1900, 1901, 5, 118,
	60, 2, 1901, 1902, 7, 16, 2, 2, 1902, 181, 3, 2, 2, 2, 1903, 1905, 5, 276,
	139, 2, 1904, 1903, 3, 2, 2, 2, 1905, 1908, 3, 2, 2, 2, 1906, 1904, 3,
	2, 2, 2, 1906, 1907, 3, 2, 2, 2, 1907, 1955, 3, 2, 2, 2, 1908, 1906, 3,
	2, 2, 2, 1909, 1913, 7, 15, 2, 2, 1910, 1912, 7, 7, 2, 2, 1911, 1910, 3,
	2, 2, 2, 1912, 1915, 3, 2, 2, 2, 1913, 1911, 3, 2, 2, 2, 1913, 1914, 3,
	2, 2, 2, 1914, 1916, 3, 2, 2, 2, 1915, 1913, 3, 2, 2, 2, 1916, 1920, 5,
	110, 56, 2, 1917, 1919, 7, 7, 2, 2, 1918, 1917, 3, 2, 2, 2, 1919, 1922,
	3, 2, 2, 2, 1920, 1918, 3, 2, 2, 2, 1920, 1921, 3, 2, 2, 2, 1921, 1923,
	3, 2, 2, 2, 1922, 1920, 3, 2, 2, 2, 1923, 1924, 7, 16, 2, 2, 1924, 1956,
	3, 2, 2, 2, 1925, 1929, 7, 15, 2, 2, 1926, 1928, 7, 7, 2, 2, 1927, 1926,
	3, 2, 2, 2, 1928, 1931, 3, 2, 2, 2, 1929, 1927, 3, 2, 2, 2, 1929, 1930,
	3, 2, 2, 2, 1930, 1932, 3, 2, 2, 2, 1931, 1929, 3, 2, 2, 2, 1932, 1936,
	5, 184, 93, 2, 1933, 1935, 7, 7, 2, 2, 1934, 1933, 3, 2, 2, 2, 1935, 1938,
	3, 2, 2, 2, 1936, 1934, 3, 2, 2, 2, 1936, 1937, 3, 2, 2, 2, 1937, 1939,
	3, 2, 2, 2, 1938, 1936, 3, 2, 2, 2, 1939, 1943, 7, 35, 2, 2, 1940, 1942,
	7, 7, 2, 2, 1941, 1940, 3, 2, 2, 2, 1942, 1945, 3, 2, 2, 2, 1943, 1941,
	3, 2, 2, 2, 1943, 1944, 3, 2, 2, 2, 1944, 1946, 3, 2, 2, 2, 1945, 1943,
	3, 2, 2, 2, 1946, 1950, 5, 110, 56, 2, 1947, 1949, 7, 7, 2, 2, 1948, 1947,
	3, 2, 2, 2, 1949, 1952, 3, 2, 2, 2, 1950, 1948, 3, 2, 2, 2, 1950, 1951,
	3, 2, 2, 2, 1951, 1953, 3, 2, 2, 2, 1952, 1950, 3, 2, 2, 2, 1953, 1954,
	7, 16, 2, 2, 1954, 1956, 3, 2, 2, 2, 1955, 1909, 3, 2, 2, 2, 1955, 1925,
	3, 2, 2, 2, 1956, 183, 3, 2, 2, 2, 1957, 1959, 5, 186, 94, 2, 1958, 1957,
	3, 2, 2, 2, 1958, 1959, 3, 2, 2, 2, 1959, 1976, 3, 2, 2, 2, 1960, 1962,
	7, 7, 2, 2, 1961, 1960, 3, 2, 2, 2, 1962, 1965, 3, 2, 2, 2, 1963, 1961,
	3, 2, 2, 2, 1963, 1964, 3, 2, 2, 2, 1964, 1966, 3, 2, 2, 2, 1965, 1963,
	3, 2, 2, 2, 1966, 1970, 7, 10, 2, 2, 1967, 1969, 7, 7, 2, 2, 1968, 1967,
	3, 2, 2, 2, 1969, 1972, 3, 2, 2, 2, 1970, 1968, 3, 2, 2, 2, 1970, 1971,
	3, 2, 2, 2, 1971, 1973, 3, 2, 2, 2, 1972, 1970, 3, 2, 2, 2, 1973, 1975,
	5, 186, 94, 2, 1974, 1963, 3, 2, 2, 2, 1975, 1978, 3, 2, 2, 2, 1976, 1974,
	3, 2, 2, 2, 1976, 1977, 3, 2, 2, 2, 1977, 185, 3, 2, 2, 2, 1978, 1976,
	3, 2, 2, 2, 1979, 1998, 5, 72, 37, 2, 1980, 1995, 5, 70, 36, 2, 1981, 1983,
	7, 7, 2, 2, 1982, 1981, 3, 2, 2, 2, 1983, 1986, 3, 2, 2, 2, 1984, 1982,
	3, 2, 2, 2, 1984, 1985, 3, 2, 2, 2, 1985, 1987, 3, 2, 2, 2, 1986, 1984,
	3, 2, 2, 2, 1987, 1991, 7, 27, 2, 2, 1988, 1990, 7, 7, 2, 2, 1989, 1988,
	3, 2, 2, 2, 1990, 1993, 3, 2, 2, 2, 1991, 1989, 3, 2, 2, 2, 1991, 1992,
	3, 2, 2, 2, 1992, 1994, 3, 2, 2, 2, 1993, 1991, 3, 2, 2, 2, 1994, 1996,
	5, 84, 43, 2, 1995, 1984, 3, 2, 2, 2, 1995, 1996, 3, 2, 2, 2, 1996, 1998,
	3, 2, 2, 2, 1997, 1979, 3, 2, 2, 2, 1997, 1980, 3, 2, 2, 2, 1998, 187,
	3, 2, 2, 2, 1999, 2014, 7, 64, 2, 2, 2000, 2002, 7, 7, 2, 2, 2001, 2000,
	3, 2, 2, 2, 2002, 2005, 3, 2, 2, 2, 2003, 2001, 3, 2, 2, 2, 2003, 2004,
	3, 2, 2, 2, 2004, 2006, 3, 2, 2, 2, 2005, 2003, 3, 2, 2, 2, 2006, 2010,
	7, 27, 2, 2, 2007, 2009, 7, 7, 2, 2, 2008, 2007, 3, 2, 2, 2, 2009, 2012,
	3, 2, 2, 2, 2010, 2008, 3, 2, 2, 2, 2010, 2011, 3, 2, 2, 2, 2011, 2013,
	3, 2, 2, 2, 2012, 2010, 3, 2, 2, 2, 2013, 2015, 5, 30, 16, 2, 2014, 2003,
	3, 2, 2, 2, 2014, 2015, 3, 2, 2, 2, 2015, 2019, 3, 2, 2, 2, 2016, 2018,
	7, 7, 2, 2, 2017, 2016, 3, 2, 2, 2, 2018, 2021, 3, 2, 2, 2, 2019, 2017,
	3, 2, 2, 2, 2019, 2020, 3, 2, 2, 2, 2020, 2022, 3, 2, 2, 2, 2021, 2019,
	3, 2, 2, 2, 2022, 2023, 5, 38, 20, 2, 2023, 189, 3, 2, 2, 2, 2024, 2026,
	7, 13, 2, 2, 2025, 2027, 5, 118, 60, 2, 2026, 2025, 3, 2, 2, 2, 2026, 2027,
	3, 2, 2, 2, 2027, 2032, 3, 2, 2, 2, 2028, 2029, 7, 10, 2, 2, 2029, 2031,
	5, 118, 60, 2, 2030, 2028, 3, 2, 2, 2, 2031, 2034, 3, 2, 2, 2, 2032, 2030,
	3, 2, 2, 2, 2032, 2033, 3, 2, 2, 2, 2033, 2035, 3, 2, 2, 2, 2034, 2032,
	3, 2, 2, 2, 2035, 2036, 7, 14, 2, 2, 2036, 191, 3, 2, 2, 2, 2037, 2039,
	7, 72, 2, 2, 2038, 2040, 7, 143, 2, 2, 2039, 2038, 3, 2, 2, 2, 2039, 2040,
	3, 2, 2, 2, 2040, 193, 3, 2, 2, 2, 2041, 2058, 7, 73, 2, 2, 2042, 2046,
	7, 45, 2, 2, 2043, 2045, 7, 7, 2, 2, 2044, 2043, 3, 2, 2, 2, 2045, 2048,
	3, 2, 2, 2, 2046, 2044, 3, 2, 2, 2, 2046, 2047, 3, 2, 2, 2, 2047, 2049,
	3, 2, 2, 2, 2048, 2046, 3, 2, 2, 2, 2049, 2053, 5, 84, 43, 2, 2050, 2052,
	7, 7, 2, 2, 2051, 2050, 3, 2, 2, 2, 2052, 2055, 3, 2, 2, 2, 2053, 2051,
	3, 2, 2, 2, 2053, 2054, 3, 2, 2, 2, 2054, 2056, 3, 2, 2, 2, 2055, 2053,
	3, 2, 2, 2, 2056, 2057, 7, 46, 2, 2, 2057, 2059, 3, 2, 2, 2, 2058, 2042,
	3, 2, 2, 2, 2058, 2059, 3, 2, 2, 2, 2059, 2061, 3, 2, 2, 2, 2060, 2062,
	7, 143, 2, 2, 2061, 2060, 3, 2, 2, 2, 2061, 2062, 3, 2, 2, 2, 2062, 195,
	3, 2, 2, 2, 2063, 2066, 5, 198, 100, 2, 2064, 2066, 5, 202, 102, 2, 2065,
	2063, 3, 2, 2, 2, 2065, 2064, 3, 2, 2, 2, 2066, 197, 3, 2, 2, 2, 2067,
	2071, 7, 76, 2, 2, 2068, 2070, 7, 7, 2, 2, 2069, 2068, 3, 2, 2, 2, 2070,
	2073, 3, 2, 2, 2, 2071, 2069, 3, 2, 2, 2, 2071, 2072, 3, 2, 2, 2, 2072,
	2074, 3, 2, 2, 2, 2073, 2071, 3, 2, 2, 2, 2074, 2075, 7, 11, 2, 2, 2075,
	2076, 5, 118, 60, 2, 2076, 2080, 7, 12, 2, 2, 2077, 2079, 7, 7, 2, 2, 2078,
	2077, 3, 2, 2, 2, 2079, 2082, 3, 2, 2, 2, 2080, 2078, 3, 2, 2, 2, 2080,
	2081, 3, 2, 2, 2, 2081, 2084, 3, 2, 2, 2, 2082, 2080, 3, 2, 2, 2, 2083,
	2085, 5, 200, 101, 2, 2084, 2083, 3, 2, 2, 2, 2084, 2085, 3, 2, 2, 2, 2085,
	2087, 3, 2, 2, 2, 2086, 2088, 7, 28, 2, 2, 2087, 2086, 3, 2, 2, 2, 2087,
	2088, 3, 2, 2, 2, 2088, 2105, 3, 2, 2, 2, 2089, 2091, 7, 7, 2, 2, 2090,
	2089, 3, 2, 2, 2, 2091, 2094, 3, 2, 2, 2, 2092, 2090, 3, 2, 2, 2, 2092,
	2093, 3, 2, 2, 2, 2093, 2095, 3, 2, 2, 2, 2094, 2092, 3, 2, 2, 2, 2095,
	2099, 7, 77, 2, 2, 2096, 2098, 7, 7, 2, 2, 2097, 2096, 3, 2, 2, 2, 2098,
	2101, 3, 2, 2, 2, 2099, 2097, 3, 2, 2, 2, 2099, 2100, 3, 2, 2, 2, 2100,
	2103, 3, 2, 2, 2, 2101, 2099, 3, 2, 2, 2, 2102, 2104, 5, 200, 101, 2, 2103,
	2102, 3, 2, 2, 2, 2103, 2104, 3, 2, 2, 2, 2104, 2106, 3, 2, 2, 2, 2105,
	2092, 3, 2, 2, 2, 2105, 2106, 3, 2, 2, 2, 2106, 199, 3, 2, 2, 2, 2107,
	2110, 5, 108, 55, 2, 2108, 2110, 5, 118, 60, 2, 2109, 2107, 3, 2, 2, 2,
	2109, 2108, 3, 2, 2, 2, 2110, 201, 3, 2, 2, 2, 2111, 2115, 7, 78, 2, 2,
	2112, 2114, 7, 7, 2, 2, 2113, 2112, 3, 2, 2, 2, 2114, 2117, 3, 2, 2, 2,
	2115, 2113, 3, 2, 2, 2, 2115, 2116, 3, 2, 2, 2, 2116, 2122, 3, 2, 2, 2,
	2117, 2115, 3, 2, 2, 2, 2118, 2119, 7, 11, 2, 2, 2119, 2120, 5, 118, 60,
	2, 2120, 2121, 7, 12, 2, 2, 2121, 2123, 3, 2, 2, 2, 2122, 2118, 3, 2, 2,
	2, 2122, 2123, 3, 2, 2, 2, 2123, 2127, 3, 2, 2, 2, 2124, 2126, 7, 7, 2,
	2, 2125, 2124, 3, 2, 2, 2, 2126, 2129, 3, 2, 2, 2, 2127, 2125, 3, 2, 2,
	2, 2127, 2128, 3, 2, 2, 2, 2128, 2130, 3, 2, 2, 2, 2129, 2127, 3, 2, 2,
	2, 2130, 2134, 7, 15, 2, 2, 2131, 2133, 7, 7, 2, 2, 2132, 2131, 3, 2, 2,
	2, 2133, 2136, 3, 2, 2, 2, 2134, 2132, 3, 2, 2, 2, 2134, 2135, 3, 2, 2,
	2, 2135, 2146, 3, 2, 2, 2, 2136, 2134, 3, 2, 2, 2, 2137, 2141, 5, 204,
	103, 2, 2138, 2140, 7, 7, 2, 2, 2139, 2138, 3, 2, 2, 2, 2140, 2143, 3,
	2, 2, 2, 2141, 2139, 3, 2, 2, 2, 2141, 2142, 3, 2, 2, 2, 2142, 2145, 3,
	2, 2, 2, 2143, 2141, 3, 2, 2, 2, 2144, 2137, 3, 2, 2, 2, 2145, 2148, 3,
	2, 2, 2, 2146, 2144, 3, 2, 2, 2, 2146, 2147, 3, 2, 2, 2, 2147, 2152, 3,
	2, 2, 2, 2148, 2146, 3, 2, 2, 2, 2149, 2151, 7, 7, 2, 2, 2150, 2149, 3,
	2, 2, 2, 2151, 2154, 3, 2, 2, 2, 2152, 2150, 3, 2, 2, 2, 2152, 2153, 3,
	2, 2, 2, 2153, 2155, 3, 2, 2, 2, 2154, 2152, 3, 2, 2, 2, 2155, 2156, 7,
	16, 2, 2, 2156, 203, 3, 2, 2, 2, 2157, 2174, 5, 206, 104, 2, 2158, 2160,
	7, 7, 2, 2, 2159, 2158, 3, 2, 2, 2, 2160, 2163, 3, 2, 2, 2, 2161, 2159,
	3, 2, 2, 2, 2161, 2162, 3, 2, 2, 2, 2162, 2164, 3, 2, 2, 2, 2163, 2161,
	3, 2, 2, 2, 2164, 2168, 7, 10, 2, 2, 2165, 2167, 7, 7, 2, 2, 2166, 2165,
	3, 2, 2, 2, 2167, 2170, 3, 2, 2, 2, 2168, 2166, 3, 2, 2, 2, 2168, 2169,
	3, 2, 2, 2, 2169, 2171, 3, 2, 2, 2, 2170, 2168, 3, 2, 2, 2, 2171, 2173,
	5, 206, 104, 2, 2172, 2161, 3, 2, 2, 2, 2173, 2176, 3, 2, 2, 2, 2174, 2172,
	3, 2, 2, 2, 2174, 2175, 3, 2, 2, 2, 2175, 2180, 3, 2, 2, 2, 2176, 2174,
	3, 2, 2, 2, 2177, 2179, 7, 7, 2, 2, 2178, 2177, 3, 2, 2, 2, 2179, 2182,
	3, 2, 2, 2, 2180, 2178, 3, 2, 2, 2, 2180, 2181, 3, 2, 2, 2, 2181, 2183,
	3, 2, 2, 2, 2182, 2180, 3, 2, 2, 2, 2183, 2187, 7, 35, 2, 2, 2184, 2186,
	7, 7, 2, 2, 2185, 2184, 3, 2, 2, 2, 2186, 2189, 3, 2, 2, 2, 2187, 2185,
	3, 2, 2, 2, 2187, 2188, 3, 2, 2, 2, 2188, 2190, 3, 2, 2, 2, 2189, 2187,
	3, 2, 2, 2, 2190, 2192, 5, 200, 101, 2, 2191, 2193, 5, 290, 146, 2, 2192,
	2191, 3, 2, 2, 2, 2192, 2193, 3, 2, 2, 2, 2193, 2210, 3, 2, 2, 2, 2194,
	2198, 7, 77, 2, 2, 2195, 2197, 7, 7, 2, 2, 2196, 2195, 3, 2, 2, 2, 2197,
	2200, 3, 2, 2, 2, 2198, 2196, 3, 2, 2, 2, 2198, 2199, 3, 2, 2, 2, 2199,
	2201, 3, 2, 2, 2, 2200, 2198, 3, 2, 2, 2, 2201, 2205, 7, 35, 2, 2, 2202,
	2204, 7, 7, 2, 2, 2203, 2202, 3, 2, 2, 2, 2204, 2207, 3, 2, 2, 2, 2205,
	2203, 3, 2, 2, 2, 2205, 2206, 3, 2, 2, 2, 2206, 2208, 3, 2, 2, 2, 2207,
	2205, 3, 2, 2, 2, 2208, 2210, 5, 200, 101, 2, 2209, 2157, 3, 2, 2, 2, 2209,
	2194, 3, 2, 2, 2, 2210, 205, 3, 2, 2, 2, 2211, 2215, 5, 118, 60, 2, 2212,
	2215, 5, 208, 105, 2, 2213, 2215, 5, 210, 106, 2, 2214, 2211, 3, 2, 2,
	2, 2214, 2212, 3, 2, 2, 2, 2214, 2213, 3, 2, 2, 2, 2215, 207, 3, 2, 2,
	2, 2216, 2220, 5, 236, 119, 2, 2217, 2219, 7, 7, 2, 2, 2218, 2217, 3, 2,
	2, 2, 2219, 2222, 3, 2, 2, 2, 2220, 2218, 3, 2, 2, 2, 2220, 2221, 3, 2,
	2, 2, 2221, 2223, 3, 2, 2, 2, 2222, 2220, 3, 2, 2, 2, 2223, 2224, 5, 118,
	60, 2, 2224, 209, 3, 2, 2, 2, 2225, 2229, 5, 238, 120, 2, 2226, 2228, 7,
	7, 2, 2, 2227, 2226, 3, 2, 2, 2, 2228, 2231, 3, 2, 2, 2, 2229, 2227, 3,
	2, 2, 2, 2229, 2230, 3, 2, 2, 2, 2230, 2232, 3, 2, 2, 2, 2231, 2229, 3,
	2, 2, 2, 2232, 2233, 5, 84, 43, 2, 2233, 211, 3, 2, 2, 2, 2234, 2238, 7,
	79, 2, 2, 2235, 2237, 7, 7, 2, 2, 2236, 2235, 3, 2, 2, 2, 2237, 2240, 3,
	2, 2, 2, 2238, 2236, 3, 2, 2, 2, 2238, 2239, 3, 2, 2, 2, 2239, 2241, 3,
	2, 2, 2, 2240, 2238, 3, 2, 2, 2, 2241, 2251, 5, 108, 55, 2, 2242, 2244,
	7, 7, 2, 2, 2243, 2242, 3, 2, 2, 2, 2244, 2247, 3, 2, 2, 2, 2245, 2243,
	3, 2, 2, 2, 2245, 2246, 3, 2, 2, 2, 2246, 2248, 3, 2, 2, 2, 2247, 2245,
	3, 2, 2, 2, 2248, 2250, 5, 214, 108, 2, 2249, 2245, 3, 2, 2, 2, 2250, 2253,
	3, 2, 2, 2, 2251, 2249, 3, 2, 2, 2, 2251, 2252, 3, 2, 2, 2, 2252, 2261,
	3, 2, 2, 2, 2253, 2251, 3, 2, 2, 2, 2254, 2256, 7, 7, 2, 2, 2255, 2254,
	3, 2, 2, 2, 2256, 2259, 3, 2, 2, 2, 2257, 2255, 3, 2, 2, 2, 2257, 2258,
	3, 2, 2, 2, 2258, 2260, 3, 2, 2, 2, 2259, 2257, 3, 2, 2, 2, 2260, 2262,
	5, 216, 109, 2, 2261, 2257, 3, 2, 2, 2, 2261, 2262, 3, 2, 2, 2, 2262, 213,
	3, 2, 2, 2, 2263, 2267, 7, 80, 2, 2, 2264, 2266, 7, 7, 2, 2, 2265, 2264,
	3, 2, 2, 2, 2266, 2269, 3, 2, 2, 2, 2267, 2265, 3, 2, 2, 2, 2267, 2268,
	3, 2, 2, 2, 2268, 2270, 3, 2, 2, 2, 2269, 2267, 3, 2, 2, 2, 2270, 2274,
	7, 11, 2, 2, 2271, 2273, 5, 276, 139, 2, 2272, 2271, 3, 2, 2, 2, 2273,
	2276, 3, 2, 2, 2, 2274, 2272, 3, 2, 2, 2, 2274, 2275, 3, 2, 2, 2, 2275,
	2277, 3, 2, 2, 2, 2276, 2274, 3, 2, 2, 2, 2277, 2278, 5, 288, 145, 2, 2278,
	2279, 7, 27, 2, 2, 2279, 2280, 5, 98, 50, 2, 2280, 2284, 7, 12, 2, 2, 2281,
	2283, 7, 7, 2, 2, 2282, 2281, 3, 2, 2, 2, 2283, 2286, 3, 2, 2, 2, 2284,
	2282, 3, 2, 2, 2, 2284, 2285, 3, 2, 2, 2, 2285, 2287, 3, 2, 2, 2, 2286,
	2284, 3, 2, 2, 2, 2287, 2288, 5, 108, 55, 2, 2288, 215, 3, 2, 2, 2, 2289,
	2293, 7, 81, 2, 2, 2290, 2292, 7, 7, 2, 2, 2291, 2290, 3, 2, 2, 2, 2292,
	2295, 3, 2, 2, 2, 2293, 2291, 3, 2, 2, 2, 2293, 2294, 3, 2, 2, 2, 2294,
	2296, 3, 2, 2, 2, 2295, 2293, 3, 2, 2, 2, 2296, 2297, 5, 108, 55, 2, 2297,
	217, 3, 2, 2, 2, 2298, 2302, 5, 220, 111, 2, 2299, 2302, 5, 222, 112, 2,
	2300, 2302, 5, 224, 113, 2, 2301, 2298, 3, 2, 2, 2, 2301, 2299, 3, 2, 2,
	2, 2301, 2300, 3, 2, 2, 2, 2302, 219, 3, 2, 2, 2, 2303, 2307, 7, 82, 2,
	2, 2304, 2306, 7, 7, 2, 2, 2305, 2304, 3, 2, 2, 2, 2306, 2309, 3, 2, 2,
	2, 2307, 2305, 3, 2, 2, 2, 2307, 2308, 3, 2, 2, 2, 2308, 2310, 3, 2, 2,
	2, 2309, 2307, 3, 2, 2, 2, 2310, 2314, 7, 11, 2, 2, 2311, 2313, 5, 276,
	139, 2, 2312, 2311, 3, 2, 2, 2, 2313, 2316, 3, 2, 2, 2, 2314, 2312, 3,
	2, 2, 2, 2314, 2315, 3, 2, 2, 2, 2315, 2319, 3, 2, 2, 2, 2316, 2314, 3,
	2, 2, 2, 2317, 2320, 5, 72, 37, 2, 2318, 2320, 5, 70, 36, 2, 2319, 2317,
	3, 2, 2, 2, 2319, 2318, 3, 2, 2, 2, 2320, 2321, 3, 2, 2, 2, 2321, 2322,
	7, 91, 2, 2, 2322, 2323, 5, 118, 60, 2, 2323, 2327, 7, 12, 2, 2, 2324,
	2326, 7, 7, 2, 2, 2325, 2324, 3, 2, 2, 2, 2326, 2329, 3, 2, 2, 2, 2327,
	2325, 3, 2, 2, 2, 2327, 2328, 3, 2, 2, 2, 2328, 2331, 3, 2, 2, 2, 2329,
	2327, 3, 2, 2, 2, 2330, 2332, 5, 200, 101, 2, 2331, 2330, 3, 2, 2, 2, 2331,
	2332, 3, 2, 2, 2, 2332, 221, 3, 2, 2, 2, 2333, 2337, 7, 84, 2, 2, 2334,
	2336, 7, 7, 2, 2, 2335, 2334, 3, 2, 2, 2, 2336, 2339, 3, 2, 2, 2, 2337,
	2335, 3, 2, 2, 2, 2337, 2338, 3, 2, 2, 2, 2338, 2340, 3, 2, 2, 2, 2339,
	2337, 3, 2, 2, 2, 2340, 2341, 7, 11, 2, 2, 2341, 2342, 5, 118, 60, 2, 2342,
	2346, 7, 12, 2, 2, 2343, 2345, 7, 7, 2, 2, 2344, 2343, 3, 2, 2, 2, 2345,
	2348, 3, 2, 2, 2, 2346, 2344, 3, 2, 2, 2, 2346, 2347, 3, 2, 2, 2, 2347,
	2350, 3, 2, 2, 2, 2348, 2346, 3, 2, 2, 2, 2349, 2351, 5, 200, 101, 2, 2350,
	2349, 3, 2, 2, 2, 2350, 2351, 3, 2, 2, 2, 2351, 223, 3, 2, 2, 2, 2352,
	2356, 7, 83, 2, 2, 2353, 2355, 7, 7, 2, 2, 2354, 2353, 3, 2, 2, 2, 2355,
	2358, 3, 2, 2, 2, 2356, 2354, 3, 2, 2, 2, 2356, 2357, 3, 2, 2, 2, 2357,
	2360, 3, 2, 2, 2, 2358, 2356, 3, 2, 2, 2, 2359, 2361, 5, 200, 101, 2, 2360,
	2359, 3, 2, 2, 2, 2360, 2361, 3, 2, 2, 2, 2361, 2365, 3, 2, 2, 2, 2362,
	2364, 7, 7, 2, 2, 2363, 2362, 3, 2, 2, 2, 2364, 2367, 3, 2, 2, 2, 2365,
	2363, 3, 2, 2, 2, 2365, 2366, 3, 2, 2, 2, 2366, 2368, 3, 2, 2, 2, 2367,
	2365, 3, 2, 2, 2, 2368, 2372, 7, 84, 2, 2, 2369, 2371, 7, 7, 2, 2, 2370,
	2369, 3, 2, 2, 2, 2371, 2374, 3, 2, 2, 2, 2372, 2370, 3, 2, 2, 2, 2372,
	2373, 3, 2, 2, 2, 2373, 2375, 3, 2, 2, 2, 2374, 2372, 3, 2, 2, 2, 2375,
	2376, 7, 11, 2, 2, 2376, 2377, 5, 118, 60, 2, 2377, 2378, 7, 12, 2, 2,
	2378, 225, 3, 2, 2, 2, 2379, 2383, 7, 85, 2, 2, 2380, 2382, 7, 7, 2, 2,
	2381, 2380, 3, 2, 2, 2, 2382, 2385, 3, 2, 2, 2, 2383, 2381, 3, 2, 2, 2,
	2383, 2384, 3, 2, 2, 2, 2384, 2386, 3, 2, 2, 2, 2385, 2383, 3, 2, 2, 2,
	2386, 2396, 5, 118, 60, 2, 2387, 2389, 9, 7, 2, 2, 2388, 2390, 5, 118,
	60, 2, 2389, 2388, 3, 2, 2, 2, 2389, 2390, 3, 2, 2, 2, 2390, 2396, 3, 2,
	2, 2, 2391, 2396, 7, 87, 2, 2, 2392, 2396, 7, 56, 2, 2, 2393, 2396, 7,
	88, 2, 2, 2394, 2396, 7, 57, 2, 2, 2395, 2379, 3, 2, 2, 2, 2395, 2387,
	3, 2, 2, 2, 2395, 2391, 3, 2, 2, 2, 2395, 2392, 3, 2, 2, 2, 2395, 2393,
	3, 2, 2, 2, 2395, 2394, 3, 2, 2, 2, 2396, 227, 3, 2, 2, 2, 2397, 2407,
	5, 98, 50, 2, 2398, 2402, 7, 43, 2, 2, 2399, 2401, 7, 7, 2, 2, 2400, 2399,
	3, 2, 2, 2, 2401, 2404, 3, 2, 2, 2, 2402, 2400, 3, 2, 2, 2, 2402, 2403,
	3, 2, 2, 2, 2403, 2406, 3, 2, 2, 2, 2404, 2402, 3, 2, 2, 2, 2405, 2398,
	3, 2, 2, 2, 2406, 2409, 3, 2, 2, 2, 2407, 2405, 3, 2, 2, 2, 2407, 2408,
	3, 2, 2, 2, 2408, 2411, 3, 2, 2, 2, 2409, 2407, 3, 2, 2, 2, 2410, 2397,
	3, 2, 2, 2, 2410, 2411, 3, 2, 2, 2, 2411, 2415, 3, 2, 2, 2, 2412, 2414,
	7, 7, 2, 2, 2413, 2412, 3, 2, 2, 2, 2414, 2417, 3, 2, 2, 2, 2415, 2413,
	3, 2, 2, 2, 2415, 2416, 3, 2, 2, 2, 2416, 2418, 3, 2, 2, 2, 2417, 2415,
	3, 2, 2, 2, 2418, 2422, 9, 8, 2, 2, 2419, 2421, 7, 7, 2, 2, 2420, 2419,
	3, 2, 2, 2, 2421, 2424, 3, 2, 2, 2, 2422, 2420, 3, 2, 2, 2, 2422, 2423,
	3, 2, 2, 2, 2423, 2427, 3, 2, 2, 2, 2424, 2422, 3, 2, 2, 2, 2425, 2428,
	5, 286, 144, 2, 2426, 2428, 7, 61, 2, 2, 2427, 2425, 3, 2, 2, 2, 2427,
	2426, 3, 2, 2, 2, 2428, 229, 3, 2, 2, 2, 2429, 2430, 9, 9, 2, 2, 2430,
	231, 3, 2, 2, 2, 2431, 2432, 9, 10, 2, 2, 2432, 233, 3, 2, 2, 2, 2433,
	2434, 9, 11, 2, 2, 2434, 235, 3, 2, 2, 2, 2435, 2436, 9, 12, 2, 2, 2436,
	237, 3, 2, 2, 2, 2437, 2438, 9, 13, 2, 2, 2438, 239, 3, 2, 2, 2, 2439,
	2440, 9, 14, 2, 2, 2440, 241, 3, 2, 2, 2, 2441, 2442, 9, 15, 2, 2, 2442,
	243, 3, 2, 2, 2, 2443, 2444, 9, 16, 2, 2, 2444, 245, 3, 2, 2, 2, 2445,
	2453, 7, 22, 2, 2, 2446, 2453, 7, 23, 2, 2, 2447, 2453, 7, 20, 2, 2, 2448,
	2453, 7, 21, 2, 2, 2449, 2453, 7, 26, 2, 2, 2450, 2453, 5, 276, 139, 2,
	2451, 2453, 5, 274, 138, 2, 2452, 2445, 3, 2, 2, 2, 2452, 2446, 3, 2, 2,
	2, 2452, 2447, 3, 2, 2, 2, 2452, 2448, 3, 2, 2, 2, 2452, 2449, 3, 2, 2,
	2, 2452, 2450, 3, 2, 2, 2, 2452, 2451, 3, 2, 2, 2, 2453, 247, 3, 2, 2,
	2, 2454, 2470, 7, 22, 2, 2, 2455, 2470, 7, 23, 2, 2, 2456, 2457, 7, 26,
	2, 2, 2457, 2470, 7, 26, 2, 2, 2458, 2470, 5, 150, 76, 2, 2459, 2470, 5,
	154, 78, 2, 2460, 2462, 7, 7, 2, 2, 2461, 2460, 3, 2, 2, 2, 2462, 2465,
	3, 2, 2, 2, 2463, 2461, 3, 2, 2, 2, 2463, 2464, 3, 2, 2, 2, 2464, 2466,
	3, 2, 2, 2, 2465, 2463, 3, 2, 2, 2, 2466, 2467, 5, 250, 126, 2, 2467, 2468,
	5, 144, 73, 2, 2468, 2470, 3, 2, 2, 2, 2469, 2454, 3, 2, 2, 2, 2469, 2455,
	3, 2, 2, 2, 2469, 2456, 3, 2, 2, 2, 2469, 2458, 3, 2, 2, 2, 2469, 2459,
	3, 2, 2, 2, 2469, 2463, 3, 2, 2, 2, 2470, 249, 3, 2, 2, 2, 2471, 2475,
	7, 9, 2, 2, 2472, 2473, 7, 43, 2, 2, 2473, 2475, 7, 9, 2, 2, 2474, 2471,
	3, 2, 2, 2, 2474, 2472, 3, 2, 2, 2, 2475, 251, 3, 2, 2, 2, 2476, 2479,
	5, 276, 139, 2, 2477, 2479, 5, 254, 128, 2, 2478, 2476, 3, 2, 2, 2, 2478,
	2477, 3, 2, 2, 2, 2479, 2480, 3, 2, 2, 2, 2480, 2478, 3, 2, 2, 2, 2480,
	2481, 3, 2, 2, 2, 2481, 253, 3, 2, 2, 2, 2482, 2492, 5, 256, 129, 2, 2483,
	2492, 5, 258, 130, 2, 2484, 2492, 5, 260, 131, 2, 2485, 2492, 5, 262, 132,
	2, 2486, 2492, 5, 264, 133, 2, 2487, 2492, 5, 266, 134, 2, 2488, 2492,
	5, 268, 135, 2, 2489, 2492, 5, 270, 136, 2, 2490, 2492, 5, 272, 137, 2,
	2491, 2482, 3, 2, 2, 2, 2491, 2483, 3, 2, 2, 2, 2491, 2484, 3, 2, 2, 2,
	2491, 2485, 3, 2, 2, 2, 2491, 2486, 3, 2, 2, 2, 2491, 2487, 3, 2, 2, 2,
	2491, 2488, 3, 2, 2, 2, 2491, 2489, 3, 2, 2, 2, 2491, 2490, 3, 2, 2, 2,
	2492, 2496, 3, 2, 2, 2, 2493, 2495, 7, 7, 2, 2, 2494, 2493, 3, 2, 2, 2,
	2495, 2498, 3, 2, 2, 2, 2496, 2494, 3, 2, 2, 2, 2496, 2497, 3, 2, 2, 2,
	2497, 255, 3, 2, 2, 2, 2498, 2496, 3, 2, 2, 2, 2499, 2500, 9, 17, 2, 2,
	2500, 257, 3, 2, 2, 2, 2501, 2502, 9, 18, 2, 2, 2502, 259, 3, 2, 2, 2,
	2503, 2504, 9, 19, 2, 2, 2504, 261, 3, 2, 2, 2, 2505, 2506, 9, 20, 2, 2,
	2506, 263, 3, 2, 2, 2, 2507, 2508, 9, 21, 2, 2, 2508, 265, 3, 2, 2, 2,
	2509, 2510, 7, 125, 2, 2, 2510, 267, 3, 2, 2, 2, 2511, 2512, 9, 22, 2,
	2, 2512, 269, 3, 2, 2, 2, 2513, 2514, 9, 23, 2, 2, 2514, 271, 3, 2, 2,
	2, 2515, 2516, 7, 130, 2, 2, 2516, 273, 3, 2, 2, 2, 2517, 2521, 7, 144,
	2, 2, 2518, 2520, 7, 7, 2, 2, 2519, 2518, 3, 2, 2, 2, 2520, 2523, 3, 2,
	2, 2, 2521, 2519, 3, 2, 2, 2, 2521, 2522, 3, 2, 2, 2, 2522, 275, 3, 2,
	2, 2, 2523, 2521, 3, 2, 2, 2, 2524, 2527, 5, 278, 140, 2, 2525, 2527, 5,
	280, 141, 2, 2526, 2524, 3, 2, 2, 2, 2526, 2525, 3, 2, 2, 2, 2527, 2531,
	3, 2, 2, 2, 2528, 2530, 7, 7, 2, 2, 2529, 2528, 3, 2, 2, 2, 2530, 2533,
	3, 2, 2, 2, 2531, 2529, 3, 2, 2, 2, 2531, 2532, 3, 2, 2, 2, 2532, 277,
	3, 2, 2, 2, 2533, 2531, 3, 2, 2, 2, 2534, 2538, 5, 282, 142, 2, 2535, 2537,
	7, 7, 2, 2, 2536, 2535, 3, 2, 2, 2, 2537, 2540, 3, 2, 2, 2, 2538, 2536,
	3, 2, 2, 2, 2538, 2539, 3, 2, 2, 2, 2539, 2541, 3, 2, 2, 2, 2540, 2538,
	3, 2, 2, 2, 2541, 2545, 7, 27, 2, 2, 2542, 2544, 7, 7, 2, 2, 2543, 2542,
	3, 2, 2, 2, 2544, 2547, 3, 2, 2, 2, 2545, 2543, 3, 2, 2, 2, 2545, 2546,
	3, 2, 2, 2, 2546, 2548, 3, 2, 2, 2, 2547, 2545, 3, 2, 2, 2, 2548, 2549,
	5, 284, 143, 2, 2549, 2570, 3, 2, 2, 2, 2550, 2558, 7, 143, 2, 2, 2551,
	2553, 7, 7, 2, 2, 2552, 2551, 3, 2, 2, 2, 2553, 2556, 3, 2, 2, 2, 2554,
	2552, 3, 2, 2, 2, 2554, 2555, 3, 2, 2, 2, 2555, 2557, 3, 2, 2, 2, 2556,
	2554, 3, 2, 2, 2, 2557, 2559, 5, 158, 80, 2, 2558, 2554, 3, 2, 2, 2, 2558,
	2559, 3, 2, 2, 2, 2559, 2567, 3, 2, 2, 2, 2560, 2562, 7, 7, 2, 2, 2561,
	2560, 3, 2, 2, 2, 2562, 2565, 3, 2, 2, 2, 2563, 2561, 3, 2, 2, 2, 2563,
	2564, 3, 2, 2, 2, 2564, 2566, 3, 2, 2, 2, 2565, 2563, 3, 2, 2, 2, 2566,
	2568, 5, 156, 79, 2, 2567, 2563, 3, 2, 2, 2, 2567, 2568, 3, 2, 2, 2, 2568,
	2570, 3, 2, 2, 2, 2569, 2534, 3, 2, 2, 2, 2569, 2550, 3, 2, 2, 2, 2570,
	279, 3, 2, 2, 2, 2571, 2572, 5, 282, 142, 2, 2572, 2573, 7, 27, 2, 2, 2573,
	2575, 7, 13, 2, 2, 2574, 2576, 5, 284, 143, 2, 2575, 2574, 3, 2, 2, 2,
	2576, 2577, 3, 2, 2, 2, 2577, 2575, 3, 2, 2, 2, 2577, 2578, 3, 2, 2, 2,
	2578, 2579, 3, 2, 2, 2, 2579, 2580, 7, 14, 2, 2, 2580, 2591, 3, 2, 2, 2,
	2581, 2582, 7, 42, 2, 2, 2582, 2584, 7, 13, 2, 2, 2583, 2585, 5, 284, 143,
	2, 2584, 2583, 3, 2, 2, 2, 2585, 2586, 3, 2, 2, 2, 2586, 2584, 3, 2, 2,
	2, 2586, 2587, 3, 2, 2, 2, 2587, 2588, 3, 2, 2, 2, 2588, 2589, 7, 14, 2,
	2, 2589, 2591, 3, 2, 2, 2, 2590, 2571, 3, 2, 2, 2, 2590, 2581, 3, 2, 2,
	2, 2591, 281, 3, 2, 2, 2, 2592, 2593, 9, 24, 2, 2, 2593, 283, 3, 2, 2,
	2, 2594, 2596, 5, 286, 144, 2, 2595, 2597, 5, 158, 80, 2, 2596, 2595, 3,
	2, 2, 2, 2596, 2597, 3, 2, 2, 2, 2597, 2599, 3, 2, 2, 2, 2598, 2600, 5,
	156, 79, 2, 2599, 2598, 3, 2, 2, 2, 2599, 2600, 3, 2, 2, 2, 2600, 285,
	3, 2, 2, 2, 2601, 2612, 5, 288, 145, 2, 2602, 2604, 7, 7, 2, 2, 2603, 2602,
	3, 2, 2, 2, 2604, 2607, 3, 2, 2, 2, 2605, 2603, 3, 2, 2, 2, 2605, 2606,
	3, 2, 2, 2, 2606, 2608, 3, 2, 2, 2, 2607, 2605, 3, 2, 2, 2, 2608, 2609,
	7, 9, 2, 2, 2609, 2611, 5, 288, 145, 2, 2610, 2605, 3, 2, 2, 2, 2611, 2614,
	3, 2, 2, 2, 2612, 2610, 3, 2, 2, 2, 2612, 2613, 3, 2, 2, 2, 2613, 287,
	3, 2, 2, 2, 2614, 2612, 3, 2, 2, 2, 2615, 2616, 9, 25, 2, 2, 2616, 289,
	3, 2, 2, 2, 2617, 2619, 7, 7, 2, 2, 2618, 2617, 3, 2, 2, 2, 2619, 2620,
	3, 2, 2, 2, 2620, 2618, 3, 2, 2, 2, 2620, 2621, 3, 2, 2, 2, 2621, 2636,
	3, 2, 2, 2, 2622, 2624, 7, 7, 2, 2, 2623, 2622, 3, 2, 2, 2, 2624, 2627,
	3, 2, 2, 2, 2625, 2623, 3, 2, 2, 2, 2625, 2626, 3, 2, 2, 2, 2626, 2628,
	3, 2, 2, 2, 2627, 2625, 3, 2, 2, 2, 2628, 2632, 7, 28, 2, 2, 2629, 2631,
	7, 7, 2, 2, 2630, 2629, 3, 2, 2, 2, 2631, 2634, 3, 2, 2, 2, 2632, 2630,
	3, 2, 2, 2, 2632, 2633, 3, 2, 2, 2, 2633, 2636, 3, 2, 2, 2, 2634, 2632,
	3, 2, 2, 2, 2635, 2618, 3, 2, 2, 2, 2635, 2625, 3, 2, 2, 2, 2636, 291,
	3, 2, 2, 2, 2637, 2638, 9, 26, 2, 2, 2638, 293, 3, 2, 2, 2, 399, 297, 304,
	311, 314, 318, 321, 328, 335, 342, 345, 349, 352, 357, 365, 373, 378, 381,
	385, 388, 393, 395, 400, 408, 411, 421, 424, 430, 437, 441, 446, 450, 455,
	462, 466, 471, 475, 480, 487, 491, 494, 500, 503, 513, 516, 521, 524, 531,
	536, 543, 550, 556, 562, 571, 578, 587, 593, 599, 612, 617, 623, 629, 635,
	642, 649, 653, 658, 662, 668, 676, 680, 686, 690, 695, 702, 708, 711, 716,
	725, 730, 733, 739, 743, 748, 752, 757, 761, 764, 770, 777, 782, 787, 791,
	796, 800, 805, 812, 819, 823, 828, 832, 837, 841, 849, 852, 857, 862, 873,
	877, 880, 886, 893, 897, 902, 909, 913, 918, 922, 925, 931, 935, 941, 945,
	950, 957, 961, 966, 970, 973, 979, 983, 988, 995, 1000, 1005, 1010, 1015,
	1019, 1024, 1031, 1035, 1041, 1047, 1049, 1057, 1065, 1068, 1072, 1078,
	1086, 1093, 1097, 1102, 1110, 1114, 1116, 1119, 1123, 1129, 1135, 1137,
	1142, 1148, 1153, 1156, 1162, 1169, 1173, 1178, 1185, 1194, 1201, 1208,
	1214, 1220, 1226, 1231, 1238, 1245, 1249, 1252, 1258, 1265, 1268, 1270,
	1278, 1283, 1289, 1297, 1303, 1310, 1313, 1319, 1326, 1334, 1340, 1347,
	1353, 1360, 1364, 1369, 1374, 1378, 1387, 1394, 1401, 1407, 1413, 1420,
	1427, 1439, 1446, 1449, 1453, 1456, 1460, 1465, 1471, 1479, 1486, 1494,
	1501, 1508, 1514, 1521, 1528, 1534, 1542, 1549, 1557, 1562, 1569, 1576,
	1582, 1587, 1593, 1600, 1606, 1614, 1621, 1629, 1635, 1643, 1650, 1658,
	1665, 1672, 1680, 1686, 1693, 1698, 1713, 1721, 1726, 1733, 1739, 1741,
	1746, 1750, 1755, 1766, 1769, 1779, 1782, 1790, 1797, 1804, 1810, 1816,
	1820, 1825, 1831, 1838, 1841, 1844, 1849, 1863, 1867, 1872, 1874, 1884,
	1886, 1906, 1913, 1920, 1929, 1936, 1943, 1950, 1955, 1958, 1963, 1970,
	1976, 1984, 1991, 1995, 1997, 2003, 2010, 2014, 2019, 2026, 2032, 2039,
	2046, 2053, 2058, 2061, 2065, 2071, 2080, 2084, 2087, 2092, 2099, 2103,
	2105, 2109, 2115, 2122, 2127, 2134, 2141, 2146, 2152, 2161, 2168, 2174,
	2180, 2187, 2192, 2198, 2205, 2209, 2214, 2220, 2229, 2238, 2245, 2251,
	2257, 2261, 2267, 2274, 2284, 2293, 2301, 2307, 2314, 2319, 2327, 2331,
	2337, 2346, 2350, 2356, 2360, 2365, 2372, 2383, 2389, 2395, 2402, 2407,
	2410, 2415, 2422, 2427, 2452, 2463, 2469, 2474, 2478, 2480, 2491, 2496,
	2521, 2526, 2531, 2538, 2545, 2554, 2558, 2563, 2567, 2569, 2577, 2586,
	2590, 2596, 2599, 2605, 2612, 2620, 2625, 2632, 2635,
}
var literalNames = []string{
	"", "", "", "", "", "", "'...'", "'.'", "','", "'('", "", "'['", "", "'{'",
	"'}'", "'*'", "'%'", "'/'", "'+'", "'-'", "'++'", "'--'", "'&&'", "'||'",
	"'!'", "':'", "';'", "'='", "'+='", "'-='", "'*='", "'/='", "'%='", "'->'",
	"'=>'", "'..'", "'::'", "'?::'", "';;'", "'#'", "'@'", "'?'", "'?:'", "'<'",
	"'>'", "'<='", "'>='", "'!='", "'!=='", "'as?'", "'=='", "'==='", "'''",
	"", "", "", "'@file'", "'package'", "'import'", "'class'", "'interface'",
	"'fun'", "'object'", "'val'", "'var'", "'typealias'", "'constructor'",
	"'by'", "'companion'", "'init'", "'this'", "'super'", "'typeof'", "'where'",
	"'if'", "'else'", "'when'", "'try'", "'catch'", "'finally'", "'for'", "'do'",
	"'while'", "'throw'", "'return'", "'continue'", "'break'", "'as'", "'is'",
	"'in'", "", "", "'out'", "'@field'", "'@property'", "'@get'", "'@set'",
	"'get'", "'set'", "'@receiver'", "'@param'", "'@setparam'", "'@delegate'",
	"'dynamic'", "'public'", "'private'", "'protected'", "'internal'", "'enum'",
	"'sealed'", "'annotation'", "'data'", "'inner'", "'tailrec'", "'operator'",
	"'inline'", "'infix'", "'external'", "'suspend'", "'override'", "'abstract'",
	"'final'", "'open'", "'const'", "'lateinit'", "'vararg'", "'noinline'",
	"'crossinline'", "'reified'", "", "'\"\"\"'", "", "", "", "", "", "", "",
	"", "'null'",
}
var symbolicNames = []string{
	"", "ShebangLine", "DelimitedComment", "LineComment", "WS", "NL", "RESERVED",
	"DOT", "COMMA", "LPAREN", "RPAREN", "LSQUARE", "RSQUARE", "LCURL", "RCURL",
	"MULT", "MOD", "DIV", "ADD", "SUB", "INCR", "DECR", "CONJ", "DISJ", "EXCL",
	"COLON", "SEMICOLON", "ASSIGNMENT", "ADD_ASSIGNMENT", "SUB_ASSIGNMENT",
	"MULT_ASSIGNMENT", "DIV_ASSIGNMENT", "MOD_ASSIGNMENT", "ARROW", "DOUBLE_ARROW",
	"RANGE", "COLONCOLON", "Q_COLONCOLON", "DOUBLE_SEMICOLON", "HASH", "AT",
	"QUEST", "ELVIS", "LANGLE", "RANGLE", "LE", "GE", "EXCL_EQ", "EXCL_EQEQ",
	"AS_SAFE", "EQEQ", "EQEQEQ", "SINGLE_QUOTE", "RETURN_AT", "CONTINUE_AT",
	"BREAK_AT", "FILE", "PACKAGE", "IMPORT", "CLASS", "INTERFACE", "FUN", "OBJECT",
	"VAL", "VAR", "TYPE_ALIAS", "CONSTRUCTOR", "BY", "COMPANION", "INIT", "THIS",
	"SUPER", "TYPEOF", "WHERE", "IF", "ELSE", "WHEN", "TRY", "CATCH", "FINALLY",
	"FOR", "DO", "WHILE", "THROW", "RETURN", "CONTINUE", "BREAK", "AS", "IS",
	"IN", "NOT_IS", "NOT_IN", "OUT", "FIELD", "PROPERTY", "GET", "SET", "GETTER",
	"SETTER", "RECEIVER", "PARAM", "SETPARAM", "DELEGATE", "DYNAMIC", "PUBLIC",
	"PRIVATE", "PROTECTED", "INTERNAL", "ENUM", "SEALED", "ANNOTATION", "DATA",
	"INNER", "TAILREC", "OPERATOR", "INLINE", "INFIX", "EXTERNAL", "SUSPEND",
	"OVERRIDE", "ABSTRACT", "FINAL", "OPEN", "CONST", "LATEINIT", "VARARG",
	"NOINLINE", "CROSSINLINE", "REIFIED", "QUOTE_OPEN", "TRIPLE_QUOTE_OPEN",
	"RealLiteral", "FloatLiteral", "DoubleLiteral", "LongLiteral", "IntegerLiteral",
	"HexLiteral", "BinLiteral", "BooleanLiteral", "NullLiteral", "Identifier",
	"LabelReference", "LabelDefinition", "FieldIdentifier", "CharacterLiteral",
	"UNICODE_CLASS_LL", "UNICODE_CLASS_LM", "UNICODE_CLASS_LO", "UNICODE_CLASS_LT",
	"UNICODE_CLASS_LU", "UNICODE_CLASS_ND", "UNICODE_CLASS_NL", "Inside_Comment",
	"Inside_WS", "Inside_NL", "QUOTE_CLOSE", "LineStrRef", "LineStrText", "LineStrEscapedChar",
	"LineStrExprStart", "TRIPLE_QUOTE_CLOSE", "MultiLineStringQuote", "MultiLineStrRef",
	"MultiLineStrText", "MultiLineStrEscapedChar", "MultiLineStrExprStart",
	"MultiLineNL", "StrExpr_IN", "StrExpr_Comment", "StrExpr_WS", "StrExpr_NL",
}

var ruleNames = []string{
	"kotlinFile", "script", "preamble", "fileAnnotations", "fileAnnotation",
	"packageHeader", "importList", "importHeader", "importAlias", "topLevelObject",
	"classDeclaration", "primaryConstructor", "classParameters", "classParameter",
	"delegationSpecifiers", "delegationSpecifier", "constructorInvocation",
	"explicitDelegation", "classBody", "classMemberDeclaration", "anonymousInitializer",
	"secondaryConstructor", "constructorDelegationCall", "enumClassBody", "enumEntries",
	"enumEntry", "functionDeclaration", "functionValueParameters", "functionValueParameter",
	"parameter", "functionBody", "objectDeclaration", "companionObject", "propertyDeclaration",
	"multiVariableDeclaration", "variableDeclaration", "getter", "setter",
	"typeAlias", "typeParameters", "typeParameter", "type", "typeModifierList",
	"parenthesizedType", "nullableType", "typeReference", "functionType", "functionTypeReceiver",
	"userType", "simpleUserType", "functionTypeParameters", "typeConstraints",
	"typeConstraint", "block", "statements", "statement", "blockLevelExpression",
	"declaration", "expression", "disjunction", "conjunction", "equalityComparison",
	"comparison", "namedInfix", "elvisExpression", "infixFunctionCall", "rangeExpression",
	"additiveExpression", "multiplicativeExpression", "typeRHS", "prefixUnaryExpression",
	"postfixUnaryExpression", "atomicExpression", "parenthesizedExpression",
	"callSuffix", "annotatedLambda", "arrayAccess", "valueArguments", "typeArguments",
	"typeProjection", "typeProjectionModifierList", "valueArgument", "literalConstant",
	"stringLiteral", "lineStringLiteral", "multiLineStringLiteral", "lineStringContent",
	"lineStringExpression", "multiLineStringContent", "multiLineStringExpression",
	"functionLiteral", "lambdaParameters", "lambdaParameter", "objectLiteral",
	"collectionLiteral", "thisExpression", "superExpression", "conditionalExpression",
	"ifExpression", "controlStructureBody", "whenExpression", "whenEntry",
	"whenCondition", "rangeTest", "typeTest", "tryExpression", "catchBlock",
	"finallyBlock", "loopExpression", "forExpression", "whileExpression", "doWhileExpression",
	"jumpExpression", "callableReference", "assignmentOperator", "equalityOperation",
	"comparisonOperator", "inOperator", "isOperator", "additiveOperator", "multiplicativeOperation",
	"typeOperation", "prefixUnaryOperation", "postfixUnaryOperation", "memberAccessOperator",
	"modifierList", "modifier", "classModifier", "memberModifier", "visibilityModifier",
	"varianceAnnotation", "functionModifier", "propertyModifier", "inheritanceModifier",
	"parameterModifier", "typeParameterModifier", "labelDefinition", "annotations",
	"annotation", "annotationList", "annotationUseSiteTarget", "unescapedAnnotation",
	"identifier", "simpleIdentifier", "semi", "anysemi",
}

type KotlinParser struct {
	*antlr.BaseParser
}

// NewKotlinParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *KotlinParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewKotlinParser(input antlr.TokenStream) *KotlinParser {
	this := new(KotlinParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "KotlinParser.g4"

	return this
}

// KotlinParser tokens.
const (
	KotlinParserEOF                     = antlr.TokenEOF
	KotlinParserShebangLine             = 1
	KotlinParserDelimitedComment        = 2
	KotlinParserLineComment             = 3
	KotlinParserWS                      = 4
	KotlinParserNL                      = 5
	KotlinParserRESERVED                = 6
	KotlinParserDOT                     = 7
	KotlinParserCOMMA                   = 8
	KotlinParserLPAREN                  = 9
	KotlinParserRPAREN                  = 10
	KotlinParserLSQUARE                 = 11
	KotlinParserRSQUARE                 = 12
	KotlinParserLCURL                   = 13
	KotlinParserRCURL                   = 14
	KotlinParserMULT                    = 15
	KotlinParserMOD                     = 16
	KotlinParserDIV                     = 17
	KotlinParserADD                     = 18
	KotlinParserSUB                     = 19
	KotlinParserINCR                    = 20
	KotlinParserDECR                    = 21
	KotlinParserCONJ                    = 22
	KotlinParserDISJ                    = 23
	KotlinParserEXCL                    = 24
	KotlinParserCOLON                   = 25
	KotlinParserSEMICOLON               = 26
	KotlinParserASSIGNMENT              = 27
	KotlinParserADD_ASSIGNMENT          = 28
	KotlinParserSUB_ASSIGNMENT          = 29
	KotlinParserMULT_ASSIGNMENT         = 30
	KotlinParserDIV_ASSIGNMENT          = 31
	KotlinParserMOD_ASSIGNMENT          = 32
	KotlinParserARROW                   = 33
	KotlinParserDOUBLE_ARROW            = 34
	KotlinParserRANGE                   = 35
	KotlinParserCOLONCOLON              = 36
	KotlinParserQ_COLONCOLON            = 37
	KotlinParserDOUBLE_SEMICOLON        = 38
	KotlinParserHASH                    = 39
	KotlinParserAT                      = 40
	KotlinParserQUEST                   = 41
	KotlinParserELVIS                   = 42
	KotlinParserLANGLE                  = 43
	KotlinParserRANGLE                  = 44
	KotlinParserLE                      = 45
	KotlinParserGE                      = 46
	KotlinParserEXCL_EQ                 = 47
	KotlinParserEXCL_EQEQ               = 48
	KotlinParserAS_SAFE                 = 49
	KotlinParserEQEQ                    = 50
	KotlinParserEQEQEQ                  = 51
	KotlinParserSINGLE_QUOTE            = 52
	KotlinParserRETURN_AT               = 53
	KotlinParserCONTINUE_AT             = 54
	KotlinParserBREAK_AT                = 55
	KotlinParserFILE                    = 56
	KotlinParserPACKAGE                 = 57
	KotlinParserIMPORT                  = 58
	KotlinParserCLASS                   = 59
	KotlinParserINTERFACE               = 60
	KotlinParserFUN                     = 61
	KotlinParserOBJECT                  = 62
	KotlinParserVAL                     = 63
	KotlinParserVAR                     = 64
	KotlinParserTYPE_ALIAS              = 65
	KotlinParserCONSTRUCTOR             = 66
	KotlinParserBY                      = 67
	KotlinParserCOMPANION               = 68
	KotlinParserINIT                    = 69
	KotlinParserTHIS                    = 70
	KotlinParserSUPER                   = 71
	KotlinParserTYPEOF                  = 72
	KotlinParserWHERE                   = 73
	KotlinParserIF                      = 74
	KotlinParserELSE                    = 75
	KotlinParserWHEN                    = 76
	KotlinParserTRY                     = 77
	KotlinParserCATCH                   = 78
	KotlinParserFINALLY                 = 79
	KotlinParserFOR                     = 80
	KotlinParserDO                      = 81
	KotlinParserWHILE                   = 82
	KotlinParserTHROW                   = 83
	KotlinParserRETURN                  = 84
	KotlinParserCONTINUE                = 85
	KotlinParserBREAK                   = 86
	KotlinParserAS                      = 87
	KotlinParserIS                      = 88
	KotlinParserIN                      = 89
	KotlinParserNOT_IS                  = 90
	KotlinParserNOT_IN                  = 91
	KotlinParserOUT                     = 92
	KotlinParserFIELD                   = 93
	KotlinParserPROPERTY                = 94
	KotlinParserGET                     = 95
	KotlinParserSET                     = 96
	KotlinParserGETTER                  = 97
	KotlinParserSETTER                  = 98
	KotlinParserRECEIVER                = 99
	KotlinParserPARAM                   = 100
	KotlinParserSETPARAM                = 101
	KotlinParserDELEGATE                = 102
	KotlinParserDYNAMIC                 = 103
	KotlinParserPUBLIC                  = 104
	KotlinParserPRIVATE                 = 105
	KotlinParserPROTECTED               = 106
	KotlinParserINTERNAL                = 107
	KotlinParserENUM                    = 108
	KotlinParserSEALED                  = 109
	KotlinParserANNOTATION              = 110
	KotlinParserDATA                    = 111
	KotlinParserINNER                   = 112
	KotlinParserTAILREC                 = 113
	KotlinParserOPERATOR                = 114
	KotlinParserINLINE                  = 115
	KotlinParserINFIX                   = 116
	KotlinParserEXTERNAL                = 117
	KotlinParserSUSPEND                 = 118
	KotlinParserOVERRIDE                = 119
	KotlinParserABSTRACT                = 120
	KotlinParserFINAL                   = 121
	KotlinParserOPEN                    = 122
	KotlinParserCONST                   = 123
	KotlinParserLATEINIT                = 124
	KotlinParserVARARG                  = 125
	KotlinParserNOINLINE                = 126
	KotlinParserCROSSINLINE             = 127
	KotlinParserREIFIED                 = 128
	KotlinParserQUOTE_OPEN              = 129
	KotlinParserTRIPLE_QUOTE_OPEN       = 130
	KotlinParserRealLiteral             = 131
	KotlinParserFloatLiteral            = 132
	KotlinParserDoubleLiteral           = 133
	KotlinParserLongLiteral             = 134
	KotlinParserIntegerLiteral          = 135
	KotlinParserHexLiteral              = 136
	KotlinParserBinLiteral              = 137
	KotlinParserBooleanLiteral          = 138
	KotlinParserNullLiteral             = 139
	KotlinParserIdentifier              = 140
	KotlinParserLabelReference          = 141
	KotlinParserLabelDefinition         = 142
	KotlinParserFieldIdentifier         = 143
	KotlinParserCharacterLiteral        = 144
	KotlinParserUNICODE_CLASS_LL        = 145
	KotlinParserUNICODE_CLASS_LM        = 146
	KotlinParserUNICODE_CLASS_LO        = 147
	KotlinParserUNICODE_CLASS_LT        = 148
	KotlinParserUNICODE_CLASS_LU        = 149
	KotlinParserUNICODE_CLASS_ND        = 150
	KotlinParserUNICODE_CLASS_NL        = 151
	KotlinParserInside_Comment          = 152
	KotlinParserInside_WS               = 153
	KotlinParserInside_NL               = 154
	KotlinParserQUOTE_CLOSE             = 155
	KotlinParserLineStrRef              = 156
	KotlinParserLineStrText             = 157
	KotlinParserLineStrEscapedChar      = 158
	KotlinParserLineStrExprStart        = 159
	KotlinParserTRIPLE_QUOTE_CLOSE      = 160
	KotlinParserMultiLineStringQuote    = 161
	KotlinParserMultiLineStrRef         = 162
	KotlinParserMultiLineStrText        = 163
	KotlinParserMultiLineStrEscapedChar = 164
	KotlinParserMultiLineStrExprStart   = 165
	KotlinParserMultiLineNL             = 166
	KotlinParserStrExpr_IN              = 167
	KotlinParserStrExpr_Comment         = 168
	KotlinParserStrExpr_WS              = 169
	KotlinParserStrExpr_NL              = 170
)

// KotlinParser rules.
const (
	KotlinParserRULE_kotlinFile                 = 0
	KotlinParserRULE_script                     = 1
	KotlinParserRULE_preamble                   = 2
	KotlinParserRULE_fileAnnotations            = 3
	KotlinParserRULE_fileAnnotation             = 4
	KotlinParserRULE_packageHeader              = 5
	KotlinParserRULE_importList                 = 6
	KotlinParserRULE_importHeader               = 7
	KotlinParserRULE_importAlias                = 8
	KotlinParserRULE_topLevelObject             = 9
	KotlinParserRULE_classDeclaration           = 10
	KotlinParserRULE_primaryConstructor         = 11
	KotlinParserRULE_classParameters            = 12
	KotlinParserRULE_classParameter             = 13
	KotlinParserRULE_delegationSpecifiers       = 14
	KotlinParserRULE_delegationSpecifier        = 15
	KotlinParserRULE_constructorInvocation      = 16
	KotlinParserRULE_explicitDelegation         = 17
	KotlinParserRULE_classBody                  = 18
	KotlinParserRULE_classMemberDeclaration     = 19
	KotlinParserRULE_anonymousInitializer       = 20
	KotlinParserRULE_secondaryConstructor       = 21
	KotlinParserRULE_constructorDelegationCall  = 22
	KotlinParserRULE_enumClassBody              = 23
	KotlinParserRULE_enumEntries                = 24
	KotlinParserRULE_enumEntry                  = 25
	KotlinParserRULE_functionDeclaration        = 26
	KotlinParserRULE_functionValueParameters    = 27
	KotlinParserRULE_functionValueParameter     = 28
	KotlinParserRULE_parameter                  = 29
	KotlinParserRULE_functionBody               = 30
	KotlinParserRULE_objectDeclaration          = 31
	KotlinParserRULE_companionObject            = 32
	KotlinParserRULE_propertyDeclaration        = 33
	KotlinParserRULE_multiVariableDeclaration   = 34
	KotlinParserRULE_variableDeclaration        = 35
	KotlinParserRULE_getter                     = 36
	KotlinParserRULE_setter                     = 37
	KotlinParserRULE_typeAlias                  = 38
	KotlinParserRULE_typeParameters             = 39
	KotlinParserRULE_typeParameter              = 40
	KotlinParserRULE_type                       = 41
	KotlinParserRULE_typeModifierList           = 42
	KotlinParserRULE_parenthesizedType          = 43
	KotlinParserRULE_nullableType               = 44
	KotlinParserRULE_typeReference              = 45
	KotlinParserRULE_functionType               = 46
	KotlinParserRULE_functionTypeReceiver       = 47
	KotlinParserRULE_userType                   = 48
	KotlinParserRULE_simpleUserType             = 49
	KotlinParserRULE_functionTypeParameters     = 50
	KotlinParserRULE_typeConstraints            = 51
	KotlinParserRULE_typeConstraint             = 52
	KotlinParserRULE_block                      = 53
	KotlinParserRULE_statements                 = 54
	KotlinParserRULE_statement                  = 55
	KotlinParserRULE_blockLevelExpression       = 56
	KotlinParserRULE_declaration                = 57
	KotlinParserRULE_expression                 = 58
	KotlinParserRULE_disjunction                = 59
	KotlinParserRULE_conjunction                = 60
	KotlinParserRULE_equalityComparison         = 61
	KotlinParserRULE_comparison                 = 62
	KotlinParserRULE_namedInfix                 = 63
	KotlinParserRULE_elvisExpression            = 64
	KotlinParserRULE_infixFunctionCall          = 65
	KotlinParserRULE_rangeExpression            = 66
	KotlinParserRULE_additiveExpression         = 67
	KotlinParserRULE_multiplicativeExpression   = 68
	KotlinParserRULE_typeRHS                    = 69
	KotlinParserRULE_prefixUnaryExpression      = 70
	KotlinParserRULE_postfixUnaryExpression     = 71
	KotlinParserRULE_atomicExpression           = 72
	KotlinParserRULE_parenthesizedExpression    = 73
	KotlinParserRULE_callSuffix                 = 74
	KotlinParserRULE_annotatedLambda            = 75
	KotlinParserRULE_arrayAccess                = 76
	KotlinParserRULE_valueArguments             = 77
	KotlinParserRULE_typeArguments              = 78
	KotlinParserRULE_typeProjection             = 79
	KotlinParserRULE_typeProjectionModifierList = 80
	KotlinParserRULE_valueArgument              = 81
	KotlinParserRULE_literalConstant            = 82
	KotlinParserRULE_stringLiteral              = 83
	KotlinParserRULE_lineStringLiteral          = 84
	KotlinParserRULE_multiLineStringLiteral     = 85
	KotlinParserRULE_lineStringContent          = 86
	KotlinParserRULE_lineStringExpression       = 87
	KotlinParserRULE_multiLineStringContent     = 88
	KotlinParserRULE_multiLineStringExpression  = 89
	KotlinParserRULE_functionLiteral            = 90
	KotlinParserRULE_lambdaParameters           = 91
	KotlinParserRULE_lambdaParameter            = 92
	KotlinParserRULE_objectLiteral              = 93
	KotlinParserRULE_collectionLiteral          = 94
	KotlinParserRULE_thisExpression             = 95
	KotlinParserRULE_superExpression            = 96
	KotlinParserRULE_conditionalExpression      = 97
	KotlinParserRULE_ifExpression               = 98
	KotlinParserRULE_controlStructureBody       = 99
	KotlinParserRULE_whenExpression             = 100
	KotlinParserRULE_whenEntry                  = 101
	KotlinParserRULE_whenCondition              = 102
	KotlinParserRULE_rangeTest                  = 103
	KotlinParserRULE_typeTest                   = 104
	KotlinParserRULE_tryExpression              = 105
	KotlinParserRULE_catchBlock                 = 106
	KotlinParserRULE_finallyBlock               = 107
	KotlinParserRULE_loopExpression             = 108
	KotlinParserRULE_forExpression              = 109
	KotlinParserRULE_whileExpression            = 110
	KotlinParserRULE_doWhileExpression          = 111
	KotlinParserRULE_jumpExpression             = 112
	KotlinParserRULE_callableReference          = 113
	KotlinParserRULE_assignmentOperator         = 114
	KotlinParserRULE_equalityOperation          = 115
	KotlinParserRULE_comparisonOperator         = 116
	KotlinParserRULE_inOperator                 = 117
	KotlinParserRULE_isOperator                 = 118
	KotlinParserRULE_additiveOperator           = 119
	KotlinParserRULE_multiplicativeOperation    = 120
	KotlinParserRULE_typeOperation              = 121
	KotlinParserRULE_prefixUnaryOperation       = 122
	KotlinParserRULE_postfixUnaryOperation      = 123
	KotlinParserRULE_memberAccessOperator       = 124
	KotlinParserRULE_modifierList               = 125
	KotlinParserRULE_modifier                   = 126
	KotlinParserRULE_classModifier              = 127
	KotlinParserRULE_memberModifier             = 128
	KotlinParserRULE_visibilityModifier         = 129
	KotlinParserRULE_varianceAnnotation         = 130
	KotlinParserRULE_functionModifier           = 131
	KotlinParserRULE_propertyModifier           = 132
	KotlinParserRULE_inheritanceModifier        = 133
	KotlinParserRULE_parameterModifier          = 134
	KotlinParserRULE_typeParameterModifier      = 135
	KotlinParserRULE_labelDefinition            = 136
	KotlinParserRULE_annotations                = 137
	KotlinParserRULE_annotation                 = 138
	KotlinParserRULE_annotationList             = 139
	KotlinParserRULE_annotationUseSiteTarget    = 140
	KotlinParserRULE_unescapedAnnotation        = 141
	KotlinParserRULE_identifier                 = 142
	KotlinParserRULE_simpleIdentifier           = 143
	KotlinParserRULE_semi                       = 144
	KotlinParserRULE_anysemi                    = 145
)

// IKotlinFileContext is an interface to support dynamic dispatch.
type IKotlinFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKotlinFileContext differentiates from other interfaces.
	IsKotlinFileContext()
}

type KotlinFileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKotlinFileContext() *KotlinFileContext {
	var p = new(KotlinFileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_kotlinFile
	return p
}

func (*KotlinFileContext) IsKotlinFileContext() {}

func NewKotlinFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KotlinFileContext {
	var p = new(KotlinFileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_kotlinFile

	return p
}

func (s *KotlinFileContext) GetParser() antlr.Parser { return s.parser }

func (s *KotlinFileContext) Preamble() IPreambleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreambleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreambleContext)
}

func (s *KotlinFileContext) EOF() antlr.TerminalNode {
	return s.GetToken(KotlinParserEOF, 0)
}

func (s *KotlinFileContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *KotlinFileContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *KotlinFileContext) AllAnysemi() []IAnysemiContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnysemiContext)(nil)).Elem())
	var tst = make([]IAnysemiContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnysemiContext)
		}
	}

	return tst
}

func (s *KotlinFileContext) Anysemi(i int) IAnysemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnysemiContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnysemiContext)
}

func (s *KotlinFileContext) AllTopLevelObject() []ITopLevelObjectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITopLevelObjectContext)(nil)).Elem())
	var tst = make([]ITopLevelObjectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITopLevelObjectContext)
		}
	}

	return tst
}

func (s *KotlinFileContext) TopLevelObject(i int) ITopLevelObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopLevelObjectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITopLevelObjectContext)
}

func (s *KotlinFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KotlinFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KotlinFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterKotlinFile(s)
	}
}

func (s *KotlinFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitKotlinFile(s)
	}
}

func (s *KotlinFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitKotlinFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) KotlinFile() (localctx IKotlinFileContext) {
	localctx = NewKotlinFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, KotlinParserRULE_kotlinFile)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(292)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(297)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())
	}
	{
		p.SetState(298)
		p.Preamble()
	}
	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
		{
			p.SetState(299)
			p.Anysemi()
		}

		p.SetState(304)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(KotlinParserAT-40))|(1<<(KotlinParserFILE-40))|(1<<(KotlinParserCLASS-40))|(1<<(KotlinParserINTERFACE-40))|(1<<(KotlinParserFUN-40))|(1<<(KotlinParserOBJECT-40))|(1<<(KotlinParserVAL-40))|(1<<(KotlinParserVAR-40))|(1<<(KotlinParserTYPE_ALIAS-40)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(305)
			p.TopLevelObject()
		}
		p.SetState(316)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
			p.SetState(307)
			p.GetErrorHandler().Sync(p)
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(306)
						p.Anysemi()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(309)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
			}
			p.SetState(312)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(KotlinParserAT-40))|(1<<(KotlinParserFILE-40))|(1<<(KotlinParserCLASS-40))|(1<<(KotlinParserINTERFACE-40))|(1<<(KotlinParserFUN-40))|(1<<(KotlinParserOBJECT-40))|(1<<(KotlinParserVAL-40))|(1<<(KotlinParserVAR-40))|(1<<(KotlinParserTYPE_ALIAS-40)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
				{
					p.SetState(311)
					p.TopLevelObject()
				}

			}

			p.SetState(318)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(321)
		p.Match(KotlinParserEOF)
	}

	return localctx
}

// IScriptContext is an interface to support dynamic dispatch.
type IScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptContext differentiates from other interfaces.
	IsScriptContext()
}

type ScriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptContext() *ScriptContext {
	var p = new(ScriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_script
	return p
}

func (*ScriptContext) IsScriptContext() {}

func NewScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptContext {
	var p = new(ScriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_script

	return p
}

func (s *ScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptContext) Preamble() IPreambleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPreambleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPreambleContext)
}

func (s *ScriptContext) EOF() antlr.TerminalNode {
	return s.GetToken(KotlinParserEOF, 0)
}

func (s *ScriptContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ScriptContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ScriptContext) AllAnysemi() []IAnysemiContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnysemiContext)(nil)).Elem())
	var tst = make([]IAnysemiContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnysemiContext)
		}
	}

	return tst
}

func (s *ScriptContext) Anysemi(i int) IAnysemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnysemiContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnysemiContext)
}

func (s *ScriptContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ScriptContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterScript(s)
	}
}

func (s *ScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitScript(s)
	}
}

func (s *ScriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitScript(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Script() (localctx IScriptContext) {
	localctx = NewScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, KotlinParserRULE_script)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(323)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(328)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}
	{
		p.SetState(329)
		p.Preamble()
	}
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(330)
				p.Anysemi()
			}

		}
		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())
	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserNL)|(1<<KotlinParserLPAREN)|(1<<KotlinParserLSQUARE)|(1<<KotlinParserLCURL)|(1<<KotlinParserADD)|(1<<KotlinParserSUB)|(1<<KotlinParserINCR)|(1<<KotlinParserDECR)|(1<<KotlinParserEXCL))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(KotlinParserCOLONCOLON-36))|(1<<(KotlinParserQ_COLONCOLON-36))|(1<<(KotlinParserAT-36))|(1<<(KotlinParserRETURN_AT-36))|(1<<(KotlinParserCONTINUE_AT-36))|(1<<(KotlinParserBREAK_AT-36))|(1<<(KotlinParserFILE-36))|(1<<(KotlinParserIMPORT-36))|(1<<(KotlinParserOBJECT-36))|(1<<(KotlinParserCONSTRUCTOR-36))|(1<<(KotlinParserBY-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(KotlinParserCOMPANION-68))|(1<<(KotlinParserINIT-68))|(1<<(KotlinParserTHIS-68))|(1<<(KotlinParserSUPER-68))|(1<<(KotlinParserWHERE-68))|(1<<(KotlinParserIF-68))|(1<<(KotlinParserWHEN-68))|(1<<(KotlinParserTRY-68))|(1<<(KotlinParserCATCH-68))|(1<<(KotlinParserFINALLY-68))|(1<<(KotlinParserFOR-68))|(1<<(KotlinParserDO-68))|(1<<(KotlinParserWHILE-68))|(1<<(KotlinParserTHROW-68))|(1<<(KotlinParserRETURN-68))|(1<<(KotlinParserCONTINUE-68))|(1<<(KotlinParserBREAK-68))|(1<<(KotlinParserOUT-68))|(1<<(KotlinParserFIELD-68))|(1<<(KotlinParserPROPERTY-68))|(1<<(KotlinParserGET-68))|(1<<(KotlinParserSET-68))|(1<<(KotlinParserGETTER-68))|(1<<(KotlinParserSETTER-68))|(1<<(KotlinParserRECEIVER-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(KotlinParserPARAM-100))|(1<<(KotlinParserSETPARAM-100))|(1<<(KotlinParserDELEGATE-100))|(1<<(KotlinParserDYNAMIC-100))|(1<<(KotlinParserPUBLIC-100))|(1<<(KotlinParserPRIVATE-100))|(1<<(KotlinParserPROTECTED-100))|(1<<(KotlinParserINTERNAL-100))|(1<<(KotlinParserENUM-100))|(1<<(KotlinParserSEALED-100))|(1<<(KotlinParserANNOTATION-100))|(1<<(KotlinParserDATA-100))|(1<<(KotlinParserINNER-100))|(1<<(KotlinParserTAILREC-100))|(1<<(KotlinParserOPERATOR-100))|(1<<(KotlinParserINLINE-100))|(1<<(KotlinParserINFIX-100))|(1<<(KotlinParserEXTERNAL-100))|(1<<(KotlinParserSUSPEND-100))|(1<<(KotlinParserOVERRIDE-100))|(1<<(KotlinParserABSTRACT-100))|(1<<(KotlinParserFINAL-100))|(1<<(KotlinParserOPEN-100))|(1<<(KotlinParserCONST-100))|(1<<(KotlinParserLATEINIT-100))|(1<<(KotlinParserVARARG-100))|(1<<(KotlinParserNOINLINE-100))|(1<<(KotlinParserCROSSINLINE-100))|(1<<(KotlinParserREIFIED-100))|(1<<(KotlinParserQUOTE_OPEN-100))|(1<<(KotlinParserTRIPLE_QUOTE_OPEN-100))|(1<<(KotlinParserRealLiteral-100)))) != 0) || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(KotlinParserLongLiteral-134))|(1<<(KotlinParserIntegerLiteral-134))|(1<<(KotlinParserHexLiteral-134))|(1<<(KotlinParserBinLiteral-134))|(1<<(KotlinParserBooleanLiteral-134))|(1<<(KotlinParserNullLiteral-134))|(1<<(KotlinParserIdentifier-134))|(1<<(KotlinParserLabelReference-134))|(1<<(KotlinParserLabelDefinition-134))|(1<<(KotlinParserCharacterLiteral-134)))) != 0) {
		{
			p.SetState(336)
			p.Expression()
		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
			p.SetState(338)
			p.GetErrorHandler().Sync(p)
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(337)
						p.Anysemi()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(340)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
			}
			p.SetState(343)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(342)
					p.Expression()
				}

			}

			p.SetState(349)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(352)
		p.Match(KotlinParserEOF)
	}

	return localctx
}

// IPreambleContext is an interface to support dynamic dispatch.
type IPreambleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreambleContext differentiates from other interfaces.
	IsPreambleContext()
}

type PreambleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreambleContext() *PreambleContext {
	var p = new(PreambleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_preamble
	return p
}

func (*PreambleContext) IsPreambleContext() {}

func NewPreambleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreambleContext {
	var p = new(PreambleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_preamble

	return p
}

func (s *PreambleContext) GetParser() antlr.Parser { return s.parser }

func (s *PreambleContext) PackageHeader() IPackageHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageHeaderContext)
}

func (s *PreambleContext) ImportList() IImportListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportListContext)
}

func (s *PreambleContext) FileAnnotations() IFileAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileAnnotationsContext)
}

func (s *PreambleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreambleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreambleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPreamble(s)
	}
}

func (s *PreambleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPreamble(s)
	}
}

func (s *PreambleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitPreamble(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Preamble() (localctx IPreambleContext) {
	localctx = NewPreambleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, KotlinParserRULE_preamble)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(355)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(354)
			p.FileAnnotations()
		}

	}
	{
		p.SetState(357)
		p.PackageHeader()
	}
	{
		p.SetState(358)
		p.ImportList()
	}

	return localctx
}

// IFileAnnotationsContext is an interface to support dynamic dispatch.
type IFileAnnotationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileAnnotationsContext differentiates from other interfaces.
	IsFileAnnotationsContext()
}

type FileAnnotationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileAnnotationsContext() *FileAnnotationsContext {
	var p = new(FileAnnotationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_fileAnnotations
	return p
}

func (*FileAnnotationsContext) IsFileAnnotationsContext() {}

func NewFileAnnotationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileAnnotationsContext {
	var p = new(FileAnnotationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_fileAnnotations

	return p
}

func (s *FileAnnotationsContext) GetParser() antlr.Parser { return s.parser }

func (s *FileAnnotationsContext) AllFileAnnotation() []IFileAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileAnnotationContext)(nil)).Elem())
	var tst = make([]IFileAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileAnnotationContext)
		}
	}

	return tst
}

func (s *FileAnnotationsContext) FileAnnotation(i int) IFileAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileAnnotationContext)
}

func (s *FileAnnotationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileAnnotationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileAnnotationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFileAnnotations(s)
	}
}

func (s *FileAnnotationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFileAnnotations(s)
	}
}

func (s *FileAnnotationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFileAnnotations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FileAnnotations() (localctx IFileAnnotationsContext) {
	localctx = NewFileAnnotationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, KotlinParserRULE_fileAnnotations)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(360)
				p.FileAnnotation()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext())
	}

	return localctx
}

// IFileAnnotationContext is an interface to support dynamic dispatch.
type IFileAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileAnnotationContext differentiates from other interfaces.
	IsFileAnnotationContext()
}

type FileAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileAnnotationContext() *FileAnnotationContext {
	var p = new(FileAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_fileAnnotation
	return p
}

func (*FileAnnotationContext) IsFileAnnotationContext() {}

func NewFileAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileAnnotationContext {
	var p = new(FileAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_fileAnnotation

	return p
}

func (s *FileAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *FileAnnotationContext) AllFILE() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserFILE)
}

func (s *FileAnnotationContext) FILE(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserFILE, i)
}

func (s *FileAnnotationContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOLON)
}

func (s *FileAnnotationContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, i)
}

func (s *FileAnnotationContext) AllLSQUARE() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserLSQUARE)
}

func (s *FileAnnotationContext) LSQUARE(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, i)
}

func (s *FileAnnotationContext) AllRSQUARE() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserRSQUARE)
}

func (s *FileAnnotationContext) RSQUARE(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, i)
}

func (s *FileAnnotationContext) AllUnescapedAnnotation() []IUnescapedAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem())
	var tst = make([]IUnescapedAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnescapedAnnotationContext)
		}
	}

	return tst
}

func (s *FileAnnotationContext) UnescapedAnnotation(i int) IUnescapedAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *FileAnnotationContext) AllSemi() []ISemiContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISemiContext)(nil)).Elem())
	var tst = make([]ISemiContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISemiContext)
		}
	}

	return tst
}

func (s *FileAnnotationContext) Semi(i int) ISemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemiContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *FileAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFileAnnotation(s)
	}
}

func (s *FileAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFileAnnotation(s)
	}
}

func (s *FileAnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFileAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FileAnnotation() (localctx IFileAnnotationContext) {
	localctx = NewFileAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, KotlinParserRULE_fileAnnotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(365)
				p.Match(KotlinParserFILE)
			}
			{
				p.SetState(366)
				p.Match(KotlinParserCOLON)
			}
			p.SetState(376)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserLSQUARE:
				{
					p.SetState(367)
					p.Match(KotlinParserLSQUARE)
				}
				p.SetState(369)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(KotlinParserIMPORT-58))|(1<<(KotlinParserCONSTRUCTOR-58))|(1<<(KotlinParserBY-58))|(1<<(KotlinParserCOMPANION-58))|(1<<(KotlinParserINIT-58))|(1<<(KotlinParserWHERE-58))|(1<<(KotlinParserCATCH-58))|(1<<(KotlinParserFINALLY-58)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(KotlinParserOUT-92))|(1<<(KotlinParserGETTER-92))|(1<<(KotlinParserSETTER-92))|(1<<(KotlinParserDYNAMIC-92))|(1<<(KotlinParserPUBLIC-92))|(1<<(KotlinParserPRIVATE-92))|(1<<(KotlinParserPROTECTED-92))|(1<<(KotlinParserINTERNAL-92))|(1<<(KotlinParserENUM-92))|(1<<(KotlinParserSEALED-92))|(1<<(KotlinParserANNOTATION-92))|(1<<(KotlinParserDATA-92))|(1<<(KotlinParserINNER-92))|(1<<(KotlinParserTAILREC-92))|(1<<(KotlinParserOPERATOR-92))|(1<<(KotlinParserINLINE-92))|(1<<(KotlinParserINFIX-92))|(1<<(KotlinParserEXTERNAL-92))|(1<<(KotlinParserSUSPEND-92))|(1<<(KotlinParserOVERRIDE-92))|(1<<(KotlinParserABSTRACT-92))|(1<<(KotlinParserFINAL-92))|(1<<(KotlinParserOPEN-92))|(1<<(KotlinParserCONST-92)))) != 0) || (((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(KotlinParserLATEINIT-124))|(1<<(KotlinParserVARARG-124))|(1<<(KotlinParserNOINLINE-124))|(1<<(KotlinParserCROSSINLINE-124))|(1<<(KotlinParserREIFIED-124))|(1<<(KotlinParserIdentifier-124)))) != 0) {
					{
						p.SetState(368)
						p.UnescapedAnnotation()
					}

					p.SetState(371)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(373)
					p.Match(KotlinParserRSQUARE)
				}

			case KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserGETTER, KotlinParserSETTER, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserIdentifier:
				{
					p.SetState(375)
					p.UnescapedAnnotation()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			p.SetState(379)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(378)
					p.Semi()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(383)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())
	}

	return localctx
}

// IPackageHeaderContext is an interface to support dynamic dispatch.
type IPackageHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageHeaderContext differentiates from other interfaces.
	IsPackageHeaderContext()
}

type PackageHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageHeaderContext() *PackageHeaderContext {
	var p = new(PackageHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_packageHeader
	return p
}

func (*PackageHeaderContext) IsPackageHeaderContext() {}

func NewPackageHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageHeaderContext {
	var p = new(PackageHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_packageHeader

	return p
}

func (s *PackageHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageHeaderContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPACKAGE, 0)
}

func (s *PackageHeaderContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PackageHeaderContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *PackageHeaderContext) Semi() ISemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemiContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *PackageHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPackageHeader(s)
	}
}

func (s *PackageHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPackageHeader(s)
	}
}

func (s *PackageHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitPackageHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) PackageHeader() (localctx IPackageHeaderContext) {
	localctx = NewPackageHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, KotlinParserRULE_packageHeader)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(393)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		p.SetState(386)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
			{
				p.SetState(385)
				p.ModifierList()
			}

		}
		{
			p.SetState(388)
			p.Match(KotlinParserPACKAGE)
		}
		{
			p.SetState(389)
			p.Identifier()
		}
		p.SetState(391)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(390)
				p.Semi()
			}

		}

	}

	return localctx
}

// IImportListContext is an interface to support dynamic dispatch.
type IImportListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportListContext differentiates from other interfaces.
	IsImportListContext()
}

type ImportListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportListContext() *ImportListContext {
	var p = new(ImportListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_importList
	return p
}

func (*ImportListContext) IsImportListContext() {}

func NewImportListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportListContext {
	var p = new(ImportListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importList

	return p
}

func (s *ImportListContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportListContext) AllImportHeader() []IImportHeaderContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportHeaderContext)(nil)).Elem())
	var tst = make([]IImportHeaderContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportHeaderContext)
		}
	}

	return tst
}

func (s *ImportListContext) ImportHeader(i int) IImportHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportHeaderContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportHeaderContext)
}

func (s *ImportListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportList(s)
	}
}

func (s *ImportListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportList(s)
	}
}

func (s *ImportListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitImportList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ImportList() (localctx IImportListContext) {
	localctx = NewImportListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, KotlinParserRULE_importList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(398)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(395)
				p.ImportHeader()
			}

		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// IImportHeaderContext is an interface to support dynamic dispatch.
type IImportHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportHeaderContext differentiates from other interfaces.
	IsImportHeaderContext()
}

type ImportHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportHeaderContext() *ImportHeaderContext {
	var p = new(ImportHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_importHeader
	return p
}

func (*ImportHeaderContext) IsImportHeaderContext() {}

func NewImportHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportHeaderContext {
	var p = new(ImportHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importHeader

	return p
}

func (s *ImportHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportHeaderContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(KotlinParserIMPORT, 0)
}

func (s *ImportHeaderContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportHeaderContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *ImportHeaderContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *ImportHeaderContext) ImportAlias() IImportAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportAliasContext)
}

func (s *ImportHeaderContext) Semi() ISemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemiContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *ImportHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportHeader(s)
	}
}

func (s *ImportHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportHeader(s)
	}
}

func (s *ImportHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitImportHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ImportHeader() (localctx IImportHeaderContext) {
	localctx = NewImportHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, KotlinParserRULE_importHeader)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		p.Match(KotlinParserIMPORT)
	}
	{
		p.SetState(402)
		p.Identifier()
	}
	p.SetState(406)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserDOT:
		{
			p.SetState(403)
			p.Match(KotlinParserDOT)
		}
		{
			p.SetState(404)
			p.Match(KotlinParserMULT)
		}

	case KotlinParserAS:
		{
			p.SetState(405)
			p.ImportAlias()
		}

	case KotlinParserEOF, KotlinParserNL, KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL, KotlinParserSEMICOLON, KotlinParserCOLONCOLON, KotlinParserQ_COLONCOLON, KotlinParserAT, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserFILE, KotlinParserIMPORT, KotlinParserCLASS, KotlinParserINTERFACE, KotlinParserFUN, KotlinParserOBJECT, KotlinParserVAL, KotlinParserVAR, KotlinParserTYPE_ALIAS, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserIN, KotlinParserOUT, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserGETTER, KotlinParserSETTER, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN, KotlinParserRealLiteral, KotlinParserLongLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserIdentifier, KotlinParserLabelReference, KotlinParserLabelDefinition, KotlinParserCharacterLiteral:

	default:
	}
	p.SetState(409)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(408)
			p.Semi()
		}

	}

	return localctx
}

// IImportAliasContext is an interface to support dynamic dispatch.
type IImportAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportAliasContext differentiates from other interfaces.
	IsImportAliasContext()
}

type ImportAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAliasContext() *ImportAliasContext {
	var p = new(ImportAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_importAlias
	return p
}

func (*ImportAliasContext) IsImportAliasContext() {}

func NewImportAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAliasContext {
	var p = new(ImportAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importAlias

	return p
}

func (s *ImportAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS, 0)
}

func (s *ImportAliasContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ImportAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportAlias(s)
	}
}

func (s *ImportAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportAlias(s)
	}
}

func (s *ImportAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitImportAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ImportAlias() (localctx IImportAliasContext) {
	localctx = NewImportAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, KotlinParserRULE_importAlias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(411)
		p.Match(KotlinParserAS)
	}
	{
		p.SetState(412)
		p.SimpleIdentifier()
	}

	return localctx
}

// ITopLevelObjectContext is an interface to support dynamic dispatch.
type ITopLevelObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopLevelObjectContext differentiates from other interfaces.
	IsTopLevelObjectContext()
}

type TopLevelObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopLevelObjectContext() *TopLevelObjectContext {
	var p = new(TopLevelObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_topLevelObject
	return p
}

func (*TopLevelObjectContext) IsTopLevelObjectContext() {}

func NewTopLevelObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopLevelObjectContext {
	var p = new(TopLevelObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_topLevelObject

	return p
}

func (s *TopLevelObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *TopLevelObjectContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TopLevelObjectContext) ObjectDeclaration() IObjectDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectDeclarationContext)
}

func (s *TopLevelObjectContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *TopLevelObjectContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *TopLevelObjectContext) TypeAlias() ITypeAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *TopLevelObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopLevelObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopLevelObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTopLevelObject(s)
	}
}

func (s *TopLevelObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTopLevelObject(s)
	}
}

func (s *TopLevelObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTopLevelObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TopLevelObject() (localctx ITopLevelObjectContext) {
	localctx = NewTopLevelObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, KotlinParserRULE_topLevelObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(414)
			p.ClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(415)
			p.ObjectDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(416)
			p.FunctionDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(417)
			p.PropertyDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(418)
			p.TypeAlias()
		}

	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *ClassDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERFACE, 0)
}

func (s *ClassDeclarationContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *ClassDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) PrimaryConstructor() IPrimaryConstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryConstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryConstructorContext)
}

func (s *ClassDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ClassDeclarationContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelegationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ClassDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) EnumClassBody() IEnumClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumClassBodyContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, KotlinParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(421)
			p.ModifierList()
		}

	}
	{
		p.SetState(424)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserCLASS || _la == KotlinParserINTERFACE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(425)
			p.Match(KotlinParserNL)
		}

		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(431)
		p.SimpleIdentifier()
	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(432)
				p.Match(KotlinParserNL)
			}

			p.SetState(437)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(438)
			p.TypeParameters()
		}

	}
	p.SetState(448)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(441)
				p.Match(KotlinParserNL)
			}

			p.SetState(446)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(447)
			p.PrimaryConstructor()
		}

	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(450)
				p.Match(KotlinParserNL)
			}

			p.SetState(455)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(456)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(457)
				p.Match(KotlinParserNL)
			}

			p.SetState(462)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(463)
			p.DelegationSpecifiers()
		}

	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(466)
				p.Match(KotlinParserNL)
			}

			p.SetState(471)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(472)
			p.TypeConstraints()
		}

	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(475)
				p.Match(KotlinParserNL)
			}

			p.SetState(480)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(481)
			p.ClassBody()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 2 {
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(482)
				p.Match(KotlinParserNL)
			}

			p.SetState(487)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(488)
			p.EnumClassBody()
		}

	}

	return localctx
}

// IPrimaryConstructorContext is an interface to support dynamic dispatch.
type IPrimaryConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryConstructorContext differentiates from other interfaces.
	IsPrimaryConstructorContext()
}

type PrimaryConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryConstructorContext() *PrimaryConstructorContext {
	var p = new(PrimaryConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_primaryConstructor
	return p
}

func (*PrimaryConstructorContext) IsPrimaryConstructorContext() {}

func NewPrimaryConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryConstructorContext {
	var p = new(PrimaryConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_primaryConstructor

	return p
}

func (s *PrimaryConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryConstructorContext) ClassParameters() IClassParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassParametersContext)
}

func (s *PrimaryConstructorContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *PrimaryConstructorContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *PrimaryConstructorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PrimaryConstructorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PrimaryConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrimaryConstructor(s)
	}
}

func (s *PrimaryConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrimaryConstructor(s)
	}
}

func (s *PrimaryConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitPrimaryConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) PrimaryConstructor() (localctx IPrimaryConstructorContext) {
	localctx = NewPrimaryConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, KotlinParserRULE_primaryConstructor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(491)
			p.ModifierList()
		}

	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserCONSTRUCTOR {
		{
			p.SetState(494)
			p.Match(KotlinParserCONSTRUCTOR)
		}
		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(495)
				p.Match(KotlinParserNL)
			}

			p.SetState(500)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(503)
		p.ClassParameters()
	}

	return localctx
}

// IClassParametersContext is an interface to support dynamic dispatch.
type IClassParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassParametersContext differentiates from other interfaces.
	IsClassParametersContext()
}

type ClassParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParametersContext() *ClassParametersContext {
	var p = new(ClassParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classParameters
	return p
}

func (*ClassParametersContext) IsClassParametersContext() {}

func NewClassParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParametersContext {
	var p = new(ClassParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classParameters

	return p
}

func (s *ClassParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ClassParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ClassParametersContext) AllClassParameter() []IClassParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassParameterContext)(nil)).Elem())
	var tst = make([]IClassParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassParameterContext)
		}
	}

	return tst
}

func (s *ClassParametersContext) ClassParameter(i int) IClassParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassParameterContext)
}

func (s *ClassParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ClassParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ClassParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassParameters(s)
	}
}

func (s *ClassParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassParameters(s)
	}
}

func (s *ClassParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitClassParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ClassParameters() (localctx IClassParametersContext) {
	localctx = NewClassParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, KotlinParserRULE_classParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(505)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(514)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(KotlinParserAT-40))|(1<<(KotlinParserFILE-40))|(1<<(KotlinParserIMPORT-40))|(1<<(KotlinParserVAL-40))|(1<<(KotlinParserVAR-40))|(1<<(KotlinParserCONSTRUCTOR-40))|(1<<(KotlinParserBY-40))|(1<<(KotlinParserCOMPANION-40))|(1<<(KotlinParserINIT-40)))) != 0) || (((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(KotlinParserWHERE-73))|(1<<(KotlinParserCATCH-73))|(1<<(KotlinParserFINALLY-73))|(1<<(KotlinParserIN-73))|(1<<(KotlinParserOUT-73))|(1<<(KotlinParserFIELD-73))|(1<<(KotlinParserPROPERTY-73))|(1<<(KotlinParserGET-73))|(1<<(KotlinParserSET-73))|(1<<(KotlinParserGETTER-73))|(1<<(KotlinParserSETTER-73))|(1<<(KotlinParserRECEIVER-73))|(1<<(KotlinParserPARAM-73))|(1<<(KotlinParserSETPARAM-73))|(1<<(KotlinParserDELEGATE-73))|(1<<(KotlinParserDYNAMIC-73))|(1<<(KotlinParserPUBLIC-73)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105)))) != 0) || _la == KotlinParserIdentifier || _la == KotlinParserLabelReference {
		{
			p.SetState(506)
			p.ClassParameter()
		}
		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserCOMMA {
			{
				p.SetState(507)
				p.Match(KotlinParserCOMMA)
			}
			{
				p.SetState(508)
				p.ClassParameter()
			}

			p.SetState(513)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(516)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IClassParameterContext is an interface to support dynamic dispatch.
type IClassParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassParameterContext differentiates from other interfaces.
	IsClassParameterContext()
}

type ClassParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParameterContext() *ClassParameterContext {
	var p = new(ClassParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classParameter
	return p
}

func (*ClassParameterContext) IsClassParameterContext() {}

func NewClassParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParameterContext {
	var p = new(ClassParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classParameter

	return p
}

func (s *ClassParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ClassParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ClassParameterContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ClassParameterContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *ClassParameterContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *ClassParameterContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassParameterContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *ClassParameterContext) VAR() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAR, 0)
}

func (s *ClassParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassParameter(s)
	}
}

func (s *ClassParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassParameter(s)
	}
}

func (s *ClassParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitClassParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ClassParameter() (localctx IClassParameterContext) {
	localctx = NewClassParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, KotlinParserRULE_classParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(519)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(518)
			p.ModifierList()
		}

	}
	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserVAL || _la == KotlinParserVAR {
		{
			p.SetState(521)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KotlinParserVAL || _la == KotlinParserVAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(524)
		p.SimpleIdentifier()
	}
	{
		p.SetState(525)
		p.Match(KotlinParserCOLON)
	}
	{
		p.SetState(526)
		p.Type()
	}
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserASSIGNMENT {
		{
			p.SetState(527)
			p.Match(KotlinParserASSIGNMENT)
		}
		{
			p.SetState(528)
			p.Expression()
		}

	}

	return localctx
}

// IDelegationSpecifiersContext is an interface to support dynamic dispatch.
type IDelegationSpecifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelegationSpecifiersContext differentiates from other interfaces.
	IsDelegationSpecifiersContext()
}

type DelegationSpecifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelegationSpecifiersContext() *DelegationSpecifiersContext {
	var p = new(DelegationSpecifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_delegationSpecifiers
	return p
}

func (*DelegationSpecifiersContext) IsDelegationSpecifiersContext() {}

func NewDelegationSpecifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelegationSpecifiersContext {
	var p = new(DelegationSpecifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_delegationSpecifiers

	return p
}

func (s *DelegationSpecifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *DelegationSpecifiersContext) AllDelegationSpecifier() []IDelegationSpecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDelegationSpecifierContext)(nil)).Elem())
	var tst = make([]IDelegationSpecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDelegationSpecifierContext)
		}
	}

	return tst
}

func (s *DelegationSpecifiersContext) DelegationSpecifier(i int) IDelegationSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelegationSpecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifierContext)
}

func (s *DelegationSpecifiersContext) AllAnnotations() []IAnnotationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem())
	var tst = make([]IAnnotationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsContext)
		}
	}

	return tst
}

func (s *DelegationSpecifiersContext) Annotations(i int) IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *DelegationSpecifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *DelegationSpecifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *DelegationSpecifiersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DelegationSpecifiersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DelegationSpecifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelegationSpecifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelegationSpecifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDelegationSpecifiers(s)
	}
}

func (s *DelegationSpecifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDelegationSpecifiers(s)
	}
}

func (s *DelegationSpecifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitDelegationSpecifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) DelegationSpecifiers() (localctx IDelegationSpecifiersContext) {
	localctx = NewDelegationSpecifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, KotlinParserRULE_delegationSpecifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(KotlinParserFIELD-93))|(1<<(KotlinParserPROPERTY-93))|(1<<(KotlinParserGET-93))|(1<<(KotlinParserSET-93))|(1<<(KotlinParserRECEIVER-93))|(1<<(KotlinParserPARAM-93))|(1<<(KotlinParserSETPARAM-93))|(1<<(KotlinParserDELEGATE-93)))) != 0) || _la == KotlinParserLabelReference {
		{
			p.SetState(531)
			p.Annotations()
		}

		p.SetState(536)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(537)
		p.DelegationSpecifier()
	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(541)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(538)
					p.Match(KotlinParserNL)
				}

				p.SetState(543)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(544)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(548)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(545)
					p.Match(KotlinParserNL)
				}

				p.SetState(550)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(551)
				p.DelegationSpecifier()
			}

		}
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())
	}

	return localctx
}

// IDelegationSpecifierContext is an interface to support dynamic dispatch.
type IDelegationSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelegationSpecifierContext differentiates from other interfaces.
	IsDelegationSpecifierContext()
}

type DelegationSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelegationSpecifierContext() *DelegationSpecifierContext {
	var p = new(DelegationSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_delegationSpecifier
	return p
}

func (*DelegationSpecifierContext) IsDelegationSpecifierContext() {}

func NewDelegationSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelegationSpecifierContext {
	var p = new(DelegationSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_delegationSpecifier

	return p
}

func (s *DelegationSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DelegationSpecifierContext) ConstructorInvocation() IConstructorInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorInvocationContext)
}

func (s *DelegationSpecifierContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *DelegationSpecifierContext) ExplicitDelegation() IExplicitDelegationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitDelegationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitDelegationContext)
}

func (s *DelegationSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelegationSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelegationSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDelegationSpecifier(s)
	}
}

func (s *DelegationSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDelegationSpecifier(s)
	}
}

func (s *DelegationSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitDelegationSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) DelegationSpecifier() (localctx IDelegationSpecifierContext) {
	localctx = NewDelegationSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, KotlinParserRULE_delegationSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(557)
			p.ConstructorInvocation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(558)
			p.UserType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(559)
			p.ExplicitDelegation()
		}

	}

	return localctx
}

// IConstructorInvocationContext is an interface to support dynamic dispatch.
type IConstructorInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorInvocationContext differentiates from other interfaces.
	IsConstructorInvocationContext()
}

type ConstructorInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorInvocationContext() *ConstructorInvocationContext {
	var p = new(ConstructorInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_constructorInvocation
	return p
}

func (*ConstructorInvocationContext) IsConstructorInvocationContext() {}

func NewConstructorInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorInvocationContext {
	var p = new(ConstructorInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_constructorInvocation

	return p
}

func (s *ConstructorInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorInvocationContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ConstructorInvocationContext) CallSuffix() ICallSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallSuffixContext)
}

func (s *ConstructorInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConstructorInvocation(s)
	}
}

func (s *ConstructorInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConstructorInvocation(s)
	}
}

func (s *ConstructorInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitConstructorInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ConstructorInvocation() (localctx IConstructorInvocationContext) {
	localctx = NewConstructorInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, KotlinParserRULE_constructorInvocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(562)
		p.UserType()
	}
	{
		p.SetState(563)
		p.CallSuffix()
	}

	return localctx
}

// IExplicitDelegationContext is an interface to support dynamic dispatch.
type IExplicitDelegationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitDelegationContext differentiates from other interfaces.
	IsExplicitDelegationContext()
}

type ExplicitDelegationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitDelegationContext() *ExplicitDelegationContext {
	var p = new(ExplicitDelegationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_explicitDelegation
	return p
}

func (*ExplicitDelegationContext) IsExplicitDelegationContext() {}

func NewExplicitDelegationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitDelegationContext {
	var p = new(ExplicitDelegationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_explicitDelegation

	return p
}

func (s *ExplicitDelegationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitDelegationContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ExplicitDelegationContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *ExplicitDelegationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExplicitDelegationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ExplicitDelegationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ExplicitDelegationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitDelegationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitDelegationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExplicitDelegation(s)
	}
}

func (s *ExplicitDelegationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExplicitDelegation(s)
	}
}

func (s *ExplicitDelegationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitExplicitDelegation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ExplicitDelegation() (localctx IExplicitDelegationContext) {
	localctx = NewExplicitDelegationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, KotlinParserRULE_explicitDelegation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		p.UserType()
	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(566)
			p.Match(KotlinParserNL)
		}

		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(572)
		p.Match(KotlinParserBY)
	}
	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(573)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())
	}
	{
		p.SetState(579)
		p.Expression()
	}

	return localctx
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classBody
	return p
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *ClassBodyContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *ClassBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassBodyContext) AllClassMemberDeclaration() []IClassMemberDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassMemberDeclarationContext)(nil)).Elem())
	var tst = make([]IClassMemberDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassMemberDeclarationContext)
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassMemberDeclaration(i int) IClassMemberDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassMemberDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (s *ClassBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitClassBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, KotlinParserRULE_classBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(582)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
	}
	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(KotlinParserAT-40))|(1<<(KotlinParserFILE-40))|(1<<(KotlinParserCLASS-40))|(1<<(KotlinParserINTERFACE-40))|(1<<(KotlinParserFUN-40))|(1<<(KotlinParserOBJECT-40))|(1<<(KotlinParserVAL-40))|(1<<(KotlinParserVAR-40))|(1<<(KotlinParserTYPE_ALIAS-40))|(1<<(KotlinParserCONSTRUCTOR-40))|(1<<(KotlinParserCOMPANION-40))|(1<<(KotlinParserINIT-40)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(588)
			p.ClassMemberDeclaration()
		}

		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(594)
			p.Match(KotlinParserNL)
		}

		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(600)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IClassMemberDeclarationContext is an interface to support dynamic dispatch.
type IClassMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassMemberDeclarationContext differentiates from other interfaces.
	IsClassMemberDeclarationContext()
}

type ClassMemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberDeclarationContext() *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classMemberDeclaration
	return p
}

func (*ClassMemberDeclarationContext) IsClassMemberDeclarationContext() {}

func NewClassMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classMemberDeclaration

	return p
}

func (s *ClassMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ClassMemberDeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *ClassMemberDeclarationContext) ObjectDeclaration() IObjectDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectDeclarationContext)
}

func (s *ClassMemberDeclarationContext) CompanionObject() ICompanionObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompanionObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompanionObjectContext)
}

func (s *ClassMemberDeclarationContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *ClassMemberDeclarationContext) AnonymousInitializer() IAnonymousInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnonymousInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnonymousInitializerContext)
}

func (s *ClassMemberDeclarationContext) SecondaryConstructor() ISecondaryConstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISecondaryConstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISecondaryConstructorContext)
}

func (s *ClassMemberDeclarationContext) TypeAlias() ITypeAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *ClassMemberDeclarationContext) AllAnysemi() []IAnysemiContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnysemiContext)(nil)).Elem())
	var tst = make([]IAnysemiContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnysemiContext)
		}
	}

	return tst
}

func (s *ClassMemberDeclarationContext) Anysemi(i int) IAnysemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnysemiContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnysemiContext)
}

func (s *ClassMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassMemberDeclaration(s)
	}
}

func (s *ClassMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassMemberDeclaration(s)
	}
}

func (s *ClassMemberDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitClassMemberDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ClassMemberDeclaration() (localctx IClassMemberDeclarationContext) {
	localctx = NewClassMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, KotlinParserRULE_classMemberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(602)
			p.ClassDeclaration()
		}

	case 2:
		{
			p.SetState(603)
			p.FunctionDeclaration()
		}

	case 3:
		{
			p.SetState(604)
			p.ObjectDeclaration()
		}

	case 4:
		{
			p.SetState(605)
			p.CompanionObject()
		}

	case 5:
		{
			p.SetState(606)
			p.PropertyDeclaration()
		}

	case 6:
		{
			p.SetState(607)
			p.AnonymousInitializer()
		}

	case 7:
		{
			p.SetState(608)
			p.SecondaryConstructor()
		}

	case 8:
		{
			p.SetState(609)
			p.TypeAlias()
		}

	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(612)
				p.Anysemi()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext())
	}

	return localctx
}

// IAnonymousInitializerContext is an interface to support dynamic dispatch.
type IAnonymousInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymousInitializerContext differentiates from other interfaces.
	IsAnonymousInitializerContext()
}

type AnonymousInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousInitializerContext() *AnonymousInitializerContext {
	var p = new(AnonymousInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_anonymousInitializer
	return p
}

func (*AnonymousInitializerContext) IsAnonymousInitializerContext() {}

func NewAnonymousInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousInitializerContext {
	var p = new(AnonymousInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_anonymousInitializer

	return p
}

func (s *AnonymousInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousInitializerContext) INIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserINIT, 0)
}

func (s *AnonymousInitializerContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *AnonymousInitializerContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnonymousInitializerContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnonymousInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnonymousInitializer(s)
	}
}

func (s *AnonymousInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnonymousInitializer(s)
	}
}

func (s *AnonymousInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAnonymousInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) AnonymousInitializer() (localctx IAnonymousInitializerContext) {
	localctx = NewAnonymousInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, KotlinParserRULE_anonymousInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Match(KotlinParserINIT)
	}
	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(618)
			p.Match(KotlinParserNL)
		}

		p.SetState(623)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(624)
		p.Block()
	}

	return localctx
}

// ISecondaryConstructorContext is an interface to support dynamic dispatch.
type ISecondaryConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecondaryConstructorContext differentiates from other interfaces.
	IsSecondaryConstructorContext()
}

type SecondaryConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecondaryConstructorContext() *SecondaryConstructorContext {
	var p = new(SecondaryConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_secondaryConstructor
	return p
}

func (*SecondaryConstructorContext) IsSecondaryConstructorContext() {}

func NewSecondaryConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SecondaryConstructorContext {
	var p = new(SecondaryConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_secondaryConstructor

	return p
}

func (s *SecondaryConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *SecondaryConstructorContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *SecondaryConstructorContext) FunctionValueParameters() IFunctionValueParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionValueParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParametersContext)
}

func (s *SecondaryConstructorContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *SecondaryConstructorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SecondaryConstructorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SecondaryConstructorContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *SecondaryConstructorContext) ConstructorDelegationCall() IConstructorDelegationCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorDelegationCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorDelegationCallContext)
}

func (s *SecondaryConstructorContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SecondaryConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecondaryConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SecondaryConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSecondaryConstructor(s)
	}
}

func (s *SecondaryConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSecondaryConstructor(s)
	}
}

func (s *SecondaryConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitSecondaryConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) SecondaryConstructor() (localctx ISecondaryConstructorContext) {
	localctx = NewSecondaryConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, KotlinParserRULE_secondaryConstructor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(626)
			p.ModifierList()
		}

	}
	{
		p.SetState(629)
		p.Match(KotlinParserCONSTRUCTOR)
	}
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(630)
			p.Match(KotlinParserNL)
		}

		p.SetState(635)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(636)
		p.FunctionValueParameters()
	}
	p.SetState(651)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
		p.SetState(640)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(637)
				p.Match(KotlinParserNL)
			}

			p.SetState(642)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(643)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(644)
				p.Match(KotlinParserNL)
			}

			p.SetState(649)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(650)
			p.ConstructorDelegationCall()
		}

	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(653)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
	}
	p.SetState(660)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLCURL {
		{
			p.SetState(659)
			p.Block()
		}

	}

	return localctx
}

// IConstructorDelegationCallContext is an interface to support dynamic dispatch.
type IConstructorDelegationCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorDelegationCallContext differentiates from other interfaces.
	IsConstructorDelegationCallContext()
}

type ConstructorDelegationCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDelegationCallContext() *ConstructorDelegationCallContext {
	var p = new(ConstructorDelegationCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_constructorDelegationCall
	return p
}

func (*ConstructorDelegationCallContext) IsConstructorDelegationCallContext() {}

func NewConstructorDelegationCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDelegationCallContext {
	var p = new(ConstructorDelegationCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_constructorDelegationCall

	return p
}

func (s *ConstructorDelegationCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDelegationCallContext) THIS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS, 0)
}

func (s *ConstructorDelegationCallContext) ValueArguments() IValueArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *ConstructorDelegationCallContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ConstructorDelegationCallContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ConstructorDelegationCallContext) SUPER() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER, 0)
}

func (s *ConstructorDelegationCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDelegationCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDelegationCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConstructorDelegationCall(s)
	}
}

func (s *ConstructorDelegationCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConstructorDelegationCall(s)
	}
}

func (s *ConstructorDelegationCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitConstructorDelegationCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ConstructorDelegationCall() (localctx IConstructorDelegationCallContext) {
	localctx = NewConstructorDelegationCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, KotlinParserRULE_constructorDelegationCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(678)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserTHIS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(662)
			p.Match(KotlinParserTHIS)
		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(663)
				p.Match(KotlinParserNL)
			}

			p.SetState(668)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(669)
			p.ValueArguments()
		}

	case KotlinParserSUPER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(670)
			p.Match(KotlinParserSUPER)
		}
		p.SetState(674)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(671)
				p.Match(KotlinParserNL)
			}

			p.SetState(676)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(677)
			p.ValueArguments()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumClassBodyContext is an interface to support dynamic dispatch.
type IEnumClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumClassBodyContext differentiates from other interfaces.
	IsEnumClassBodyContext()
}

type EnumClassBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumClassBodyContext() *EnumClassBodyContext {
	var p = new(EnumClassBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_enumClassBody
	return p
}

func (*EnumClassBodyContext) IsEnumClassBodyContext() {}

func NewEnumClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumClassBodyContext {
	var p = new(EnumClassBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumClassBody

	return p
}

func (s *EnumClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumClassBodyContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *EnumClassBodyContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *EnumClassBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumClassBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumClassBodyContext) EnumEntries() IEnumEntriesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumEntriesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumEntriesContext)
}

func (s *EnumClassBodyContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *EnumClassBodyContext) AllClassMemberDeclaration() []IClassMemberDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassMemberDeclarationContext)(nil)).Elem())
	var tst = make([]IClassMemberDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassMemberDeclarationContext)
		}
	}

	return tst
}

func (s *EnumClassBodyContext) ClassMemberDeclaration(i int) IClassMemberDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassMemberDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationContext)
}

func (s *EnumClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumClassBody(s)
	}
}

func (s *EnumClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumClassBody(s)
	}
}

func (s *EnumClassBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitEnumClassBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) EnumClassBody() (localctx IEnumClassBodyContext) {
	localctx = NewEnumClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, KotlinParserRULE_enumClassBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(681)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(KotlinParserIMPORT-58))|(1<<(KotlinParserCONSTRUCTOR-58))|(1<<(KotlinParserBY-58))|(1<<(KotlinParserCOMPANION-58))|(1<<(KotlinParserINIT-58))|(1<<(KotlinParserWHERE-58))|(1<<(KotlinParserCATCH-58))|(1<<(KotlinParserFINALLY-58)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(KotlinParserOUT-92))|(1<<(KotlinParserGETTER-92))|(1<<(KotlinParserSETTER-92))|(1<<(KotlinParserDYNAMIC-92))|(1<<(KotlinParserPUBLIC-92))|(1<<(KotlinParserPRIVATE-92))|(1<<(KotlinParserPROTECTED-92))|(1<<(KotlinParserINTERNAL-92))|(1<<(KotlinParserENUM-92))|(1<<(KotlinParserSEALED-92))|(1<<(KotlinParserANNOTATION-92))|(1<<(KotlinParserDATA-92))|(1<<(KotlinParserINNER-92))|(1<<(KotlinParserTAILREC-92))|(1<<(KotlinParserOPERATOR-92))|(1<<(KotlinParserINLINE-92))|(1<<(KotlinParserINFIX-92))|(1<<(KotlinParserEXTERNAL-92))|(1<<(KotlinParserSUSPEND-92))|(1<<(KotlinParserOVERRIDE-92))|(1<<(KotlinParserABSTRACT-92))|(1<<(KotlinParserFINAL-92))|(1<<(KotlinParserOPEN-92))|(1<<(KotlinParserCONST-92)))) != 0) || (((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(KotlinParserLATEINIT-124))|(1<<(KotlinParserVARARG-124))|(1<<(KotlinParserNOINLINE-124))|(1<<(KotlinParserCROSSINLINE-124))|(1<<(KotlinParserREIFIED-124))|(1<<(KotlinParserIdentifier-124)))) != 0) {
		{
			p.SetState(687)
			p.EnumEntries()
		}

	}
	p.SetState(709)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
		p.SetState(693)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(690)
				p.Match(KotlinParserNL)
			}

			p.SetState(695)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(696)
			p.Match(KotlinParserSEMICOLON)
		}
		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(697)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(702)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())
		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(KotlinParserAT-40))|(1<<(KotlinParserFILE-40))|(1<<(KotlinParserCLASS-40))|(1<<(KotlinParserINTERFACE-40))|(1<<(KotlinParserFUN-40))|(1<<(KotlinParserOBJECT-40))|(1<<(KotlinParserVAL-40))|(1<<(KotlinParserVAR-40))|(1<<(KotlinParserTYPE_ALIAS-40))|(1<<(KotlinParserCONSTRUCTOR-40))|(1<<(KotlinParserCOMPANION-40))|(1<<(KotlinParserINIT-40)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
			{
				p.SetState(703)
				p.ClassMemberDeclaration()
			}

			p.SetState(708)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(714)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(711)
			p.Match(KotlinParserNL)
		}

		p.SetState(716)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(717)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IEnumEntriesContext is an interface to support dynamic dispatch.
type IEnumEntriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumEntriesContext differentiates from other interfaces.
	IsEnumEntriesContext()
}

type EnumEntriesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumEntriesContext() *EnumEntriesContext {
	var p = new(EnumEntriesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_enumEntries
	return p
}

func (*EnumEntriesContext) IsEnumEntriesContext() {}

func NewEnumEntriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumEntriesContext {
	var p = new(EnumEntriesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumEntries

	return p
}

func (s *EnumEntriesContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumEntriesContext) AllEnumEntry() []IEnumEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumEntryContext)(nil)).Elem())
	var tst = make([]IEnumEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumEntryContext)
		}
	}

	return tst
}

func (s *EnumEntriesContext) EnumEntry(i int) IEnumEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumEntryContext)
}

func (s *EnumEntriesContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *EnumEntriesContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumEntriesContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumEntriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumEntriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumEntriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumEntries(s)
	}
}

func (s *EnumEntriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumEntries(s)
	}
}

func (s *EnumEntriesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitEnumEntries(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) EnumEntries() (localctx IEnumEntriesContext) {
	localctx = NewEnumEntriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, KotlinParserRULE_enumEntries)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(KotlinParserIMPORT-58))|(1<<(KotlinParserCONSTRUCTOR-58))|(1<<(KotlinParserBY-58))|(1<<(KotlinParserCOMPANION-58))|(1<<(KotlinParserINIT-58))|(1<<(KotlinParserWHERE-58))|(1<<(KotlinParserCATCH-58))|(1<<(KotlinParserFINALLY-58)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(KotlinParserOUT-92))|(1<<(KotlinParserGETTER-92))|(1<<(KotlinParserSETTER-92))|(1<<(KotlinParserDYNAMIC-92))|(1<<(KotlinParserPUBLIC-92))|(1<<(KotlinParserPRIVATE-92))|(1<<(KotlinParserPROTECTED-92))|(1<<(KotlinParserINTERNAL-92))|(1<<(KotlinParserENUM-92))|(1<<(KotlinParserSEALED-92))|(1<<(KotlinParserANNOTATION-92))|(1<<(KotlinParserDATA-92))|(1<<(KotlinParserINNER-92))|(1<<(KotlinParserTAILREC-92))|(1<<(KotlinParserOPERATOR-92))|(1<<(KotlinParserINLINE-92))|(1<<(KotlinParserINFIX-92))|(1<<(KotlinParserEXTERNAL-92))|(1<<(KotlinParserSUSPEND-92))|(1<<(KotlinParserOVERRIDE-92))|(1<<(KotlinParserABSTRACT-92))|(1<<(KotlinParserFINAL-92))|(1<<(KotlinParserOPEN-92))|(1<<(KotlinParserCONST-92)))) != 0) || (((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(KotlinParserLATEINIT-124))|(1<<(KotlinParserVARARG-124))|(1<<(KotlinParserNOINLINE-124))|(1<<(KotlinParserCROSSINLINE-124))|(1<<(KotlinParserREIFIED-124))|(1<<(KotlinParserIdentifier-124)))) != 0) {
		{
			p.SetState(719)
			p.EnumEntry()
		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(720)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(725)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())
		}

		p.SetState(728)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(731)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(730)
			p.Match(KotlinParserSEMICOLON)
		}

	}

	return localctx
}

// IEnumEntryContext is an interface to support dynamic dispatch.
type IEnumEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumEntryContext differentiates from other interfaces.
	IsEnumEntryContext()
}

type EnumEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumEntryContext() *EnumEntryContext {
	var p = new(EnumEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_enumEntry
	return p
}

func (*EnumEntryContext) IsEnumEntryContext() {}

func NewEnumEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumEntryContext {
	var p = new(EnumEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumEntry

	return p
}

func (s *EnumEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumEntryContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *EnumEntryContext) ValueArguments() IValueArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *EnumEntryContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *EnumEntryContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, 0)
}

func (s *EnumEntryContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumEntryContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumEntry(s)
	}
}

func (s *EnumEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumEntry(s)
	}
}

func (s *EnumEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitEnumEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) EnumEntry() (localctx IEnumEntryContext) {
	localctx = NewEnumEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, KotlinParserRULE_enumEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(733)
		p.SimpleIdentifier()
	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(734)
				p.Match(KotlinParserNL)
			}

			p.SetState(739)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(740)
			p.ValueArguments()
		}

	}
	p.SetState(750)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(743)
				p.Match(KotlinParserNL)
			}

			p.SetState(748)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(749)
			p.ClassBody()
		}

	}
	p.SetState(759)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(752)
				p.Match(KotlinParserNL)
			}

			p.SetState(757)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(758)
			p.Match(KotlinParserCOMMA)
		}

	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FUN() antlr.TerminalNode {
	return s.GetToken(KotlinParserFUN, 0)
}

func (s *FunctionDeclarationContext) FunctionValueParameters() IFunctionValueParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionValueParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParametersContext)
}

func (s *FunctionDeclarationContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *FunctionDeclarationContext) AllType() []ITypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeContext)(nil)).Elem())
	var tst = make([]ITypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeContext)
		}
	}

	return tst
}

func (s *FunctionDeclarationContext) Type(i int) ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FunctionDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *FunctionDeclarationContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *FunctionDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *FunctionDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, KotlinParserRULE_functionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(761)
			p.ModifierList()
		}

	}
	{
		p.SetState(764)
		p.Match(KotlinParserFUN)
	}
	p.SetState(780)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(765)
				p.Match(KotlinParserNL)
			}

			p.SetState(770)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(771)
			p.Type()
		}
		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(772)
				p.Match(KotlinParserNL)
			}

			p.SetState(777)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(778)
			p.Match(KotlinParserDOT)
		}

	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
		p.SetState(785)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(782)
				p.Match(KotlinParserNL)
			}

			p.SetState(787)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(788)
			p.TypeParameters()
		}

	}
	p.SetState(798)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(791)
				p.Match(KotlinParserNL)
			}

			p.SetState(796)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(797)
			p.Identifier()
		}

	}
	p.SetState(803)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(800)
			p.Match(KotlinParserNL)
		}

		p.SetState(805)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(806)
		p.FunctionValueParameters()
	}
	p.SetState(821)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(807)
				p.Match(KotlinParserNL)
			}

			p.SetState(812)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(813)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(814)
				p.Match(KotlinParserNL)
			}

			p.SetState(819)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(820)
			p.Type()
		}

	}
	p.SetState(830)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		p.SetState(826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(823)
				p.Match(KotlinParserNL)
			}

			p.SetState(828)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(829)
			p.TypeConstraints()
		}

	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(832)
				p.Match(KotlinParserNL)
			}

			p.SetState(837)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(838)
			p.FunctionBody()
		}

	}

	return localctx
}

// IFunctionValueParametersContext is an interface to support dynamic dispatch.
type IFunctionValueParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionValueParametersContext differentiates from other interfaces.
	IsFunctionValueParametersContext()
}

type FunctionValueParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParametersContext() *FunctionValueParametersContext {
	var p = new(FunctionValueParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameters
	return p
}

func (*FunctionValueParametersContext) IsFunctionValueParametersContext() {}

func NewFunctionValueParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParametersContext {
	var p = new(FunctionValueParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameters

	return p
}

func (s *FunctionValueParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *FunctionValueParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *FunctionValueParametersContext) AllFunctionValueParameter() []IFunctionValueParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionValueParameterContext)(nil)).Elem())
	var tst = make([]IFunctionValueParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionValueParameterContext)
		}
	}

	return tst
}

func (s *FunctionValueParametersContext) FunctionValueParameter(i int) IFunctionValueParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionValueParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParameterContext)
}

func (s *FunctionValueParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *FunctionValueParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *FunctionValueParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameters(s)
	}
}

func (s *FunctionValueParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameters(s)
	}
}

func (s *FunctionValueParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFunctionValueParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FunctionValueParameters() (localctx IFunctionValueParametersContext) {
	localctx = NewFunctionValueParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, KotlinParserRULE_functionValueParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(841)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(KotlinParserAT-40))|(1<<(KotlinParserFILE-40))|(1<<(KotlinParserIMPORT-40))|(1<<(KotlinParserCONSTRUCTOR-40))|(1<<(KotlinParserBY-40))|(1<<(KotlinParserCOMPANION-40))|(1<<(KotlinParserINIT-40)))) != 0) || (((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(KotlinParserWHERE-73))|(1<<(KotlinParserCATCH-73))|(1<<(KotlinParserFINALLY-73))|(1<<(KotlinParserIN-73))|(1<<(KotlinParserOUT-73))|(1<<(KotlinParserFIELD-73))|(1<<(KotlinParserPROPERTY-73))|(1<<(KotlinParserGET-73))|(1<<(KotlinParserSET-73))|(1<<(KotlinParserGETTER-73))|(1<<(KotlinParserSETTER-73))|(1<<(KotlinParserRECEIVER-73))|(1<<(KotlinParserPARAM-73))|(1<<(KotlinParserSETPARAM-73))|(1<<(KotlinParserDELEGATE-73))|(1<<(KotlinParserDYNAMIC-73))|(1<<(KotlinParserPUBLIC-73)))) != 0) || (((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(KotlinParserPRIVATE-105))|(1<<(KotlinParserPROTECTED-105))|(1<<(KotlinParserINTERNAL-105))|(1<<(KotlinParserENUM-105))|(1<<(KotlinParserSEALED-105))|(1<<(KotlinParserANNOTATION-105))|(1<<(KotlinParserDATA-105))|(1<<(KotlinParserINNER-105))|(1<<(KotlinParserTAILREC-105))|(1<<(KotlinParserOPERATOR-105))|(1<<(KotlinParserINLINE-105))|(1<<(KotlinParserINFIX-105))|(1<<(KotlinParserEXTERNAL-105))|(1<<(KotlinParserSUSPEND-105))|(1<<(KotlinParserOVERRIDE-105))|(1<<(KotlinParserABSTRACT-105))|(1<<(KotlinParserFINAL-105))|(1<<(KotlinParserOPEN-105))|(1<<(KotlinParserCONST-105))|(1<<(KotlinParserLATEINIT-105))|(1<<(KotlinParserVARARG-105))|(1<<(KotlinParserNOINLINE-105))|(1<<(KotlinParserCROSSINLINE-105))|(1<<(KotlinParserREIFIED-105)))) != 0) || _la == KotlinParserIdentifier || _la == KotlinParserLabelReference {
		{
			p.SetState(842)
			p.FunctionValueParameter()
		}
		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserCOMMA {
			{
				p.SetState(843)
				p.Match(KotlinParserCOMMA)
			}
			{
				p.SetState(844)
				p.FunctionValueParameter()
			}

			p.SetState(849)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(852)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IFunctionValueParameterContext is an interface to support dynamic dispatch.
type IFunctionValueParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionValueParameterContext differentiates from other interfaces.
	IsFunctionValueParameterContext()
}

type FunctionValueParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParameterContext() *FunctionValueParameterContext {
	var p = new(FunctionValueParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameter
	return p
}

func (*FunctionValueParameterContext) IsFunctionValueParameterContext() {}

func NewFunctionValueParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParameterContext {
	var p = new(FunctionValueParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameter

	return p
}

func (s *FunctionValueParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParameterContext) Parameter() IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *FunctionValueParameterContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *FunctionValueParameterContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionValueParameterContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionValueParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameter(s)
	}
}

func (s *FunctionValueParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameter(s)
	}
}

func (s *FunctionValueParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFunctionValueParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FunctionValueParameter() (localctx IFunctionValueParameterContext) {
	localctx = NewFunctionValueParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, KotlinParserRULE_functionValueParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(855)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(854)
			p.ModifierList()
		}

	}
	{
		p.SetState(857)
		p.Parameter()
	}
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserASSIGNMENT {
		{
			p.SetState(858)
			p.Match(KotlinParserASSIGNMENT)
		}
		{
			p.SetState(859)
			p.Expression()
		}

	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ParameterContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, KotlinParserRULE_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(862)
		p.SimpleIdentifier()
	}
	{
		p.SetState(863)
		p.Match(KotlinParserCOLON)
	}
	{
		p.SetState(864)
		p.Type()
	}

	return localctx
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionBody
	return p
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionBodyContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionBodyContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (s *FunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, KotlinParserRULE_functionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(875)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLCURL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(866)
			p.Block()
		}

	case KotlinParserASSIGNMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(867)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(871)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(868)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(873)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())
		}
		{
			p.SetState(874)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectDeclarationContext is an interface to support dynamic dispatch.
type IObjectDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectDeclarationContext differentiates from other interfaces.
	IsObjectDeclarationContext()
}

type ObjectDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectDeclarationContext() *ObjectDeclarationContext {
	var p = new(ObjectDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_objectDeclaration
	return p
}

func (*ObjectDeclarationContext) IsObjectDeclarationContext() {}

func NewObjectDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectDeclarationContext {
	var p = new(ObjectDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_objectDeclaration

	return p
}

func (s *ObjectDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectDeclarationContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *ObjectDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ObjectDeclarationContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *ObjectDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ObjectDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ObjectDeclarationContext) PrimaryConstructor() IPrimaryConstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryConstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryConstructorContext)
}

func (s *ObjectDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ObjectDeclarationContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelegationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ObjectDeclarationContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ObjectDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterObjectDeclaration(s)
	}
}

func (s *ObjectDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitObjectDeclaration(s)
	}
}

func (s *ObjectDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitObjectDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ObjectDeclaration() (localctx IObjectDeclarationContext) {
	localctx = NewObjectDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, KotlinParserRULE_objectDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(877)
			p.ModifierList()
		}

	}
	{
		p.SetState(880)
		p.Match(KotlinParserOBJECT)
	}
	p.SetState(884)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(881)
			p.Match(KotlinParserNL)
		}

		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(887)
		p.SimpleIdentifier()
	}
	p.SetState(895)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
		p.SetState(891)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(888)
				p.Match(KotlinParserNL)
			}

			p.SetState(893)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(894)
			p.PrimaryConstructor()
		}

	}
	p.SetState(911)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
		p.SetState(900)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(897)
				p.Match(KotlinParserNL)
			}

			p.SetState(902)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(903)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(907)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(904)
				p.Match(KotlinParserNL)
			}

			p.SetState(909)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(910)
			p.DelegationSpecifiers()
		}

	}
	p.SetState(920)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(913)
				p.Match(KotlinParserNL)
			}

			p.SetState(918)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(919)
			p.ClassBody()
		}

	}

	return localctx
}

// ICompanionObjectContext is an interface to support dynamic dispatch.
type ICompanionObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompanionObjectContext differentiates from other interfaces.
	IsCompanionObjectContext()
}

type CompanionObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompanionObjectContext() *CompanionObjectContext {
	var p = new(CompanionObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_companionObject
	return p
}

func (*CompanionObjectContext) IsCompanionObjectContext() {}

func NewCompanionObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompanionObjectContext {
	var p = new(CompanionObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_companionObject

	return p
}

func (s *CompanionObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *CompanionObjectContext) COMPANION() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMPANION, 0)
}

func (s *CompanionObjectContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *CompanionObjectContext) AllModifierList() []IModifierListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierListContext)(nil)).Elem())
	var tst = make([]IModifierListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierListContext)
		}
	}

	return tst
}

func (s *CompanionObjectContext) ModifierList(i int) IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *CompanionObjectContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CompanionObjectContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CompanionObjectContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CompanionObjectContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *CompanionObjectContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelegationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *CompanionObjectContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *CompanionObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompanionObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompanionObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCompanionObject(s)
	}
}

func (s *CompanionObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCompanionObject(s)
	}
}

func (s *CompanionObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitCompanionObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) CompanionObject() (localctx ICompanionObjectContext) {
	localctx = NewCompanionObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, KotlinParserRULE_companionObject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(922)
			p.ModifierList()
		}

	}
	{
		p.SetState(925)
		p.Match(KotlinParserCOMPANION)
	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(926)
			p.Match(KotlinParserNL)
		}

		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(933)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(932)
			p.ModifierList()
		}

	}
	{
		p.SetState(935)
		p.Match(KotlinParserOBJECT)
	}
	p.SetState(943)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
		p.SetState(939)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(936)
				p.Match(KotlinParserNL)
			}

			p.SetState(941)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(942)
			p.SimpleIdentifier()
		}

	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		p.SetState(948)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(945)
				p.Match(KotlinParserNL)
			}

			p.SetState(950)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(951)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(952)
				p.Match(KotlinParserNL)
			}

			p.SetState(957)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(958)
			p.DelegationSpecifiers()
		}

	}
	p.SetState(968)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		p.SetState(964)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(961)
				p.Match(KotlinParserNL)
			}

			p.SetState(966)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(967)
			p.ClassBody()
		}

	}

	return localctx
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyDeclaration
	return p
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *PropertyDeclarationContext) VAR() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAR, 0)
}

func (s *PropertyDeclarationContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *PropertyDeclarationContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *PropertyDeclarationContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *PropertyDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *PropertyDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *PropertyDeclarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDeclarationContext) Getter() IGetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyDeclarationContext) Setter() ISetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertyDeclarationContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *PropertyDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *PropertyDeclarationContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *PropertyDeclarationContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *PropertyDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PropertyDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PropertyDeclarationContext) Semi() ISemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemiContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitPropertyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, KotlinParserRULE_propertyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(971)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(970)
			p.ModifierList()
		}

	}
	{
		p.SetState(973)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserVAL || _la == KotlinParserVAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(981)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
		p.SetState(977)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(974)
				p.Match(KotlinParserNL)
			}

			p.SetState(979)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(980)
			p.TypeParameters()
		}

	}
	p.SetState(998)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		p.SetState(986)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(983)
				p.Match(KotlinParserNL)
			}

			p.SetState(988)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(989)
			p.Type()
		}
		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(990)
				p.Match(KotlinParserNL)
			}

			p.SetState(995)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(996)
			p.Match(KotlinParserDOT)
		}

	}

	p.SetState(1003)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1000)
			p.Match(KotlinParserNL)
		}

		p.SetState(1005)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1008)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN:
		{
			p.SetState(1006)
			p.MultiVariableDeclaration()
		}

	case KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserGETTER, KotlinParserSETTER, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserIdentifier:
		{
			p.SetState(1007)
			p.VariableDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	p.SetState(1017)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
		p.SetState(1013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1010)
				p.Match(KotlinParserNL)
			}

			p.SetState(1015)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1016)
			p.TypeConstraints()
		}

	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
		p.SetState(1022)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1019)
				p.Match(KotlinParserNL)
			}

			p.SetState(1024)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1025)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KotlinParserASSIGNMENT || _la == KotlinParserBY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1029)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1026)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(1031)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())
		}
		{
			p.SetState(1032)
			p.Expression()
		}

	}
	p.SetState(1047)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1035)
			p.Getter()
		}
		p.SetState(1039)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1036)
				p.Semi()
			}
			{
				p.SetState(1037)
				p.Setter()
			}

		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1041)
			p.Setter()
		}
		p.SetState(1045)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1042)
				p.Semi()
			}
			{
				p.SetState(1043)
				p.Getter()
			}

		}

	}

	return localctx
}

// IMultiVariableDeclarationContext is an interface to support dynamic dispatch.
type IMultiVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiVariableDeclarationContext differentiates from other interfaces.
	IsMultiVariableDeclarationContext()
}

type MultiVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiVariableDeclarationContext() *MultiVariableDeclarationContext {
	var p = new(MultiVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiVariableDeclaration
	return p
}

func (*MultiVariableDeclarationContext) IsMultiVariableDeclarationContext() {}

func NewMultiVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiVariableDeclarationContext {
	var p = new(MultiVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiVariableDeclaration

	return p
}

func (s *MultiVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiVariableDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *MultiVariableDeclarationContext) AllVariableDeclaration() []IVariableDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem())
	var tst = make([]IVariableDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableDeclarationContext)
		}
	}

	return tst
}

func (s *MultiVariableDeclarationContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *MultiVariableDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *MultiVariableDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *MultiVariableDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *MultiVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiVariableDeclaration(s)
	}
}

func (s *MultiVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiVariableDeclaration(s)
	}
}

func (s *MultiVariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitMultiVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) MultiVariableDeclaration() (localctx IMultiVariableDeclarationContext) {
	localctx = NewMultiVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, KotlinParserRULE_multiVariableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1049)
		p.Match(KotlinParserLPAREN)
	}
	{
		p.SetState(1050)
		p.VariableDeclaration()
	}
	p.SetState(1055)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserCOMMA {
		{
			p.SetState(1051)
			p.Match(KotlinParserCOMMA)
		}
		{
			p.SetState(1052)
			p.VariableDeclaration()
		}

		p.SetState(1057)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1058)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *VariableDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *VariableDeclarationContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, KotlinParserRULE_variableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1060)
		p.SimpleIdentifier()
	}
	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserCOLON {
		{
			p.SetState(1061)
			p.Match(KotlinParserCOLON)
		}
		{
			p.SetState(1062)
			p.Type()
		}

	}

	return localctx
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_getter
	return p
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) GETTER() antlr.TerminalNode {
	return s.GetToken(KotlinParserGETTER, 0)
}

func (s *GetterContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *GetterContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *GetterContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *GetterContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *GetterContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *GetterContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GetterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *GetterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *GetterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *GetterContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitGetter(s)
	}
}

func (s *GetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Getter() (localctx IGetterContext) {
	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, KotlinParserRULE_getter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1114)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
			{
				p.SetState(1065)
				p.ModifierList()
			}

		}
		{
			p.SetState(1068)
			p.Match(KotlinParserGETTER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
			{
				p.SetState(1069)
				p.ModifierList()
			}

		}
		{
			p.SetState(1072)
			p.Match(KotlinParserGETTER)
		}
		p.SetState(1076)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1073)
				p.Match(KotlinParserNL)
			}

			p.SetState(1078)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1079)
			p.Match(KotlinParserLPAREN)
		}
		{
			p.SetState(1080)
			p.Match(KotlinParserRPAREN)
		}
		p.SetState(1095)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) == 1 {
			p.SetState(1084)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1081)
					p.Match(KotlinParserNL)
				}

				p.SetState(1086)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1087)
				p.Match(KotlinParserCOLON)
			}
			p.SetState(1091)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1088)
					p.Match(KotlinParserNL)
				}

				p.SetState(1093)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1094)
				p.Type()
			}

		}
		p.SetState(1100)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1097)
				p.Match(KotlinParserNL)
			}

			p.SetState(1102)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1112)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KotlinParserLCURL:
			{
				p.SetState(1103)
				p.Block()
			}

		case KotlinParserASSIGNMENT:
			{
				p.SetState(1104)
				p.Match(KotlinParserASSIGNMENT)
			}
			p.SetState(1108)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1105)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1110)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
			}
			{
				p.SetState(1111)
				p.Expression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_setter
	return p
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) SETTER() antlr.TerminalNode {
	return s.GetToken(KotlinParserSETTER, 0)
}

func (s *SetterContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *SetterContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *SetterContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *SetterContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *SetterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SetterContext) Parameter() IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *SetterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SetterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SetterContext) AllAnnotations() []IAnnotationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem())
	var tst = make([]IAnnotationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsContext)
		}
	}

	return tst
}

func (s *SetterContext) Annotations(i int) IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *SetterContext) AllParameterModifier() []IParameterModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterModifierContext)(nil)).Elem())
	var tst = make([]IParameterModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterModifierContext)
		}
	}

	return tst
}

func (s *SetterContext) ParameterModifier(i int) IParameterModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterModifierContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSetter(s)
	}
}

func (s *SetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitSetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Setter() (localctx ISetterContext) {
	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, KotlinParserRULE_setter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1151)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1117)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
			{
				p.SetState(1116)
				p.ModifierList()
			}

		}
		{
			p.SetState(1119)
			p.Match(KotlinParserSETTER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1121)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
			{
				p.SetState(1120)
				p.ModifierList()
			}

		}
		{
			p.SetState(1123)
			p.Match(KotlinParserSETTER)
		}
		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1124)
				p.Match(KotlinParserNL)
			}

			p.SetState(1129)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1130)
			p.Match(KotlinParserLPAREN)
		}
		p.SetState(1135)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1133)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case KotlinParserAT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserLabelReference:
					{
						p.SetState(1131)
						p.Annotations()
					}

				case KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE:
					{
						p.SetState(1132)
						p.ParameterModifier()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			}
			p.SetState(1137)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext())
		}
		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1138)
				p.SimpleIdentifier()
			}

		case 2:
			{
				p.SetState(1139)
				p.Parameter()
			}

		}
		{
			p.SetState(1142)
			p.Match(KotlinParserRPAREN)
		}
		p.SetState(1146)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1143)
				p.Match(KotlinParserNL)
			}

			p.SetState(1148)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1149)
			p.FunctionBody()
		}

	}

	return localctx
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeAlias
	return p
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) TYPE_ALIAS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTYPE_ALIAS, 0)
}

func (s *TypeAliasContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeAliasContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *TypeAliasContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeAliasContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *TypeAliasContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeAliasContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeAliasContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (s *TypeAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeAlias() (localctx ITypeAliasContext) {
	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, KotlinParserRULE_typeAlias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1154)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(KotlinParserIN-89))|(1<<(KotlinParserOUT-89))|(1<<(KotlinParserFIELD-89))|(1<<(KotlinParserPROPERTY-89))|(1<<(KotlinParserGET-89))|(1<<(KotlinParserSET-89))|(1<<(KotlinParserRECEIVER-89))|(1<<(KotlinParserPARAM-89))|(1<<(KotlinParserSETPARAM-89))|(1<<(KotlinParserDELEGATE-89))|(1<<(KotlinParserPUBLIC-89))|(1<<(KotlinParserPRIVATE-89))|(1<<(KotlinParserPROTECTED-89))|(1<<(KotlinParserINTERNAL-89))|(1<<(KotlinParserENUM-89))|(1<<(KotlinParserSEALED-89))|(1<<(KotlinParserANNOTATION-89))|(1<<(KotlinParserDATA-89))|(1<<(KotlinParserINNER-89))|(1<<(KotlinParserTAILREC-89))|(1<<(KotlinParserOPERATOR-89))|(1<<(KotlinParserINLINE-89))|(1<<(KotlinParserINFIX-89))|(1<<(KotlinParserEXTERNAL-89))|(1<<(KotlinParserSUSPEND-89))|(1<<(KotlinParserOVERRIDE-89))|(1<<(KotlinParserABSTRACT-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(KotlinParserFINAL-121))|(1<<(KotlinParserOPEN-121))|(1<<(KotlinParserCONST-121))|(1<<(KotlinParserLATEINIT-121))|(1<<(KotlinParserVARARG-121))|(1<<(KotlinParserNOINLINE-121))|(1<<(KotlinParserCROSSINLINE-121))|(1<<(KotlinParserREIFIED-121))|(1<<(KotlinParserLabelReference-121)))) != 0) {
		{
			p.SetState(1153)
			p.ModifierList()
		}

	}
	{
		p.SetState(1156)
		p.Match(KotlinParserTYPE_ALIAS)
	}
	p.SetState(1160)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1157)
			p.Match(KotlinParserNL)
		}

		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1163)
		p.SimpleIdentifier()
	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext()) == 1 {
		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1164)
				p.Match(KotlinParserNL)
			}

			p.SetState(1169)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1170)
			p.TypeParameters()
		}

	}
	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1173)
			p.Match(KotlinParserNL)
		}

		p.SetState(1178)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1179)
		p.Match(KotlinParserASSIGNMENT)
	}
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1180)
			p.Match(KotlinParserNL)
		}

		p.SetState(1185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1186)
		p.Type()
	}

	return localctx
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameters
	return p
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *TypeParametersContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParametersContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *TypeParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (s *TypeParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, KotlinParserRULE_typeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1188)
		p.Match(KotlinParserLANGLE)
	}
	p.SetState(1192)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1189)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1194)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())
	}
	{
		p.SetState(1195)
		p.TypeParameter()
	}
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1199)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1196)
					p.Match(KotlinParserNL)
				}

				p.SetState(1201)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1202)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(1206)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1203)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1208)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext())
			}
			{
				p.SetState(1209)
				p.TypeParameter()
			}

		}
		p.SetState(1214)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())
	}
	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1215)
			p.Match(KotlinParserNL)
		}

		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1221)
		p.Match(KotlinParserRANGLE)
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeParameterContext) ModifierList() IModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierListContext)
}

func (s *TypeParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *TypeParameterContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, KotlinParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1224)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1223)
			p.ModifierList()
		}

	}
	p.SetState(1229)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1226)
			p.Match(KotlinParserNL)
		}

		p.SetState(1231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1232)
		p.SimpleIdentifier()
	}
	p.SetState(1247)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
		p.SetState(1236)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1233)
				p.Match(KotlinParserNL)
			}

			p.SetState(1238)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1239)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(1243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1240)
				p.Match(KotlinParserNL)
			}

			p.SetState(1245)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1246)
			p.Type()
		}

	}

	return localctx
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_type
	return p
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) FunctionType() IFunctionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *TypeContext) NullableType() INullableTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullableTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullableTypeContext)
}

func (s *TypeContext) TypeReference() ITypeReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *TypeContext) TypeModifierList() ITypeModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeModifierListContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitType(s)
	}
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Type() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, KotlinParserRULE_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1249)
			p.TypeModifierList()
		}

	}
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1252)
			p.FunctionType()
		}

	case 2:
		{
			p.SetState(1253)
			p.ParenthesizedType()
		}

	case 3:
		{
			p.SetState(1254)
			p.NullableType()
		}

	case 4:
		{
			p.SetState(1255)
			p.TypeReference()
		}

	}

	return localctx
}

// ITypeModifierListContext is an interface to support dynamic dispatch.
type ITypeModifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeModifierListContext differentiates from other interfaces.
	IsTypeModifierListContext()
}

type TypeModifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeModifierListContext() *TypeModifierListContext {
	var p = new(TypeModifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeModifierList
	return p
}

func (*TypeModifierListContext) IsTypeModifierListContext() {}

func NewTypeModifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeModifierListContext {
	var p = new(TypeModifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeModifierList

	return p
}

func (s *TypeModifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeModifierListContext) AllAnnotations() []IAnnotationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem())
	var tst = make([]IAnnotationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsContext)
		}
	}

	return tst
}

func (s *TypeModifierListContext) Annotations(i int) IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *TypeModifierListContext) AllSUSPEND() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserSUSPEND)
}

func (s *TypeModifierListContext) SUSPEND(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, i)
}

func (s *TypeModifierListContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeModifierListContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeModifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeModifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeModifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeModifierList(s)
	}
}

func (s *TypeModifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeModifierList(s)
	}
}

func (s *TypeModifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeModifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeModifierList() (localctx ITypeModifierListContext) {
	localctx = NewTypeModifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, KotlinParserRULE_typeModifierList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1266)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1266)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserAT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserLabelReference:
				{
					p.SetState(1258)
					p.Annotations()
				}

			case KotlinParserSUSPEND:
				{
					p.SetState(1259)
					p.Match(KotlinParserSUSPEND)
				}
				p.SetState(1263)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(1260)
						p.Match(KotlinParserNL)
					}

					p.SetState(1265)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1268)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext())
	}

	return localctx
}

// IParenthesizedTypeContext is an interface to support dynamic dispatch.
type IParenthesizedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedTypeContext differentiates from other interfaces.
	IsParenthesizedTypeContext()
}

type ParenthesizedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedTypeContext() *ParenthesizedTypeContext {
	var p = new(ParenthesizedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedType
	return p
}

func (*ParenthesizedTypeContext) IsParenthesizedTypeContext() {}

func NewParenthesizedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedTypeContext {
	var p = new(ParenthesizedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedType

	return p
}

func (s *ParenthesizedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedTypeContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParenthesizedTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedType(s)
	}
}

func (s *ParenthesizedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedType(s)
	}
}

func (s *ParenthesizedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitParenthesizedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ParenthesizedType() (localctx IParenthesizedTypeContext) {
	localctx = NewParenthesizedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, KotlinParserRULE_parenthesizedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1270)
		p.Match(KotlinParserLPAREN)
	}
	{
		p.SetState(1271)
		p.Type()
	}
	{
		p.SetState(1272)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// INullableTypeContext is an interface to support dynamic dispatch.
type INullableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullableTypeContext differentiates from other interfaces.
	IsNullableTypeContext()
}

type NullableTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullableTypeContext() *NullableTypeContext {
	var p = new(NullableTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_nullableType
	return p
}

func (*NullableTypeContext) IsNullableTypeContext() {}

func NewNullableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullableTypeContext {
	var p = new(NullableTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_nullableType

	return p
}

func (s *NullableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NullableTypeContext) TypeReference() ITypeReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *NullableTypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *NullableTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *NullableTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *NullableTypeContext) AllQUEST() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserQUEST)
}

func (s *NullableTypeContext) QUEST(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST, i)
}

func (s *NullableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterNullableType(s)
	}
}

func (s *NullableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitNullableType(s)
	}
}

func (s *NullableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitNullableType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) NullableType() (localctx INullableTypeContext) {
	localctx = NewNullableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, KotlinParserRULE_nullableType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1276)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1274)
			p.TypeReference()
		}

	case 2:
		{
			p.SetState(1275)
			p.ParenthesizedType()
		}

	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1278)
			p.Match(KotlinParserNL)
		}

		p.SetState(1283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1284)
				p.Match(KotlinParserQUEST)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1287)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeReferenceContext is an interface to support dynamic dispatch.
type ITypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeReferenceContext differentiates from other interfaces.
	IsTypeReferenceContext()
}

type TypeReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeReferenceContext() *TypeReferenceContext {
	var p = new(TypeReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeReference
	return p
}

func (*TypeReferenceContext) IsTypeReferenceContext() {}

func NewTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeReferenceContext {
	var p = new(TypeReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeReference

	return p
}

func (s *TypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeReferenceContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *TypeReferenceContext) TypeReference() ITypeReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *TypeReferenceContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *TypeReferenceContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *TypeReferenceContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserDYNAMIC, 0)
}

func (s *TypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeReference(s)
	}
}

func (s *TypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeReference(s)
	}
}

func (s *TypeReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeReference() (localctx ITypeReferenceContext) {
	localctx = NewTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, KotlinParserRULE_typeReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1295)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1289)
			p.Match(KotlinParserLPAREN)
		}
		{
			p.SetState(1290)
			p.TypeReference()
		}
		{
			p.SetState(1291)
			p.Match(KotlinParserRPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1293)
			p.UserType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1294)
			p.Match(KotlinParserDYNAMIC)
		}

	}

	return localctx
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionType
	return p
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FunctionTypeParameters() IFunctionTypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionTypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeParametersContext)
}

func (s *FunctionTypeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *FunctionTypeContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FunctionTypeContext) FunctionTypeReceiver() IFunctionTypeReceiverContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionTypeReceiverContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeReceiverContext)
}

func (s *FunctionTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *FunctionTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, KotlinParserRULE_functionType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1311)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1297)
			p.FunctionTypeReceiver()
		}
		p.SetState(1301)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1298)
				p.Match(KotlinParserNL)
			}

			p.SetState(1303)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1304)
			p.Match(KotlinParserDOT)
		}
		p.SetState(1308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1305)
				p.Match(KotlinParserNL)
			}

			p.SetState(1310)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1313)
		p.FunctionTypeParameters()
	}
	p.SetState(1317)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1314)
			p.Match(KotlinParserNL)
		}

		p.SetState(1319)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1320)
		p.Match(KotlinParserARROW)
	}

	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1321)
			p.Match(KotlinParserNL)
		}

		p.SetState(1326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1327)
		p.Type()
	}

	return localctx
}

// IFunctionTypeReceiverContext is an interface to support dynamic dispatch.
type IFunctionTypeReceiverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionTypeReceiverContext differentiates from other interfaces.
	IsFunctionTypeReceiverContext()
}

type FunctionTypeReceiverContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeReceiverContext() *FunctionTypeReceiverContext {
	var p = new(FunctionTypeReceiverContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionTypeReceiver
	return p
}

func (*FunctionTypeReceiverContext) IsFunctionTypeReceiverContext() {}

func NewFunctionTypeReceiverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeReceiverContext {
	var p = new(FunctionTypeReceiverContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionTypeReceiver

	return p
}

func (s *FunctionTypeReceiverContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeReceiverContext) ParenthesizedType() IParenthesizedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *FunctionTypeReceiverContext) NullableType() INullableTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullableTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullableTypeContext)
}

func (s *FunctionTypeReceiverContext) TypeReference() ITypeReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *FunctionTypeReceiverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeReceiverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeReceiverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionTypeReceiver(s)
	}
}

func (s *FunctionTypeReceiverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionTypeReceiver(s)
	}
}

func (s *FunctionTypeReceiverContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFunctionTypeReceiver(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FunctionTypeReceiver() (localctx IFunctionTypeReceiverContext) {
	localctx = NewFunctionTypeReceiverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, KotlinParserRULE_functionTypeReceiver)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1332)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1329)
			p.ParenthesizedType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1330)
			p.NullableType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1331)
			p.TypeReference()
		}

	}

	return localctx
}

// IUserTypeContext is an interface to support dynamic dispatch.
type IUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserTypeContext differentiates from other interfaces.
	IsUserTypeContext()
}

type UserTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserTypeContext() *UserTypeContext {
	var p = new(UserTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_userType
	return p
}

func (*UserTypeContext) IsUserTypeContext() {}

func NewUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserTypeContext {
	var p = new(UserTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_userType

	return p
}

func (s *UserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UserTypeContext) AllSimpleUserType() []ISimpleUserTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleUserTypeContext)(nil)).Elem())
	var tst = make([]ISimpleUserTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleUserTypeContext)
		}
	}

	return tst
}

func (s *UserTypeContext) SimpleUserType(i int) ISimpleUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleUserTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleUserTypeContext)
}

func (s *UserTypeContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDOT)
}

func (s *UserTypeContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, i)
}

func (s *UserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *UserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *UserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUserType(s)
	}
}

func (s *UserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUserType(s)
	}
}

func (s *UserTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitUserType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) UserType() (localctx IUserTypeContext) {
	localctx = NewUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, KotlinParserRULE_userType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1334)
		p.SimpleUserType()
	}
	p.SetState(1351)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1338)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1335)
					p.Match(KotlinParserNL)
				}

				p.SetState(1340)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1341)
				p.Match(KotlinParserDOT)
			}
			p.SetState(1345)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1342)
					p.Match(KotlinParserNL)
				}

				p.SetState(1347)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1348)
				p.SimpleUserType()
			}

		}
		p.SetState(1353)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())
	}

	return localctx
}

// ISimpleUserTypeContext is an interface to support dynamic dispatch.
type ISimpleUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleUserTypeContext differentiates from other interfaces.
	IsSimpleUserTypeContext()
}

type SimpleUserTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleUserTypeContext() *SimpleUserTypeContext {
	var p = new(SimpleUserTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_simpleUserType
	return p
}

func (*SimpleUserTypeContext) IsSimpleUserTypeContext() {}

func NewSimpleUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleUserTypeContext {
	var p = new(SimpleUserTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_simpleUserType

	return p
}

func (s *SimpleUserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleUserTypeContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SimpleUserTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *SimpleUserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SimpleUserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SimpleUserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleUserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleUserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSimpleUserType(s)
	}
}

func (s *SimpleUserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSimpleUserType(s)
	}
}

func (s *SimpleUserTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitSimpleUserType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) SimpleUserType() (localctx ISimpleUserTypeContext) {
	localctx = NewSimpleUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, KotlinParserRULE_simpleUserType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1354)
		p.SimpleIdentifier()
	}
	p.SetState(1362)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext()) == 1 {
		p.SetState(1358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1355)
				p.Match(KotlinParserNL)
			}

			p.SetState(1360)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1361)
			p.TypeArguments()
		}

	}

	return localctx
}

// IFunctionTypeParametersContext is an interface to support dynamic dispatch.
type IFunctionTypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionTypeParametersContext differentiates from other interfaces.
	IsFunctionTypeParametersContext()
}

type FunctionTypeParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeParametersContext() *FunctionTypeParametersContext {
	var p = new(FunctionTypeParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionTypeParameters
	return p
}

func (*FunctionTypeParametersContext) IsFunctionTypeParametersContext() {}

func NewFunctionTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeParametersContext {
	var p = new(FunctionTypeParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionTypeParameters

	return p
}

func (s *FunctionTypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *FunctionTypeParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *FunctionTypeParametersContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *FunctionTypeParametersContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *FunctionTypeParametersContext) AllType() []ITypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeContext)(nil)).Elem())
	var tst = make([]ITypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeContext)
		}
	}

	return tst
}

func (s *FunctionTypeParametersContext) Type(i int) ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FunctionTypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *FunctionTypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *FunctionTypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionTypeParameters(s)
	}
}

func (s *FunctionTypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionTypeParameters(s)
	}
}

func (s *FunctionTypeParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFunctionTypeParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FunctionTypeParameters() (localctx IFunctionTypeParametersContext) {
	localctx = NewFunctionTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, KotlinParserRULE_functionTypeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1364)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1367)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 199, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1365)
			p.Parameter()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 199, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1366)
			p.Type()
		}

	}
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserCOMMA {
		{
			p.SetState(1369)
			p.Match(KotlinParserCOMMA)
		}
		p.SetState(1372)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1370)
				p.Parameter()
			}

		case 2:
			{
				p.SetState(1371)
				p.Type()
			}

		}

		p.SetState(1378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1379)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// ITypeConstraintsContext is an interface to support dynamic dispatch.
type ITypeConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeConstraintsContext differentiates from other interfaces.
	IsTypeConstraintsContext()
}

type TypeConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConstraintsContext() *TypeConstraintsContext {
	var p = new(TypeConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeConstraints
	return p
}

func (*TypeConstraintsContext) IsTypeConstraintsContext() {}

func NewTypeConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConstraintsContext {
	var p = new(TypeConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeConstraints

	return p
}

func (s *TypeConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConstraintsContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHERE, 0)
}

func (s *TypeConstraintsContext) AllTypeConstraint() []ITypeConstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeConstraintContext)(nil)).Elem())
	var tst = make([]ITypeConstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeConstraintContext)
		}
	}

	return tst
}

func (s *TypeConstraintsContext) TypeConstraint(i int) ITypeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeConstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintContext)
}

func (s *TypeConstraintsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeConstraintsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeConstraintsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeConstraintsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeConstraints(s)
	}
}

func (s *TypeConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeConstraints(s)
	}
}

func (s *TypeConstraintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeConstraints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeConstraints() (localctx ITypeConstraintsContext) {
	localctx = NewTypeConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, KotlinParserRULE_typeConstraints)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1381)
		p.Match(KotlinParserWHERE)
	}
	p.SetState(1385)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1382)
			p.Match(KotlinParserNL)
		}

		p.SetState(1387)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1388)
		p.TypeConstraint()
	}
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1392)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1389)
					p.Match(KotlinParserNL)
				}

				p.SetState(1394)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1395)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(1399)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1396)
					p.Match(KotlinParserNL)
				}

				p.SetState(1401)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1402)
				p.TypeConstraint()
			}

		}
		p.SetState(1407)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeConstraintContext is an interface to support dynamic dispatch.
type ITypeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeConstraintContext differentiates from other interfaces.
	IsTypeConstraintContext()
}

type TypeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConstraintContext() *TypeConstraintContext {
	var p = new(TypeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeConstraint
	return p
}

func (*TypeConstraintContext) IsTypeConstraintContext() {}

func NewTypeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConstraintContext {
	var p = new(TypeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeConstraint

	return p
}

func (s *TypeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConstraintContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeConstraintContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *TypeConstraintContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeConstraintContext) AllAnnotations() []IAnnotationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem())
	var tst = make([]IAnnotationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsContext)
		}
	}

	return tst
}

func (s *TypeConstraintContext) Annotations(i int) IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *TypeConstraintContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeConstraintContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeConstraint(s)
	}
}

func (s *TypeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeConstraint(s)
	}
}

func (s *TypeConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeConstraint() (localctx ITypeConstraintContext) {
	localctx = NewTypeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, KotlinParserRULE_typeConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(KotlinParserFIELD-93))|(1<<(KotlinParserPROPERTY-93))|(1<<(KotlinParserGET-93))|(1<<(KotlinParserSET-93))|(1<<(KotlinParserRECEIVER-93))|(1<<(KotlinParserPARAM-93))|(1<<(KotlinParserSETPARAM-93))|(1<<(KotlinParserDELEGATE-93)))) != 0) || _la == KotlinParserLabelReference {
		{
			p.SetState(1408)
			p.Annotations()
		}

		p.SetState(1413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1414)
		p.SimpleIdentifier()
	}
	p.SetState(1418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1415)
			p.Match(KotlinParserNL)
		}

		p.SetState(1420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1421)
		p.Match(KotlinParserCOLON)
	}
	p.SetState(1425)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1422)
			p.Match(KotlinParserNL)
		}

		p.SetState(1427)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1428)
		p.Type()
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *BlockContext) Statements() IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *BlockContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, KotlinParserRULE_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1430)
		p.Match(KotlinParserLCURL)
	}
	{
		p.SetState(1431)
		p.Statements()
	}
	{
		p.SetState(1432)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllAnysemi() []IAnysemiContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnysemiContext)(nil)).Elem())
	var tst = make([]IAnysemiContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnysemiContext)
		}
	}

	return tst
}

func (s *StatementsContext) Anysemi(i int) IAnysemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnysemiContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnysemiContext)
}

func (s *StatementsContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (s *StatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, KotlinParserRULE_statements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1434)
				p.Anysemi()
			}

		}
		p.SetState(1439)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext())
	}
	p.SetState(1454)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1440)
			p.Statement()
		}
		p.SetState(1451)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1442)
				p.GetErrorHandler().Sync(p)
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
						{
							p.SetState(1441)
							p.Anysemi()
						}

					default:
						panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					}

					p.SetState(1444)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext())
				}
				p.SetState(1447)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1446)
						p.Statement()
					}

				}

			}
			p.SetState(1453)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *StatementContext) BlockLevelExpression() IBlockLevelExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockLevelExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockLevelExpressionContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, KotlinParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1456)
			p.Declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1457)
			p.BlockLevelExpression()
		}

	}

	return localctx
}

// IBlockLevelExpressionContext is an interface to support dynamic dispatch.
type IBlockLevelExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockLevelExpressionContext differentiates from other interfaces.
	IsBlockLevelExpressionContext()
}

type BlockLevelExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockLevelExpressionContext() *BlockLevelExpressionContext {
	var p = new(BlockLevelExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_blockLevelExpression
	return p
}

func (*BlockLevelExpressionContext) IsBlockLevelExpressionContext() {}

func NewBlockLevelExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockLevelExpressionContext {
	var p = new(BlockLevelExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_blockLevelExpression

	return p
}

func (s *BlockLevelExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockLevelExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BlockLevelExpressionContext) AllAnnotations() []IAnnotationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem())
	var tst = make([]IAnnotationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsContext)
		}
	}

	return tst
}

func (s *BlockLevelExpressionContext) Annotations(i int) IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *BlockLevelExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *BlockLevelExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *BlockLevelExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockLevelExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockLevelExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterBlockLevelExpression(s)
	}
}

func (s *BlockLevelExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitBlockLevelExpression(s)
	}
}

func (s *BlockLevelExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitBlockLevelExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) BlockLevelExpression() (localctx IBlockLevelExpressionContext) {
	localctx = NewBlockLevelExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, KotlinParserRULE_blockLevelExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1463)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1460)
				p.Annotations()
			}

		}
		p.SetState(1465)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext())
	}
	p.SetState(1469)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1466)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1471)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext())
	}
	{
		p.SetState(1472)
		p.Expression()
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *DeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclarationContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *DeclarationContext) TypeAlias() ITypeAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *DeclarationContext) AllLabelDefinition() []ILabelDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILabelDefinitionContext)(nil)).Elem())
	var tst = make([]ILabelDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILabelDefinitionContext)
		}
	}

	return tst
}

func (s *DeclarationContext) LabelDefinition(i int) ILabelDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILabelDefinitionContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, KotlinParserRULE_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserLabelDefinition {
		{
			p.SetState(1474)
			p.LabelDefinition()
		}

		p.SetState(1479)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1484)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 218, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1480)
			p.ClassDeclaration()
		}

	case 2:
		{
			p.SetState(1481)
			p.FunctionDeclaration()
		}

	case 3:
		{
			p.SetState(1482)
			p.PropertyDeclaration()
		}

	case 4:
		{
			p.SetState(1483)
			p.TypeAlias()
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllDisjunction() []IDisjunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDisjunctionContext)(nil)).Elem())
	var tst = make([]IDisjunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDisjunctionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Disjunction(i int) IDisjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisjunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDisjunctionContext)
}

func (s *ExpressionContext) AllAssignmentOperator() []IAssignmentOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentOperatorContext)(nil)).Elem())
	var tst = make([]IAssignmentOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentOperatorContext)
		}
	}

	return tst
}

func (s *ExpressionContext) AssignmentOperator(i int) IAssignmentOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, KotlinParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1486)
		p.Disjunction()
	}
	p.SetState(1492)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 219, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1487)
				p.AssignmentOperator()
			}
			{
				p.SetState(1488)
				p.Disjunction()
			}

		}
		p.SetState(1494)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 219, p.GetParserRuleContext())
	}

	return localctx
}

// IDisjunctionContext is an interface to support dynamic dispatch.
type IDisjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisjunctionContext differentiates from other interfaces.
	IsDisjunctionContext()
}

type DisjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisjunctionContext() *DisjunctionContext {
	var p = new(DisjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_disjunction
	return p
}

func (*DisjunctionContext) IsDisjunctionContext() {}

func NewDisjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisjunctionContext {
	var p = new(DisjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_disjunction

	return p
}

func (s *DisjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DisjunctionContext) AllConjunction() []IConjunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConjunctionContext)(nil)).Elem())
	var tst = make([]IConjunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConjunctionContext)
		}
	}

	return tst
}

func (s *DisjunctionContext) Conjunction(i int) IConjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConjunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConjunctionContext)
}

func (s *DisjunctionContext) AllDISJ() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDISJ)
}

func (s *DisjunctionContext) DISJ(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDISJ, i)
}

func (s *DisjunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DisjunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DisjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDisjunction(s)
	}
}

func (s *DisjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDisjunction(s)
	}
}

func (s *DisjunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitDisjunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Disjunction() (localctx IDisjunctionContext) {
	localctx = NewDisjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, KotlinParserRULE_disjunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1495)
		p.Conjunction()
	}
	p.SetState(1512)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1499)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1496)
					p.Match(KotlinParserNL)
				}

				p.SetState(1501)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1502)
				p.Match(KotlinParserDISJ)
			}
			p.SetState(1506)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 221, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1503)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1508)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 221, p.GetParserRuleContext())
			}
			{
				p.SetState(1509)
				p.Conjunction()
			}

		}
		p.SetState(1514)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext())
	}

	return localctx
}

// IConjunctionContext is an interface to support dynamic dispatch.
type IConjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConjunctionContext differentiates from other interfaces.
	IsConjunctionContext()
}

type ConjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConjunctionContext() *ConjunctionContext {
	var p = new(ConjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_conjunction
	return p
}

func (*ConjunctionContext) IsConjunctionContext() {}

func NewConjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConjunctionContext {
	var p = new(ConjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_conjunction

	return p
}

func (s *ConjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConjunctionContext) AllEqualityComparison() []IEqualityComparisonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEqualityComparisonContext)(nil)).Elem())
	var tst = make([]IEqualityComparisonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEqualityComparisonContext)
		}
	}

	return tst
}

func (s *ConjunctionContext) EqualityComparison(i int) IEqualityComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqualityComparisonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEqualityComparisonContext)
}

func (s *ConjunctionContext) AllCONJ() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCONJ)
}

func (s *ConjunctionContext) CONJ(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCONJ, i)
}

func (s *ConjunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ConjunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ConjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConjunction(s)
	}
}

func (s *ConjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConjunction(s)
	}
}

func (s *ConjunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitConjunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Conjunction() (localctx IConjunctionContext) {
	localctx = NewConjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, KotlinParserRULE_conjunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1515)
		p.EqualityComparison()
	}
	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1519)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1516)
					p.Match(KotlinParserNL)
				}

				p.SetState(1521)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1522)
				p.Match(KotlinParserCONJ)
			}
			p.SetState(1526)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1523)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1528)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext())
			}
			{
				p.SetState(1529)
				p.EqualityComparison()
			}

		}
		p.SetState(1534)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext())
	}

	return localctx
}

// IEqualityComparisonContext is an interface to support dynamic dispatch.
type IEqualityComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqualityComparisonContext differentiates from other interfaces.
	IsEqualityComparisonContext()
}

type EqualityComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityComparisonContext() *EqualityComparisonContext {
	var p = new(EqualityComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_equalityComparison
	return p
}

func (*EqualityComparisonContext) IsEqualityComparisonContext() {}

func NewEqualityComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityComparisonContext {
	var p = new(EqualityComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_equalityComparison

	return p
}

func (s *EqualityComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityComparisonContext) AllComparison() []IComparisonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComparisonContext)(nil)).Elem())
	var tst = make([]IComparisonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComparisonContext)
		}
	}

	return tst
}

func (s *EqualityComparisonContext) Comparison(i int) IComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *EqualityComparisonContext) AllEqualityOperation() []IEqualityOperationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEqualityOperationContext)(nil)).Elem())
	var tst = make([]IEqualityOperationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEqualityOperationContext)
		}
	}

	return tst
}

func (s *EqualityComparisonContext) EqualityOperation(i int) IEqualityOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqualityOperationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEqualityOperationContext)
}

func (s *EqualityComparisonContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EqualityComparisonContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EqualityComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEqualityComparison(s)
	}
}

func (s *EqualityComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEqualityComparison(s)
	}
}

func (s *EqualityComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitEqualityComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) EqualityComparison() (localctx IEqualityComparisonContext) {
	localctx = NewEqualityComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, KotlinParserRULE_equalityComparison)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1535)
		p.Comparison()
	}
	p.SetState(1547)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1536)
				p.EqualityOperation()
			}
			p.SetState(1540)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 226, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1537)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1542)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 226, p.GetParserRuleContext())
			}
			{
				p.SetState(1543)
				p.Comparison()
			}

		}
		p.SetState(1549)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext())
	}

	return localctx
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_comparison
	return p
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) AllNamedInfix() []INamedInfixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedInfixContext)(nil)).Elem())
	var tst = make([]INamedInfixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedInfixContext)
		}
	}

	return tst
}

func (s *ComparisonContext) NamedInfix(i int) INamedInfixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedInfixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedInfixContext)
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ComparisonContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Comparison() (localctx IComparisonContext) {
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, KotlinParserRULE_comparison)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1550)
		p.NamedInfix()
	}
	p.SetState(1560)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1551)
			p.ComparisonOperator()
		}
		p.SetState(1555)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 228, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1552)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(1557)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 228, p.GetParserRuleContext())
		}
		{
			p.SetState(1558)
			p.NamedInfix()
		}

	}

	return localctx
}

// INamedInfixContext is an interface to support dynamic dispatch.
type INamedInfixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedInfixContext differentiates from other interfaces.
	IsNamedInfixContext()
}

type NamedInfixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedInfixContext() *NamedInfixContext {
	var p = new(NamedInfixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_namedInfix
	return p
}

func (*NamedInfixContext) IsNamedInfixContext() {}

func NewNamedInfixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedInfixContext {
	var p = new(NamedInfixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_namedInfix

	return p
}

func (s *NamedInfixContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedInfixContext) AllElvisExpression() []IElvisExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElvisExpressionContext)(nil)).Elem())
	var tst = make([]IElvisExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElvisExpressionContext)
		}
	}

	return tst
}

func (s *NamedInfixContext) ElvisExpression(i int) IElvisExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElvisExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElvisExpressionContext)
}

func (s *NamedInfixContext) IsOperator() IIsOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIsOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIsOperatorContext)
}

func (s *NamedInfixContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *NamedInfixContext) AllInOperator() []IInOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInOperatorContext)(nil)).Elem())
	var tst = make([]IInOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInOperatorContext)
		}
	}

	return tst
}

func (s *NamedInfixContext) InOperator(i int) IInOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInOperatorContext)
}

func (s *NamedInfixContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *NamedInfixContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *NamedInfixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedInfixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedInfixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterNamedInfix(s)
	}
}

func (s *NamedInfixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitNamedInfix(s)
	}
}

func (s *NamedInfixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitNamedInfix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) NamedInfix() (localctx INamedInfixContext) {
	localctx = NewNamedInfixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, KotlinParserRULE_namedInfix)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1562)
		p.ElvisExpression()
	}
	p.SetState(1585)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) == 1 {
		p.SetState(1572)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1563)
					p.InOperator()
				}
				p.SetState(1567)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(1564)
							p.Match(KotlinParserNL)
						}

					}
					p.SetState(1569)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext())
				}
				{
					p.SetState(1570)
					p.ElvisExpression()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1574)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext())
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1576)
			p.IsOperator()
		}
		p.SetState(1580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1577)
				p.Match(KotlinParserNL)
			}

			p.SetState(1582)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1583)
			p.Type()
		}

	}

	return localctx
}

// IElvisExpressionContext is an interface to support dynamic dispatch.
type IElvisExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElvisExpressionContext differentiates from other interfaces.
	IsElvisExpressionContext()
}

type ElvisExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElvisExpressionContext() *ElvisExpressionContext {
	var p = new(ElvisExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_elvisExpression
	return p
}

func (*ElvisExpressionContext) IsElvisExpressionContext() {}

func NewElvisExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElvisExpressionContext {
	var p = new(ElvisExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_elvisExpression

	return p
}

func (s *ElvisExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ElvisExpressionContext) AllInfixFunctionCall() []IInfixFunctionCallContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInfixFunctionCallContext)(nil)).Elem())
	var tst = make([]IInfixFunctionCallContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInfixFunctionCallContext)
		}
	}

	return tst
}

func (s *ElvisExpressionContext) InfixFunctionCall(i int) IInfixFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfixFunctionCallContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInfixFunctionCallContext)
}

func (s *ElvisExpressionContext) AllELVIS() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserELVIS)
}

func (s *ElvisExpressionContext) ELVIS(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserELVIS, i)
}

func (s *ElvisExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ElvisExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ElvisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElvisExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElvisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterElvisExpression(s)
	}
}

func (s *ElvisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitElvisExpression(s)
	}
}

func (s *ElvisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitElvisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ElvisExpression() (localctx IElvisExpressionContext) {
	localctx = NewElvisExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, KotlinParserRULE_elvisExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1587)
		p.InfixFunctionCall()
	}
	p.SetState(1604)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1591)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1588)
					p.Match(KotlinParserNL)
				}

				p.SetState(1593)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1594)
				p.Match(KotlinParserELVIS)
			}
			p.SetState(1598)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 235, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1595)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1600)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 235, p.GetParserRuleContext())
			}
			{
				p.SetState(1601)
				p.InfixFunctionCall()
			}

		}
		p.SetState(1606)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext())
	}

	return localctx
}

// IInfixFunctionCallContext is an interface to support dynamic dispatch.
type IInfixFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfixFunctionCallContext differentiates from other interfaces.
	IsInfixFunctionCallContext()
}

type InfixFunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfixFunctionCallContext() *InfixFunctionCallContext {
	var p = new(InfixFunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_infixFunctionCall
	return p
}

func (*InfixFunctionCallContext) IsInfixFunctionCallContext() {}

func NewInfixFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InfixFunctionCallContext {
	var p = new(InfixFunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_infixFunctionCall

	return p
}

func (s *InfixFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *InfixFunctionCallContext) AllRangeExpression() []IRangeExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRangeExpressionContext)(nil)).Elem())
	var tst = make([]IRangeExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRangeExpressionContext)
		}
	}

	return tst
}

func (s *InfixFunctionCallContext) RangeExpression(i int) IRangeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRangeExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRangeExpressionContext)
}

func (s *InfixFunctionCallContext) AllSimpleIdentifier() []ISimpleIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem())
	var tst = make([]ISimpleIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleIdentifierContext)
		}
	}

	return tst
}

func (s *InfixFunctionCallContext) SimpleIdentifier(i int) ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *InfixFunctionCallContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *InfixFunctionCallContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *InfixFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InfixFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InfixFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInfixFunctionCall(s)
	}
}

func (s *InfixFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInfixFunctionCall(s)
	}
}

func (s *InfixFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitInfixFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) InfixFunctionCall() (localctx IInfixFunctionCallContext) {
	localctx = NewInfixFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, KotlinParserRULE_infixFunctionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1607)
		p.RangeExpression()
	}
	p.SetState(1619)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 238, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1608)
				p.SimpleIdentifier()
			}
			p.SetState(1612)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1609)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1614)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())
			}
			{
				p.SetState(1615)
				p.RangeExpression()
			}

		}
		p.SetState(1621)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 238, p.GetParserRuleContext())
	}

	return localctx
}

// IRangeExpressionContext is an interface to support dynamic dispatch.
type IRangeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeExpressionContext differentiates from other interfaces.
	IsRangeExpressionContext()
}

type RangeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExpressionContext() *RangeExpressionContext {
	var p = new(RangeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_rangeExpression
	return p
}

func (*RangeExpressionContext) IsRangeExpressionContext() {}

func NewRangeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExpressionContext {
	var p = new(RangeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_rangeExpression

	return p
}

func (s *RangeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditiveExpressionContext)(nil)).Elem())
	var tst = make([]IAdditiveExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditiveExpressionContext)
		}
	}

	return tst
}

func (s *RangeExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *RangeExpressionContext) AllRANGE() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserRANGE)
}

func (s *RangeExpressionContext) RANGE(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGE, i)
}

func (s *RangeExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *RangeExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *RangeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterRangeExpression(s)
	}
}

func (s *RangeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitRangeExpression(s)
	}
}

func (s *RangeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitRangeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) RangeExpression() (localctx IRangeExpressionContext) {
	localctx = NewRangeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, KotlinParserRULE_rangeExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1622)
		p.AdditiveExpression()
	}
	p.SetState(1633)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 240, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1623)
				p.Match(KotlinParserRANGE)
			}
			p.SetState(1627)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 239, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1624)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1629)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 239, p.GetParserRuleContext())
			}
			{
				p.SetState(1630)
				p.AdditiveExpression()
			}

		}
		p.SetState(1635)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 240, p.GetParserRuleContext())
	}

	return localctx
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_additiveExpression
	return p
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicativeExpressionContext)(nil)).Elem())
	var tst = make([]IMultiplicativeExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicativeExpressionContext)
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) AllAdditiveOperator() []IAdditiveOperatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditiveOperatorContext)(nil)).Elem())
	var tst = make([]IAdditiveOperatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditiveOperatorContext)
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) AdditiveOperator(i int) IAdditiveOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveOperatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditiveOperatorContext)
}

func (s *AdditiveExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AdditiveExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, KotlinParserRULE_additiveExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1636)
		p.MultiplicativeExpression()
	}
	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1637)
				p.AdditiveOperator()
			}
			p.SetState(1641)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 241, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1638)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1643)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 241, p.GetParserRuleContext())
			}
			{
				p.SetState(1644)
				p.MultiplicativeExpression()
			}

		}
		p.SetState(1650)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext())
	}

	return localctx
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiplicativeExpression
	return p
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllTypeRHS() []ITypeRHSContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeRHSContext)(nil)).Elem())
	var tst = make([]ITypeRHSContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeRHSContext)
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) TypeRHS(i int) ITypeRHSContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeRHSContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeRHSContext)
}

func (s *MultiplicativeExpressionContext) AllMultiplicativeOperation() []IMultiplicativeOperationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicativeOperationContext)(nil)).Elem())
	var tst = make([]IMultiplicativeOperationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicativeOperationContext)
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) MultiplicativeOperation(i int) IMultiplicativeOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeOperationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeOperationContext)
}

func (s *MultiplicativeExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiplicativeExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, KotlinParserRULE_multiplicativeExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1651)
		p.TypeRHS()
	}
	p.SetState(1663)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1652)
				p.MultiplicativeOperation()
			}
			p.SetState(1656)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1653)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(1658)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext())
			}
			{
				p.SetState(1659)
				p.TypeRHS()
			}

		}
		p.SetState(1665)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeRHSContext is an interface to support dynamic dispatch.
type ITypeRHSContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeRHSContext differentiates from other interfaces.
	IsTypeRHSContext()
}

type TypeRHSContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeRHSContext() *TypeRHSContext {
	var p = new(TypeRHSContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeRHS
	return p
}

func (*TypeRHSContext) IsTypeRHSContext() {}

func NewTypeRHSContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeRHSContext {
	var p = new(TypeRHSContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeRHS

	return p
}

func (s *TypeRHSContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeRHSContext) AllPrefixUnaryExpression() []IPrefixUnaryExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrefixUnaryExpressionContext)(nil)).Elem())
	var tst = make([]IPrefixUnaryExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrefixUnaryExpressionContext)
		}
	}

	return tst
}

func (s *TypeRHSContext) PrefixUnaryExpression(i int) IPrefixUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixUnaryExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryExpressionContext)
}

func (s *TypeRHSContext) AllTypeOperation() []ITypeOperationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeOperationContext)(nil)).Elem())
	var tst = make([]ITypeOperationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeOperationContext)
		}
	}

	return tst
}

func (s *TypeRHSContext) TypeOperation(i int) ITypeOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeOperationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeOperationContext)
}

func (s *TypeRHSContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeRHSContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeRHSContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeRHSContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeRHSContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeRHS(s)
	}
}

func (s *TypeRHSContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeRHS(s)
	}
}

func (s *TypeRHSContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeRHS(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeRHS() (localctx ITypeRHSContext) {
	localctx = NewTypeRHSContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, KotlinParserRULE_typeRHS)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1666)
		p.PrefixUnaryExpression()
	}
	p.SetState(1678)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1670)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1667)
					p.Match(KotlinParserNL)
				}

				p.SetState(1672)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1673)
				p.TypeOperation()
			}
			{
				p.SetState(1674)
				p.PrefixUnaryExpression()
			}

		}
		p.SetState(1680)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext())
	}

	return localctx
}

// IPrefixUnaryExpressionContext is an interface to support dynamic dispatch.
type IPrefixUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefixUnaryExpressionContext differentiates from other interfaces.
	IsPrefixUnaryExpressionContext()
}

type PrefixUnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixUnaryExpressionContext() *PrefixUnaryExpressionContext {
	var p = new(PrefixUnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_prefixUnaryExpression
	return p
}

func (*PrefixUnaryExpressionContext) IsPrefixUnaryExpressionContext() {}

func NewPrefixUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixUnaryExpressionContext {
	var p = new(PrefixUnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_prefixUnaryExpression

	return p
}

func (s *PrefixUnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixUnaryExpressionContext) PostfixUnaryExpression() IPostfixUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryExpressionContext)
}

func (s *PrefixUnaryExpressionContext) AllPrefixUnaryOperation() []IPrefixUnaryOperationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrefixUnaryOperationContext)(nil)).Elem())
	var tst = make([]IPrefixUnaryOperationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrefixUnaryOperationContext)
		}
	}

	return tst
}

func (s *PrefixUnaryExpressionContext) PrefixUnaryOperation(i int) IPrefixUnaryOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixUnaryOperationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryOperationContext)
}

func (s *PrefixUnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixUnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixUnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrefixUnaryExpression(s)
	}
}

func (s *PrefixUnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrefixUnaryExpression(s)
	}
}

func (s *PrefixUnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitPrefixUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) PrefixUnaryExpression() (localctx IPrefixUnaryExpressionContext) {
	localctx = NewPrefixUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, KotlinParserRULE_prefixUnaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1684)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 247, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1681)
				p.PrefixUnaryOperation()
			}

		}
		p.SetState(1686)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 247, p.GetParserRuleContext())
	}
	{
		p.SetState(1687)
		p.PostfixUnaryExpression()
	}

	return localctx
}

// IPostfixUnaryExpressionContext is an interface to support dynamic dispatch.
type IPostfixUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixUnaryExpressionContext differentiates from other interfaces.
	IsPostfixUnaryExpressionContext()
}

type PostfixUnaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnaryExpressionContext() *PostfixUnaryExpressionContext {
	var p = new(PostfixUnaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnaryExpression
	return p
}

func (*PostfixUnaryExpressionContext) IsPostfixUnaryExpressionContext() {}

func NewPostfixUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnaryExpressionContext {
	var p = new(PostfixUnaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnaryExpression

	return p
}

func (s *PostfixUnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnaryExpressionContext) AtomicExpression() IAtomicExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicExpressionContext)
}

func (s *PostfixUnaryExpressionContext) CallableReference() ICallableReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallableReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallableReferenceContext)
}

func (s *PostfixUnaryExpressionContext) AllPostfixUnaryOperation() []IPostfixUnaryOperationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPostfixUnaryOperationContext)(nil)).Elem())
	var tst = make([]IPostfixUnaryOperationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPostfixUnaryOperationContext)
		}
	}

	return tst
}

func (s *PostfixUnaryExpressionContext) PostfixUnaryOperation(i int) IPostfixUnaryOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixUnaryOperationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryOperationContext)
}

func (s *PostfixUnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnaryExpression(s)
	}
}

func (s *PostfixUnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnaryExpression(s)
	}
}

func (s *PostfixUnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitPostfixUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) PostfixUnaryExpression() (localctx IPostfixUnaryExpressionContext) {
	localctx = NewPostfixUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, KotlinParserRULE_postfixUnaryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 248, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1689)
			p.AtomicExpression()
		}

	case 2:
		{
			p.SetState(1690)
			p.CallableReference()
		}

	}
	p.SetState(1696)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1693)
				p.PostfixUnaryOperation()
			}

		}
		p.SetState(1698)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext())
	}

	return localctx
}

// IAtomicExpressionContext is an interface to support dynamic dispatch.
type IAtomicExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomicExpressionContext differentiates from other interfaces.
	IsAtomicExpressionContext()
}

type AtomicExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicExpressionContext() *AtomicExpressionContext {
	var p = new(AtomicExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_atomicExpression
	return p
}

func (*AtomicExpressionContext) IsAtomicExpressionContext() {}

func NewAtomicExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicExpressionContext {
	var p = new(AtomicExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_atomicExpression

	return p
}

func (s *AtomicExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicExpressionContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *AtomicExpressionContext) LiteralConstant() ILiteralConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *AtomicExpressionContext) FunctionLiteral() IFunctionLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionLiteralContext)
}

func (s *AtomicExpressionContext) ThisExpression() IThisExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThisExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThisExpressionContext)
}

func (s *AtomicExpressionContext) SuperExpression() ISuperExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperExpressionContext)
}

func (s *AtomicExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *AtomicExpressionContext) TryExpression() ITryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryExpressionContext)
}

func (s *AtomicExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *AtomicExpressionContext) JumpExpression() IJumpExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJumpExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJumpExpressionContext)
}

func (s *AtomicExpressionContext) LoopExpression() ILoopExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoopExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoopExpressionContext)
}

func (s *AtomicExpressionContext) CollectionLiteral() ICollectionLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectionLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollectionLiteralContext)
}

func (s *AtomicExpressionContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *AtomicExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAtomicExpression(s)
	}
}

func (s *AtomicExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAtomicExpression(s)
	}
}

func (s *AtomicExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAtomicExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) AtomicExpression() (localctx IAtomicExpressionContext) {
	localctx = NewAtomicExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, KotlinParserRULE_atomicExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1711)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1699)
			p.ParenthesizedExpression()
		}

	case KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN, KotlinParserRealLiteral, KotlinParserLongLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1700)
			p.LiteralConstant()
		}

	case KotlinParserLCURL, KotlinParserAT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserLabelReference:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1701)
			p.FunctionLiteral()
		}

	case KotlinParserTHIS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1702)
			p.ThisExpression()
		}

	case KotlinParserSUPER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1703)
			p.SuperExpression()
		}

	case KotlinParserIF, KotlinParserWHEN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1704)
			p.ConditionalExpression()
		}

	case KotlinParserTRY:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1705)
			p.TryExpression()
		}

	case KotlinParserOBJECT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1706)
			p.ObjectLiteral()
		}

	case KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1707)
			p.JumpExpression()
		}

	case KotlinParserFOR, KotlinParserDO, KotlinParserWHILE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1708)
			p.LoopExpression()
		}

	case KotlinParserLSQUARE:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1709)
			p.CollectionLiteral()
		}

	case KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserGETTER, KotlinParserSETTER, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1710)
			p.SimpleIdentifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedExpressionContext differentiates from other interfaces.
	IsParenthesizedExpressionContext()
}

type ParenthesizedExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExpressionContext() *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedExpression
	return p
}

func (*ParenthesizedExpressionContext) IsParenthesizedExpressionContext() {}

func NewParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedExpression

	return p
}

func (s *ParenthesizedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ParenthesizedExpression() (localctx IParenthesizedExpressionContext) {
	localctx = NewParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, KotlinParserRULE_parenthesizedExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1713)
		p.Match(KotlinParserLPAREN)
	}
	{
		p.SetState(1714)
		p.Expression()
	}
	{
		p.SetState(1715)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// ICallSuffixContext is an interface to support dynamic dispatch.
type ICallSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallSuffixContext differentiates from other interfaces.
	IsCallSuffixContext()
}

type CallSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallSuffixContext() *CallSuffixContext {
	var p = new(CallSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_callSuffix
	return p
}

func (*CallSuffixContext) IsCallSuffixContext() {}

func NewCallSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallSuffixContext {
	var p = new(CallSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_callSuffix

	return p
}

func (s *CallSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *CallSuffixContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *CallSuffixContext) ValueArguments() IValueArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *CallSuffixContext) AllAnnotatedLambda() []IAnnotatedLambdaContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotatedLambdaContext)(nil)).Elem())
	var tst = make([]IAnnotatedLambdaContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotatedLambdaContext)
		}
	}

	return tst
}

func (s *CallSuffixContext) AnnotatedLambda(i int) IAnnotatedLambdaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotatedLambdaContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotatedLambdaContext)
}

func (s *CallSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCallSuffix(s)
	}
}

func (s *CallSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCallSuffix(s)
	}
}

func (s *CallSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitCallSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) CallSuffix() (localctx ICallSuffixContext) {
	localctx = NewCallSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, KotlinParserRULE_callSuffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1739)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLANGLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1717)
			p.TypeArguments()
		}
		p.SetState(1719)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 251, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1718)
				p.ValueArguments()
			}

		}
		p.SetState(1724)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 252, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1721)
					p.AnnotatedLambda()
				}

			}
			p.SetState(1726)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 252, p.GetParserRuleContext())
		}

	case KotlinParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1727)
			p.ValueArguments()
		}
		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 253, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1728)
					p.AnnotatedLambda()
				}

			}
			p.SetState(1733)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 253, p.GetParserRuleContext())
		}

	case KotlinParserNL, KotlinParserLCURL, KotlinParserAT, KotlinParserFILE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserGETTER, KotlinParserSETTER, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserIdentifier, KotlinParserLabelReference, KotlinParserLabelDefinition:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1735)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1734)
					p.AnnotatedLambda()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1737)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotatedLambdaContext is an interface to support dynamic dispatch.
type IAnnotatedLambdaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotatedLambdaContext differentiates from other interfaces.
	IsAnnotatedLambdaContext()
}

type AnnotatedLambdaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotatedLambdaContext() *AnnotatedLambdaContext {
	var p = new(AnnotatedLambdaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotatedLambda
	return p
}

func (*AnnotatedLambdaContext) IsAnnotatedLambdaContext() {}

func NewAnnotatedLambdaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotatedLambdaContext {
	var p = new(AnnotatedLambdaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotatedLambda

	return p
}

func (s *AnnotatedLambdaContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotatedLambdaContext) FunctionLiteral() IFunctionLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionLiteralContext)
}

func (s *AnnotatedLambdaContext) AllUnescapedAnnotation() []IUnescapedAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem())
	var tst = make([]IUnescapedAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnescapedAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotatedLambdaContext) UnescapedAnnotation(i int) IUnescapedAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *AnnotatedLambdaContext) LabelDefinition() antlr.TerminalNode {
	return s.GetToken(KotlinParserLabelDefinition, 0)
}

func (s *AnnotatedLambdaContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotatedLambdaContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotatedLambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotatedLambdaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotatedLambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotatedLambda(s)
	}
}

func (s *AnnotatedLambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotatedLambda(s)
	}
}

func (s *AnnotatedLambdaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAnnotatedLambda(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) AnnotatedLambda() (localctx IAnnotatedLambdaContext) {
	localctx = NewAnnotatedLambdaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, KotlinParserRULE_annotatedLambda)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1744)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(KotlinParserIMPORT-58))|(1<<(KotlinParserCONSTRUCTOR-58))|(1<<(KotlinParserBY-58))|(1<<(KotlinParserCOMPANION-58))|(1<<(KotlinParserINIT-58))|(1<<(KotlinParserWHERE-58))|(1<<(KotlinParserCATCH-58))|(1<<(KotlinParserFINALLY-58)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(KotlinParserOUT-92))|(1<<(KotlinParserGETTER-92))|(1<<(KotlinParserSETTER-92))|(1<<(KotlinParserDYNAMIC-92))|(1<<(KotlinParserPUBLIC-92))|(1<<(KotlinParserPRIVATE-92))|(1<<(KotlinParserPROTECTED-92))|(1<<(KotlinParserINTERNAL-92))|(1<<(KotlinParserENUM-92))|(1<<(KotlinParserSEALED-92))|(1<<(KotlinParserANNOTATION-92))|(1<<(KotlinParserDATA-92))|(1<<(KotlinParserINNER-92))|(1<<(KotlinParserTAILREC-92))|(1<<(KotlinParserOPERATOR-92))|(1<<(KotlinParserINLINE-92))|(1<<(KotlinParserINFIX-92))|(1<<(KotlinParserEXTERNAL-92))|(1<<(KotlinParserSUSPEND-92))|(1<<(KotlinParserOVERRIDE-92))|(1<<(KotlinParserABSTRACT-92))|(1<<(KotlinParserFINAL-92))|(1<<(KotlinParserOPEN-92))|(1<<(KotlinParserCONST-92)))) != 0) || (((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(KotlinParserLATEINIT-124))|(1<<(KotlinParserVARARG-124))|(1<<(KotlinParserNOINLINE-124))|(1<<(KotlinParserCROSSINLINE-124))|(1<<(KotlinParserREIFIED-124))|(1<<(KotlinParserIdentifier-124)))) != 0) {
		{
			p.SetState(1741)
			p.UnescapedAnnotation()
		}

		p.SetState(1746)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1748)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLabelDefinition {
		{
			p.SetState(1747)
			p.Match(KotlinParserLabelDefinition)
		}

	}
	p.SetState(1753)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1750)
			p.Match(KotlinParserNL)
		}

		p.SetState(1755)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1756)
		p.FunctionLiteral()
	}

	return localctx
}

// IArrayAccessContext is an interface to support dynamic dispatch.
type IArrayAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayAccessContext differentiates from other interfaces.
	IsArrayAccessContext()
}

type ArrayAccessContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayAccessContext() *ArrayAccessContext {
	var p = new(ArrayAccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_arrayAccess
	return p
}

func (*ArrayAccessContext) IsArrayAccessContext() {}

func NewArrayAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayAccessContext {
	var p = new(ArrayAccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_arrayAccess

	return p
}

func (s *ArrayAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayAccessContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *ArrayAccessContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *ArrayAccessContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayAccessContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayAccessContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ArrayAccessContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ArrayAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterArrayAccess(s)
	}
}

func (s *ArrayAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitArrayAccess(s)
	}
}

func (s *ArrayAccessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitArrayAccess(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ArrayAccess() (localctx IArrayAccessContext) {
	localctx = NewArrayAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, KotlinParserRULE_arrayAccess)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1758)
		p.Match(KotlinParserLSQUARE)
	}
	p.SetState(1767)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserNL)|(1<<KotlinParserLPAREN)|(1<<KotlinParserLSQUARE)|(1<<KotlinParserLCURL)|(1<<KotlinParserADD)|(1<<KotlinParserSUB)|(1<<KotlinParserINCR)|(1<<KotlinParserDECR)|(1<<KotlinParserEXCL))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(KotlinParserCOLONCOLON-36))|(1<<(KotlinParserQ_COLONCOLON-36))|(1<<(KotlinParserAT-36))|(1<<(KotlinParserRETURN_AT-36))|(1<<(KotlinParserCONTINUE_AT-36))|(1<<(KotlinParserBREAK_AT-36))|(1<<(KotlinParserFILE-36))|(1<<(KotlinParserIMPORT-36))|(1<<(KotlinParserOBJECT-36))|(1<<(KotlinParserCONSTRUCTOR-36))|(1<<(KotlinParserBY-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(KotlinParserCOMPANION-68))|(1<<(KotlinParserINIT-68))|(1<<(KotlinParserTHIS-68))|(1<<(KotlinParserSUPER-68))|(1<<(KotlinParserWHERE-68))|(1<<(KotlinParserIF-68))|(1<<(KotlinParserWHEN-68))|(1<<(KotlinParserTRY-68))|(1<<(KotlinParserCATCH-68))|(1<<(KotlinParserFINALLY-68))|(1<<(KotlinParserFOR-68))|(1<<(KotlinParserDO-68))|(1<<(KotlinParserWHILE-68))|(1<<(KotlinParserTHROW-68))|(1<<(KotlinParserRETURN-68))|(1<<(KotlinParserCONTINUE-68))|(1<<(KotlinParserBREAK-68))|(1<<(KotlinParserOUT-68))|(1<<(KotlinParserFIELD-68))|(1<<(KotlinParserPROPERTY-68))|(1<<(KotlinParserGET-68))|(1<<(KotlinParserSET-68))|(1<<(KotlinParserGETTER-68))|(1<<(KotlinParserSETTER-68))|(1<<(KotlinParserRECEIVER-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(KotlinParserPARAM-100))|(1<<(KotlinParserSETPARAM-100))|(1<<(KotlinParserDELEGATE-100))|(1<<(KotlinParserDYNAMIC-100))|(1<<(KotlinParserPUBLIC-100))|(1<<(KotlinParserPRIVATE-100))|(1<<(KotlinParserPROTECTED-100))|(1<<(KotlinParserINTERNAL-100))|(1<<(KotlinParserENUM-100))|(1<<(KotlinParserSEALED-100))|(1<<(KotlinParserANNOTATION-100))|(1<<(KotlinParserDATA-100))|(1<<(KotlinParserINNER-100))|(1<<(KotlinParserTAILREC-100))|(1<<(KotlinParserOPERATOR-100))|(1<<(KotlinParserINLINE-100))|(1<<(KotlinParserINFIX-100))|(1<<(KotlinParserEXTERNAL-100))|(1<<(KotlinParserSUSPEND-100))|(1<<(KotlinParserOVERRIDE-100))|(1<<(KotlinParserABSTRACT-100))|(1<<(KotlinParserFINAL-100))|(1<<(KotlinParserOPEN-100))|(1<<(KotlinParserCONST-100))|(1<<(KotlinParserLATEINIT-100))|(1<<(KotlinParserVARARG-100))|(1<<(KotlinParserNOINLINE-100))|(1<<(KotlinParserCROSSINLINE-100))|(1<<(KotlinParserREIFIED-100))|(1<<(KotlinParserQUOTE_OPEN-100))|(1<<(KotlinParserTRIPLE_QUOTE_OPEN-100))|(1<<(KotlinParserRealLiteral-100)))) != 0) || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(KotlinParserLongLiteral-134))|(1<<(KotlinParserIntegerLiteral-134))|(1<<(KotlinParserHexLiteral-134))|(1<<(KotlinParserBinLiteral-134))|(1<<(KotlinParserBooleanLiteral-134))|(1<<(KotlinParserNullLiteral-134))|(1<<(KotlinParserIdentifier-134))|(1<<(KotlinParserLabelReference-134))|(1<<(KotlinParserLabelDefinition-134))|(1<<(KotlinParserCharacterLiteral-134)))) != 0) {
		{
			p.SetState(1759)
			p.Expression()
		}
		p.SetState(1764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserCOMMA {
			{
				p.SetState(1760)
				p.Match(KotlinParserCOMMA)
			}
			{
				p.SetState(1761)
				p.Expression()
			}

			p.SetState(1766)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1769)
		p.Match(KotlinParserRSQUARE)
	}

	return localctx
}

// IValueArgumentsContext is an interface to support dynamic dispatch.
type IValueArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueArgumentsContext differentiates from other interfaces.
	IsValueArgumentsContext()
}

type ValueArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueArgumentsContext() *ValueArgumentsContext {
	var p = new(ValueArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_valueArguments
	return p
}

func (*ValueArgumentsContext) IsValueArgumentsContext() {}

func NewValueArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueArgumentsContext {
	var p = new(ValueArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_valueArguments

	return p
}

func (s *ValueArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ValueArgumentsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ValueArgumentsContext) AllValueArgument() []IValueArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueArgumentContext)(nil)).Elem())
	var tst = make([]IValueArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueArgumentContext)
		}
	}

	return tst
}

func (s *ValueArgumentsContext) ValueArgument(i int) IValueArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentContext)
}

func (s *ValueArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ValueArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ValueArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterValueArguments(s)
	}
}

func (s *ValueArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitValueArguments(s)
	}
}

func (s *ValueArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitValueArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ValueArguments() (localctx IValueArgumentsContext) {
	localctx = NewValueArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, KotlinParserRULE_valueArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1771)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(1780)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserNL)|(1<<KotlinParserLPAREN)|(1<<KotlinParserLSQUARE)|(1<<KotlinParserLCURL)|(1<<KotlinParserMULT)|(1<<KotlinParserADD)|(1<<KotlinParserSUB)|(1<<KotlinParserINCR)|(1<<KotlinParserDECR)|(1<<KotlinParserEXCL))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(KotlinParserCOLONCOLON-36))|(1<<(KotlinParserQ_COLONCOLON-36))|(1<<(KotlinParserAT-36))|(1<<(KotlinParserRETURN_AT-36))|(1<<(KotlinParserCONTINUE_AT-36))|(1<<(KotlinParserBREAK_AT-36))|(1<<(KotlinParserFILE-36))|(1<<(KotlinParserIMPORT-36))|(1<<(KotlinParserOBJECT-36))|(1<<(KotlinParserCONSTRUCTOR-36))|(1<<(KotlinParserBY-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(KotlinParserCOMPANION-68))|(1<<(KotlinParserINIT-68))|(1<<(KotlinParserTHIS-68))|(1<<(KotlinParserSUPER-68))|(1<<(KotlinParserWHERE-68))|(1<<(KotlinParserIF-68))|(1<<(KotlinParserWHEN-68))|(1<<(KotlinParserTRY-68))|(1<<(KotlinParserCATCH-68))|(1<<(KotlinParserFINALLY-68))|(1<<(KotlinParserFOR-68))|(1<<(KotlinParserDO-68))|(1<<(KotlinParserWHILE-68))|(1<<(KotlinParserTHROW-68))|(1<<(KotlinParserRETURN-68))|(1<<(KotlinParserCONTINUE-68))|(1<<(KotlinParserBREAK-68))|(1<<(KotlinParserOUT-68))|(1<<(KotlinParserFIELD-68))|(1<<(KotlinParserPROPERTY-68))|(1<<(KotlinParserGET-68))|(1<<(KotlinParserSET-68))|(1<<(KotlinParserGETTER-68))|(1<<(KotlinParserSETTER-68))|(1<<(KotlinParserRECEIVER-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(KotlinParserPARAM-100))|(1<<(KotlinParserSETPARAM-100))|(1<<(KotlinParserDELEGATE-100))|(1<<(KotlinParserDYNAMIC-100))|(1<<(KotlinParserPUBLIC-100))|(1<<(KotlinParserPRIVATE-100))|(1<<(KotlinParserPROTECTED-100))|(1<<(KotlinParserINTERNAL-100))|(1<<(KotlinParserENUM-100))|(1<<(KotlinParserSEALED-100))|(1<<(KotlinParserANNOTATION-100))|(1<<(KotlinParserDATA-100))|(1<<(KotlinParserINNER-100))|(1<<(KotlinParserTAILREC-100))|(1<<(KotlinParserOPERATOR-100))|(1<<(KotlinParserINLINE-100))|(1<<(KotlinParserINFIX-100))|(1<<(KotlinParserEXTERNAL-100))|(1<<(KotlinParserSUSPEND-100))|(1<<(KotlinParserOVERRIDE-100))|(1<<(KotlinParserABSTRACT-100))|(1<<(KotlinParserFINAL-100))|(1<<(KotlinParserOPEN-100))|(1<<(KotlinParserCONST-100))|(1<<(KotlinParserLATEINIT-100))|(1<<(KotlinParserVARARG-100))|(1<<(KotlinParserNOINLINE-100))|(1<<(KotlinParserCROSSINLINE-100))|(1<<(KotlinParserREIFIED-100))|(1<<(KotlinParserQUOTE_OPEN-100))|(1<<(KotlinParserTRIPLE_QUOTE_OPEN-100))|(1<<(KotlinParserRealLiteral-100)))) != 0) || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(KotlinParserLongLiteral-134))|(1<<(KotlinParserIntegerLiteral-134))|(1<<(KotlinParserHexLiteral-134))|(1<<(KotlinParserBinLiteral-134))|(1<<(KotlinParserBooleanLiteral-134))|(1<<(KotlinParserNullLiteral-134))|(1<<(KotlinParserIdentifier-134))|(1<<(KotlinParserLabelReference-134))|(1<<(KotlinParserLabelDefinition-134))|(1<<(KotlinParserCharacterLiteral-134)))) != 0) {
		{
			p.SetState(1772)
			p.ValueArgument()
		}
		p.SetState(1777)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserCOMMA {
			{
				p.SetState(1773)
				p.Match(KotlinParserCOMMA)
			}
			{
				p.SetState(1774)
				p.ValueArgument()
			}

			p.SetState(1779)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1782)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeArguments
	return p
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *TypeArgumentsContext) AllTypeProjection() []ITypeProjectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeProjectionContext)(nil)).Elem())
	var tst = make([]ITypeProjectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeProjectionContext)
		}
	}

	return tst
}

func (s *TypeArgumentsContext) TypeProjection(i int) ITypeProjectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeProjectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionContext)
}

func (s *TypeArgumentsContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *TypeArgumentsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeArgumentsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, KotlinParserRULE_typeArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1784)
		p.Match(KotlinParserLANGLE)
	}
	p.SetState(1788)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1785)
			p.Match(KotlinParserNL)
		}

		p.SetState(1790)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1791)
		p.TypeProjection()
	}
	p.SetState(1802)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1795)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1792)
					p.Match(KotlinParserNL)
				}

				p.SetState(1797)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1798)
				p.Match(KotlinParserCOMMA)
			}
			{
				p.SetState(1799)
				p.TypeProjection()
			}

		}
		p.SetState(1804)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext())
	}
	p.SetState(1808)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1805)
			p.Match(KotlinParserNL)
		}

		p.SetState(1810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1811)
		p.Match(KotlinParserRANGLE)
	}

	return localctx
}

// ITypeProjectionContext is an interface to support dynamic dispatch.
type ITypeProjectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeProjectionContext differentiates from other interfaces.
	IsTypeProjectionContext()
}

type TypeProjectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionContext() *TypeProjectionContext {
	var p = new(TypeProjectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjection
	return p
}

func (*TypeProjectionContext) IsTypeProjectionContext() {}

func NewTypeProjectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionContext {
	var p = new(TypeProjectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjection

	return p
}

func (s *TypeProjectionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeProjectionContext) TypeProjectionModifierList() ITypeProjectionModifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeProjectionModifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionModifierListContext)
}

func (s *TypeProjectionContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *TypeProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjection(s)
	}
}

func (s *TypeProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjection(s)
	}
}

func (s *TypeProjectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeProjection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeProjection() (localctx ITypeProjectionContext) {
	localctx = NewTypeProjectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, KotlinParserRULE_typeProjection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1818)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN, KotlinParserAT, KotlinParserFILE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserIN, KotlinParserOUT, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserGETTER, KotlinParserSETTER, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserIdentifier, KotlinParserLabelReference:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1814)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 267, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1813)
				p.TypeProjectionModifierList()
			}

		}
		{
			p.SetState(1816)
			p.Type()
		}

	case KotlinParserMULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1817)
			p.Match(KotlinParserMULT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeProjectionModifierListContext is an interface to support dynamic dispatch.
type ITypeProjectionModifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeProjectionModifierListContext differentiates from other interfaces.
	IsTypeProjectionModifierListContext()
}

type TypeProjectionModifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionModifierListContext() *TypeProjectionModifierListContext {
	var p = new(TypeProjectionModifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjectionModifierList
	return p
}

func (*TypeProjectionModifierListContext) IsTypeProjectionModifierListContext() {}

func NewTypeProjectionModifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionModifierListContext {
	var p = new(TypeProjectionModifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjectionModifierList

	return p
}

func (s *TypeProjectionModifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionModifierListContext) AllVarianceAnnotation() []IVarianceAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVarianceAnnotationContext)(nil)).Elem())
	var tst = make([]IVarianceAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVarianceAnnotationContext)
		}
	}

	return tst
}

func (s *TypeProjectionModifierListContext) VarianceAnnotation(i int) IVarianceAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarianceAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVarianceAnnotationContext)
}

func (s *TypeProjectionModifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionModifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionModifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjectionModifierList(s)
	}
}

func (s *TypeProjectionModifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjectionModifierList(s)
	}
}

func (s *TypeProjectionModifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeProjectionModifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeProjectionModifierList() (localctx ITypeProjectionModifierListContext) {
	localctx = NewTypeProjectionModifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, KotlinParserRULE_typeProjectionModifierList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1821)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1820)
				p.VarianceAnnotation()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1823)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 269, p.GetParserRuleContext())
	}

	return localctx
}

// IValueArgumentContext is an interface to support dynamic dispatch.
type IValueArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueArgumentContext differentiates from other interfaces.
	IsValueArgumentContext()
}

type ValueArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueArgumentContext() *ValueArgumentContext {
	var p = new(ValueArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_valueArgument
	return p
}

func (*ValueArgumentContext) IsValueArgumentContext() {}

func NewValueArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueArgumentContext {
	var p = new(ValueArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_valueArgument

	return p
}

func (s *ValueArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ValueArgumentContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ValueArgumentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *ValueArgumentContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *ValueArgumentContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ValueArgumentContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ValueArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterValueArgument(s)
	}
}

func (s *ValueArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitValueArgument(s)
	}
}

func (s *ValueArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitValueArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ValueArgument() (localctx IValueArgumentContext) {
	localctx = NewValueArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, KotlinParserRULE_valueArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1839)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 272, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1825)
			p.SimpleIdentifier()
		}
		p.SetState(1829)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1826)
				p.Match(KotlinParserNL)
			}

			p.SetState(1831)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1832)
			p.Match(KotlinParserASSIGNMENT)
		}
		p.SetState(1836)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1833)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(1838)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext())
		}

	}
	p.SetState(1842)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserMULT {
		{
			p.SetState(1841)
			p.Match(KotlinParserMULT)
		}

	}
	p.SetState(1847)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 274, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1844)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(1849)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 274, p.GetParserRuleContext())
	}
	{
		p.SetState(1850)
		p.Expression()
	}

	return localctx
}

// ILiteralConstantContext is an interface to support dynamic dispatch.
type ILiteralConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralConstantContext differentiates from other interfaces.
	IsLiteralConstantContext()
}

type LiteralConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralConstantContext() *LiteralConstantContext {
	var p = new(LiteralConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_literalConstant
	return p
}

func (*LiteralConstantContext) IsLiteralConstantContext() {}

func NewLiteralConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralConstantContext {
	var p = new(LiteralConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_literalConstant

	return p
}

func (s *LiteralConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralConstantContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserBooleanLiteral, 0)
}

func (s *LiteralConstantContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserIntegerLiteral, 0)
}

func (s *LiteralConstantContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralConstantContext) HexLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserHexLiteral, 0)
}

func (s *LiteralConstantContext) BinLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserBinLiteral, 0)
}

func (s *LiteralConstantContext) CharacterLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserCharacterLiteral, 0)
}

func (s *LiteralConstantContext) RealLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserRealLiteral, 0)
}

func (s *LiteralConstantContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserNullLiteral, 0)
}

func (s *LiteralConstantContext) LongLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserLongLiteral, 0)
}

func (s *LiteralConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLiteralConstant(s)
	}
}

func (s *LiteralConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLiteralConstant(s)
	}
}

func (s *LiteralConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitLiteralConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) LiteralConstant() (localctx ILiteralConstantContext) {
	localctx = NewLiteralConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, KotlinParserRULE_literalConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1861)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1852)
			p.Match(KotlinParserBooleanLiteral)
		}

	case KotlinParserIntegerLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1853)
			p.Match(KotlinParserIntegerLiteral)
		}

	case KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1854)
			p.StringLiteral()
		}

	case KotlinParserHexLiteral:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1855)
			p.Match(KotlinParserHexLiteral)
		}

	case KotlinParserBinLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1856)
			p.Match(KotlinParserBinLiteral)
		}

	case KotlinParserCharacterLiteral:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1857)
			p.Match(KotlinParserCharacterLiteral)
		}

	case KotlinParserRealLiteral:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1858)
			p.Match(KotlinParserRealLiteral)
		}

	case KotlinParserNullLiteral:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1859)
			p.Match(KotlinParserNullLiteral)
		}

	case KotlinParserLongLiteral:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1860)
			p.Match(KotlinParserLongLiteral)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) LineStringLiteral() ILineStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineStringLiteralContext)
}

func (s *StringLiteralContext) MultiLineStringLiteral() IMultiLineStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiLineStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringLiteralContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, KotlinParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1865)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserQUOTE_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1863)
			p.LineStringLiteral()
		}

	case KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1864)
			p.MultiLineStringLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILineStringLiteralContext is an interface to support dynamic dispatch.
type ILineStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineStringLiteralContext differentiates from other interfaces.
	IsLineStringLiteralContext()
}

type LineStringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringLiteralContext() *LineStringLiteralContext {
	var p = new(LineStringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringLiteral
	return p
}

func (*LineStringLiteralContext) IsLineStringLiteralContext() {}

func NewLineStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringLiteralContext {
	var p = new(LineStringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringLiteral

	return p
}

func (s *LineStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringLiteralContext) QUOTE_OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUOTE_OPEN, 0)
}

func (s *LineStringLiteralContext) QUOTE_CLOSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUOTE_CLOSE, 0)
}

func (s *LineStringLiteralContext) AllLineStringContent() []ILineStringContentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILineStringContentContext)(nil)).Elem())
	var tst = make([]ILineStringContentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILineStringContentContext)
		}
	}

	return tst
}

func (s *LineStringLiteralContext) LineStringContent(i int) ILineStringContentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStringContentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILineStringContentContext)
}

func (s *LineStringLiteralContext) AllLineStringExpression() []ILineStringExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILineStringExpressionContext)(nil)).Elem())
	var tst = make([]ILineStringExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILineStringExpressionContext)
		}
	}

	return tst
}

func (s *LineStringLiteralContext) LineStringExpression(i int) ILineStringExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStringExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILineStringExpressionContext)
}

func (s *LineStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringLiteral(s)
	}
}

func (s *LineStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringLiteral(s)
	}
}

func (s *LineStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitLineStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) LineStringLiteral() (localctx ILineStringLiteralContext) {
	localctx = NewLineStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, KotlinParserRULE_lineStringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1867)
		p.Match(KotlinParserQUOTE_OPEN)
	}
	p.SetState(1872)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-156)&-(0x1f+1)) == 0 && ((1<<uint((_la-156)))&((1<<(KotlinParserLineStrRef-156))|(1<<(KotlinParserLineStrText-156))|(1<<(KotlinParserLineStrEscapedChar-156))|(1<<(KotlinParserLineStrExprStart-156)))) != 0 {
		p.SetState(1870)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KotlinParserLineStrRef, KotlinParserLineStrText, KotlinParserLineStrEscapedChar:
			{
				p.SetState(1868)
				p.LineStringContent()
			}

		case KotlinParserLineStrExprStart:
			{
				p.SetState(1869)
				p.LineStringExpression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1874)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1875)
		p.Match(KotlinParserQUOTE_CLOSE)
	}

	return localctx
}

// IMultiLineStringLiteralContext is an interface to support dynamic dispatch.
type IMultiLineStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiLineStringLiteralContext differentiates from other interfaces.
	IsMultiLineStringLiteralContext()
}

type MultiLineStringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringLiteralContext() *MultiLineStringLiteralContext {
	var p = new(MultiLineStringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringLiteral
	return p
}

func (*MultiLineStringLiteralContext) IsMultiLineStringLiteralContext() {}

func NewMultiLineStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringLiteralContext {
	var p = new(MultiLineStringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringLiteral

	return p
}

func (s *MultiLineStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringLiteralContext) TRIPLE_QUOTE_OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRIPLE_QUOTE_OPEN, 0)
}

func (s *MultiLineStringLiteralContext) TRIPLE_QUOTE_CLOSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRIPLE_QUOTE_CLOSE, 0)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringContent() []IMultiLineStringContentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiLineStringContentContext)(nil)).Elem())
	var tst = make([]IMultiLineStringContentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiLineStringContentContext)
		}
	}

	return tst
}

func (s *MultiLineStringLiteralContext) MultiLineStringContent(i int) IMultiLineStringContentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiLineStringContentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringContentContext)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringExpression() []IMultiLineStringExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiLineStringExpressionContext)(nil)).Elem())
	var tst = make([]IMultiLineStringExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiLineStringExpressionContext)
		}
	}

	return tst
}

func (s *MultiLineStringLiteralContext) MultiLineStringExpression(i int) IMultiLineStringExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiLineStringExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringExpressionContext)
}

func (s *MultiLineStringLiteralContext) AllLineStringLiteral() []ILineStringLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILineStringLiteralContext)(nil)).Elem())
	var tst = make([]ILineStringLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILineStringLiteralContext)
		}
	}

	return tst
}

func (s *MultiLineStringLiteralContext) LineStringLiteral(i int) ILineStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStringLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILineStringLiteralContext)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringQuote() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserMultiLineStringQuote)
}

func (s *MultiLineStringLiteralContext) MultiLineStringQuote(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStringQuote, i)
}

func (s *MultiLineStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringLiteral(s)
	}
}

func (s *MultiLineStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringLiteral(s)
	}
}

func (s *MultiLineStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitMultiLineStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) MultiLineStringLiteral() (localctx IMultiLineStringLiteralContext) {
	localctx = NewMultiLineStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, KotlinParserRULE_multiLineStringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1877)
		p.Match(KotlinParserTRIPLE_QUOTE_OPEN)
	}
	p.SetState(1884)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserQUOTE_OPEN || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(KotlinParserMultiLineStringQuote-161))|(1<<(KotlinParserMultiLineStrRef-161))|(1<<(KotlinParserMultiLineStrText-161))|(1<<(KotlinParserMultiLineStrEscapedChar-161))|(1<<(KotlinParserMultiLineStrExprStart-161)))) != 0) {
		p.SetState(1882)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KotlinParserMultiLineStrRef, KotlinParserMultiLineStrText, KotlinParserMultiLineStrEscapedChar:
			{
				p.SetState(1878)
				p.MultiLineStringContent()
			}

		case KotlinParserMultiLineStrExprStart:
			{
				p.SetState(1879)
				p.MultiLineStringExpression()
			}

		case KotlinParserQUOTE_OPEN:
			{
				p.SetState(1880)
				p.LineStringLiteral()
			}

		case KotlinParserMultiLineStringQuote:
			{
				p.SetState(1881)
				p.Match(KotlinParserMultiLineStringQuote)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1887)
		p.Match(KotlinParserTRIPLE_QUOTE_CLOSE)
	}

	return localctx
}

// ILineStringContentContext is an interface to support dynamic dispatch.
type ILineStringContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineStringContentContext differentiates from other interfaces.
	IsLineStringContentContext()
}

type LineStringContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringContentContext() *LineStringContentContext {
	var p = new(LineStringContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringContent
	return p
}

func (*LineStringContentContext) IsLineStringContentContext() {}

func NewLineStringContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringContentContext {
	var p = new(LineStringContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringContent

	return p
}

func (s *LineStringContentContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringContentContext) LineStrText() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrText, 0)
}

func (s *LineStringContentContext) LineStrEscapedChar() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrEscapedChar, 0)
}

func (s *LineStringContentContext) LineStrRef() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrRef, 0)
}

func (s *LineStringContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringContent(s)
	}
}

func (s *LineStringContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringContent(s)
	}
}

func (s *LineStringContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitLineStringContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) LineStringContent() (localctx ILineStringContentContext) {
	localctx = NewLineStringContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, KotlinParserRULE_lineStringContent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1889)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-156)&-(0x1f+1)) == 0 && ((1<<uint((_la-156)))&((1<<(KotlinParserLineStrRef-156))|(1<<(KotlinParserLineStrText-156))|(1<<(KotlinParserLineStrEscapedChar-156)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILineStringExpressionContext is an interface to support dynamic dispatch.
type ILineStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineStringExpressionContext differentiates from other interfaces.
	IsLineStringExpressionContext()
}

type LineStringExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringExpressionContext() *LineStringExpressionContext {
	var p = new(LineStringExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringExpression
	return p
}

func (*LineStringExpressionContext) IsLineStringExpressionContext() {}

func NewLineStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringExpressionContext {
	var p = new(LineStringExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringExpression

	return p
}

func (s *LineStringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringExpressionContext) LineStrExprStart() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrExprStart, 0)
}

func (s *LineStringExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LineStringExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *LineStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringExpression(s)
	}
}

func (s *LineStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringExpression(s)
	}
}

func (s *LineStringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitLineStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) LineStringExpression() (localctx ILineStringExpressionContext) {
	localctx = NewLineStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, KotlinParserRULE_lineStringExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1891)
		p.Match(KotlinParserLineStrExprStart)
	}
	{
		p.SetState(1892)
		p.Expression()
	}
	{
		p.SetState(1893)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IMultiLineStringContentContext is an interface to support dynamic dispatch.
type IMultiLineStringContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiLineStringContentContext differentiates from other interfaces.
	IsMultiLineStringContentContext()
}

type MultiLineStringContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringContentContext() *MultiLineStringContentContext {
	var p = new(MultiLineStringContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringContent
	return p
}

func (*MultiLineStringContentContext) IsMultiLineStringContentContext() {}

func NewMultiLineStringContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringContentContext {
	var p = new(MultiLineStringContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringContent

	return p
}

func (s *MultiLineStringContentContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringContentContext) MultiLineStrText() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrText, 0)
}

func (s *MultiLineStringContentContext) MultiLineStrEscapedChar() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrEscapedChar, 0)
}

func (s *MultiLineStringContentContext) MultiLineStrRef() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrRef, 0)
}

func (s *MultiLineStringContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringContent(s)
	}
}

func (s *MultiLineStringContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringContent(s)
	}
}

func (s *MultiLineStringContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitMultiLineStringContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) MultiLineStringContent() (localctx IMultiLineStringContentContext) {
	localctx = NewMultiLineStringContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, KotlinParserRULE_multiLineStringContent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1895)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(KotlinParserMultiLineStrRef-162))|(1<<(KotlinParserMultiLineStrText-162))|(1<<(KotlinParserMultiLineStrEscapedChar-162)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMultiLineStringExpressionContext is an interface to support dynamic dispatch.
type IMultiLineStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiLineStringExpressionContext differentiates from other interfaces.
	IsMultiLineStringExpressionContext()
}

type MultiLineStringExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringExpressionContext() *MultiLineStringExpressionContext {
	var p = new(MultiLineStringExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringExpression
	return p
}

func (*MultiLineStringExpressionContext) IsMultiLineStringExpressionContext() {}

func NewMultiLineStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringExpressionContext {
	var p = new(MultiLineStringExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringExpression

	return p
}

func (s *MultiLineStringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringExpressionContext) MultiLineStrExprStart() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrExprStart, 0)
}

func (s *MultiLineStringExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiLineStringExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *MultiLineStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringExpression(s)
	}
}

func (s *MultiLineStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringExpression(s)
	}
}

func (s *MultiLineStringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitMultiLineStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) MultiLineStringExpression() (localctx IMultiLineStringExpressionContext) {
	localctx = NewMultiLineStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, KotlinParserRULE_multiLineStringExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1897)
		p.Match(KotlinParserMultiLineStrExprStart)
	}
	{
		p.SetState(1898)
		p.Expression()
	}
	{
		p.SetState(1899)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IFunctionLiteralContext is an interface to support dynamic dispatch.
type IFunctionLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionLiteralContext differentiates from other interfaces.
	IsFunctionLiteralContext()
}

type FunctionLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionLiteralContext() *FunctionLiteralContext {
	var p = new(FunctionLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionLiteral
	return p
}

func (*FunctionLiteralContext) IsFunctionLiteralContext() {}

func NewFunctionLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionLiteralContext {
	var p = new(FunctionLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionLiteral

	return p
}

func (s *FunctionLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionLiteralContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *FunctionLiteralContext) Statements() IStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *FunctionLiteralContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *FunctionLiteralContext) LambdaParameters() ILambdaParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *FunctionLiteralContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *FunctionLiteralContext) AllAnnotations() []IAnnotationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem())
	var tst = make([]IAnnotationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsContext)
		}
	}

	return tst
}

func (s *FunctionLiteralContext) Annotations(i int) IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *FunctionLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionLiteral(s)
	}
}

func (s *FunctionLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionLiteral(s)
	}
}

func (s *FunctionLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFunctionLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FunctionLiteral() (localctx IFunctionLiteralContext) {
	localctx = NewFunctionLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, KotlinParserRULE_functionLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1904)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(KotlinParserFIELD-93))|(1<<(KotlinParserPROPERTY-93))|(1<<(KotlinParserGET-93))|(1<<(KotlinParserSET-93))|(1<<(KotlinParserRECEIVER-93))|(1<<(KotlinParserPARAM-93))|(1<<(KotlinParserSETPARAM-93))|(1<<(KotlinParserDELEGATE-93)))) != 0) || _la == KotlinParserLabelReference {
		{
			p.SetState(1901)
			p.Annotations()
		}

		p.SetState(1906)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1953)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 288, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1907)
			p.Match(KotlinParserLCURL)
		}
		p.SetState(1911)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 282, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1908)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(1913)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 282, p.GetParserRuleContext())
		}
		{
			p.SetState(1914)
			p.Statements()
		}
		p.SetState(1918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1915)
				p.Match(KotlinParserNL)
			}

			p.SetState(1920)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1921)
			p.Match(KotlinParserRCURL)
		}

	case 2:
		{
			p.SetState(1923)
			p.Match(KotlinParserLCURL)
		}
		p.SetState(1927)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1924)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(1929)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext())
		}
		{
			p.SetState(1930)
			p.LambdaParameters()
		}
		p.SetState(1934)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1931)
				p.Match(KotlinParserNL)
			}

			p.SetState(1936)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1937)
			p.Match(KotlinParserARROW)
		}
		p.SetState(1941)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 286, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1938)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(1943)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 286, p.GetParserRuleContext())
		}
		{
			p.SetState(1944)
			p.Statements()
		}
		p.SetState(1948)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1945)
				p.Match(KotlinParserNL)
			}

			p.SetState(1950)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1951)
			p.Match(KotlinParserRCURL)
		}

	}

	return localctx
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaParameters
	return p
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) AllLambdaParameter() []ILambdaParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILambdaParameterContext)(nil)).Elem())
	var tst = make([]ILambdaParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILambdaParameterContext)
		}
	}

	return tst
}

func (s *LambdaParametersContext) LambdaParameter(i int) ILambdaParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILambdaParameterContext)
}

func (s *LambdaParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *LambdaParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *LambdaParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitLambdaParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) LambdaParameters() (localctx ILambdaParametersContext) {
	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, KotlinParserRULE_lambdaParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1956)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLPAREN || (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(KotlinParserIMPORT-58))|(1<<(KotlinParserCONSTRUCTOR-58))|(1<<(KotlinParserBY-58))|(1<<(KotlinParserCOMPANION-58))|(1<<(KotlinParserINIT-58))|(1<<(KotlinParserWHERE-58))|(1<<(KotlinParserCATCH-58))|(1<<(KotlinParserFINALLY-58)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(KotlinParserOUT-92))|(1<<(KotlinParserGETTER-92))|(1<<(KotlinParserSETTER-92))|(1<<(KotlinParserDYNAMIC-92))|(1<<(KotlinParserPUBLIC-92))|(1<<(KotlinParserPRIVATE-92))|(1<<(KotlinParserPROTECTED-92))|(1<<(KotlinParserINTERNAL-92))|(1<<(KotlinParserENUM-92))|(1<<(KotlinParserSEALED-92))|(1<<(KotlinParserANNOTATION-92))|(1<<(KotlinParserDATA-92))|(1<<(KotlinParserINNER-92))|(1<<(KotlinParserTAILREC-92))|(1<<(KotlinParserOPERATOR-92))|(1<<(KotlinParserINLINE-92))|(1<<(KotlinParserINFIX-92))|(1<<(KotlinParserEXTERNAL-92))|(1<<(KotlinParserSUSPEND-92))|(1<<(KotlinParserOVERRIDE-92))|(1<<(KotlinParserABSTRACT-92))|(1<<(KotlinParserFINAL-92))|(1<<(KotlinParserOPEN-92))|(1<<(KotlinParserCONST-92)))) != 0) || (((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(KotlinParserLATEINIT-124))|(1<<(KotlinParserVARARG-124))|(1<<(KotlinParserNOINLINE-124))|(1<<(KotlinParserCROSSINLINE-124))|(1<<(KotlinParserREIFIED-124))|(1<<(KotlinParserIdentifier-124)))) != 0) {
		{
			p.SetState(1955)
			p.LambdaParameter()
		}

	}
	p.SetState(1974)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1961)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1958)
					p.Match(KotlinParserNL)
				}

				p.SetState(1963)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1964)
				p.Match(KotlinParserCOMMA)
			}
			p.SetState(1968)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1965)
					p.Match(KotlinParserNL)
				}

				p.SetState(1970)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1971)
				p.LambdaParameter()
			}

		}
		p.SetState(1976)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext())
	}

	return localctx
}

// ILambdaParameterContext is an interface to support dynamic dispatch.
type ILambdaParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaParameterContext differentiates from other interfaces.
	IsLambdaParameterContext()
}

type LambdaParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParameterContext() *LambdaParameterContext {
	var p = new(LambdaParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaParameter
	return p
}

func (*LambdaParameterContext) IsLambdaParameterContext() {}

func NewLambdaParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParameterContext {
	var p = new(LambdaParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaParameter

	return p
}

func (s *LambdaParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParameterContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *LambdaParameterContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *LambdaParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *LambdaParameterContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LambdaParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaParameter(s)
	}
}

func (s *LambdaParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaParameter(s)
	}
}

func (s *LambdaParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitLambdaParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) LambdaParameter() (localctx ILambdaParameterContext) {
	localctx = NewLambdaParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, KotlinParserRULE_lambdaParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1995)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserGETTER, KotlinParserSETTER, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1977)
			p.VariableDeclaration()
		}

	case KotlinParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1978)
			p.MultiVariableDeclaration()
		}
		p.SetState(1993)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 295, p.GetParserRuleContext()) == 1 {
			p.SetState(1982)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1979)
					p.Match(KotlinParserNL)
				}

				p.SetState(1984)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1985)
				p.Match(KotlinParserCOLON)
			}
			p.SetState(1989)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1986)
					p.Match(KotlinParserNL)
				}

				p.SetState(1991)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1992)
				p.Type()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_objectLiteral
	return p
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *ObjectLiteralContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ObjectLiteralContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ObjectLiteralContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelegationSpecifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ObjectLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ObjectLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, KotlinParserRULE_objectLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1997)
		p.Match(KotlinParserOBJECT)
	}
	p.SetState(2012)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 299, p.GetParserRuleContext()) == 1 {
		p.SetState(2001)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1998)
				p.Match(KotlinParserNL)
			}

			p.SetState(2003)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2004)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(2008)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2005)
				p.Match(KotlinParserNL)
			}

			p.SetState(2010)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2011)
			p.DelegationSpecifiers()
		}

	}
	p.SetState(2017)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2014)
			p.Match(KotlinParserNL)
		}

		p.SetState(2019)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2020)
		p.ClassBody()
	}

	return localctx
}

// ICollectionLiteralContext is an interface to support dynamic dispatch.
type ICollectionLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectionLiteralContext differentiates from other interfaces.
	IsCollectionLiteralContext()
}

type CollectionLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionLiteralContext() *CollectionLiteralContext {
	var p = new(CollectionLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_collectionLiteral
	return p
}

func (*CollectionLiteralContext) IsCollectionLiteralContext() {}

func NewCollectionLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionLiteralContext {
	var p = new(CollectionLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_collectionLiteral

	return p
}

func (s *CollectionLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionLiteralContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *CollectionLiteralContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *CollectionLiteralContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *CollectionLiteralContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CollectionLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *CollectionLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *CollectionLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCollectionLiteral(s)
	}
}

func (s *CollectionLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCollectionLiteral(s)
	}
}

func (s *CollectionLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitCollectionLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) CollectionLiteral() (localctx ICollectionLiteralContext) {
	localctx = NewCollectionLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, KotlinParserRULE_collectionLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2022)
		p.Match(KotlinParserLSQUARE)
	}
	p.SetState(2024)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserNL)|(1<<KotlinParserLPAREN)|(1<<KotlinParserLSQUARE)|(1<<KotlinParserLCURL)|(1<<KotlinParserADD)|(1<<KotlinParserSUB)|(1<<KotlinParserINCR)|(1<<KotlinParserDECR)|(1<<KotlinParserEXCL))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(KotlinParserCOLONCOLON-36))|(1<<(KotlinParserQ_COLONCOLON-36))|(1<<(KotlinParserAT-36))|(1<<(KotlinParserRETURN_AT-36))|(1<<(KotlinParserCONTINUE_AT-36))|(1<<(KotlinParserBREAK_AT-36))|(1<<(KotlinParserFILE-36))|(1<<(KotlinParserIMPORT-36))|(1<<(KotlinParserOBJECT-36))|(1<<(KotlinParserCONSTRUCTOR-36))|(1<<(KotlinParserBY-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(KotlinParserCOMPANION-68))|(1<<(KotlinParserINIT-68))|(1<<(KotlinParserTHIS-68))|(1<<(KotlinParserSUPER-68))|(1<<(KotlinParserWHERE-68))|(1<<(KotlinParserIF-68))|(1<<(KotlinParserWHEN-68))|(1<<(KotlinParserTRY-68))|(1<<(KotlinParserCATCH-68))|(1<<(KotlinParserFINALLY-68))|(1<<(KotlinParserFOR-68))|(1<<(KotlinParserDO-68))|(1<<(KotlinParserWHILE-68))|(1<<(KotlinParserTHROW-68))|(1<<(KotlinParserRETURN-68))|(1<<(KotlinParserCONTINUE-68))|(1<<(KotlinParserBREAK-68))|(1<<(KotlinParserOUT-68))|(1<<(KotlinParserFIELD-68))|(1<<(KotlinParserPROPERTY-68))|(1<<(KotlinParserGET-68))|(1<<(KotlinParserSET-68))|(1<<(KotlinParserGETTER-68))|(1<<(KotlinParserSETTER-68))|(1<<(KotlinParserRECEIVER-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(KotlinParserPARAM-100))|(1<<(KotlinParserSETPARAM-100))|(1<<(KotlinParserDELEGATE-100))|(1<<(KotlinParserDYNAMIC-100))|(1<<(KotlinParserPUBLIC-100))|(1<<(KotlinParserPRIVATE-100))|(1<<(KotlinParserPROTECTED-100))|(1<<(KotlinParserINTERNAL-100))|(1<<(KotlinParserENUM-100))|(1<<(KotlinParserSEALED-100))|(1<<(KotlinParserANNOTATION-100))|(1<<(KotlinParserDATA-100))|(1<<(KotlinParserINNER-100))|(1<<(KotlinParserTAILREC-100))|(1<<(KotlinParserOPERATOR-100))|(1<<(KotlinParserINLINE-100))|(1<<(KotlinParserINFIX-100))|(1<<(KotlinParserEXTERNAL-100))|(1<<(KotlinParserSUSPEND-100))|(1<<(KotlinParserOVERRIDE-100))|(1<<(KotlinParserABSTRACT-100))|(1<<(KotlinParserFINAL-100))|(1<<(KotlinParserOPEN-100))|(1<<(KotlinParserCONST-100))|(1<<(KotlinParserLATEINIT-100))|(1<<(KotlinParserVARARG-100))|(1<<(KotlinParserNOINLINE-100))|(1<<(KotlinParserCROSSINLINE-100))|(1<<(KotlinParserREIFIED-100))|(1<<(KotlinParserQUOTE_OPEN-100))|(1<<(KotlinParserTRIPLE_QUOTE_OPEN-100))|(1<<(KotlinParserRealLiteral-100)))) != 0) || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(KotlinParserLongLiteral-134))|(1<<(KotlinParserIntegerLiteral-134))|(1<<(KotlinParserHexLiteral-134))|(1<<(KotlinParserBinLiteral-134))|(1<<(KotlinParserBooleanLiteral-134))|(1<<(KotlinParserNullLiteral-134))|(1<<(KotlinParserIdentifier-134))|(1<<(KotlinParserLabelReference-134))|(1<<(KotlinParserLabelDefinition-134))|(1<<(KotlinParserCharacterLiteral-134)))) != 0) {
		{
			p.SetState(2023)
			p.Expression()
		}

	}
	p.SetState(2030)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserCOMMA {
		{
			p.SetState(2026)
			p.Match(KotlinParserCOMMA)
		}
		{
			p.SetState(2027)
			p.Expression()
		}

		p.SetState(2032)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2033)
		p.Match(KotlinParserRSQUARE)
	}

	return localctx
}

// IThisExpressionContext is an interface to support dynamic dispatch.
type IThisExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThisExpressionContext differentiates from other interfaces.
	IsThisExpressionContext()
}

type ThisExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThisExpressionContext() *ThisExpressionContext {
	var p = new(ThisExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_thisExpression
	return p
}

func (*ThisExpressionContext) IsThisExpressionContext() {}

func NewThisExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_thisExpression

	return p
}

func (s *ThisExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ThisExpressionContext) THIS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS, 0)
}

func (s *ThisExpressionContext) LabelReference() antlr.TerminalNode {
	return s.GetToken(KotlinParserLabelReference, 0)
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitThisExpression(s)
	}
}

func (s *ThisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitThisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ThisExpression() (localctx IThisExpressionContext) {
	localctx = NewThisExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, KotlinParserRULE_thisExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2035)
		p.Match(KotlinParserTHIS)
	}
	p.SetState(2037)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 303, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2036)
			p.Match(KotlinParserLabelReference)
		}

	}

	return localctx
}

// ISuperExpressionContext is an interface to support dynamic dispatch.
type ISuperExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuperExpressionContext differentiates from other interfaces.
	IsSuperExpressionContext()
}

type SuperExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperExpressionContext() *SuperExpressionContext {
	var p = new(SuperExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_superExpression
	return p
}

func (*SuperExpressionContext) IsSuperExpressionContext() {}

func NewSuperExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperExpressionContext {
	var p = new(SuperExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_superExpression

	return p
}

func (s *SuperExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SuperExpressionContext) SUPER() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER, 0)
}

func (s *SuperExpressionContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *SuperExpressionContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SuperExpressionContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *SuperExpressionContext) LabelReference() antlr.TerminalNode {
	return s.GetToken(KotlinParserLabelReference, 0)
}

func (s *SuperExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SuperExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SuperExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSuperExpression(s)
	}
}

func (s *SuperExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSuperExpression(s)
	}
}

func (s *SuperExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitSuperExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) SuperExpression() (localctx ISuperExpressionContext) {
	localctx = NewSuperExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, KotlinParserRULE_superExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2039)
		p.Match(KotlinParserSUPER)
	}
	p.SetState(2056)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 306, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2040)
			p.Match(KotlinParserLANGLE)
		}
		p.SetState(2044)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2041)
				p.Match(KotlinParserNL)
			}

			p.SetState(2046)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2047)
			p.Type()
		}
		p.SetState(2051)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2048)
				p.Match(KotlinParserNL)
			}

			p.SetState(2053)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2054)
			p.Match(KotlinParserRANGLE)
		}

	}
	p.SetState(2059)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 307, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2058)
			p.Match(KotlinParserLabelReference)
		}

	}

	return localctx
}

// IConditionalExpressionContext is an interface to support dynamic dispatch.
type IConditionalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalExpressionContext differentiates from other interfaces.
	IsConditionalExpressionContext()
}

type ConditionalExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalExpressionContext() *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_conditionalExpression
	return p
}

func (*ConditionalExpressionContext) IsConditionalExpressionContext() {}

func NewConditionalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_conditionalExpression

	return p
}

func (s *ConditionalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalExpressionContext) IfExpression() IIfExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExpressionContext)
}

func (s *ConditionalExpressionContext) WhenExpression() IWhenExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConditionalExpression(s)
	}
}

func (s *ConditionalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConditionalExpression(s)
	}
}

func (s *ConditionalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitConditionalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ConditionalExpression() (localctx IConditionalExpressionContext) {
	localctx = NewConditionalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, KotlinParserRULE_conditionalExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2063)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2061)
			p.IfExpression()
		}

	case KotlinParserWHEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2062)
			p.WhenExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfExpressionContext is an interface to support dynamic dispatch.
type IIfExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfExpressionContext differentiates from other interfaces.
	IsIfExpressionContext()
}

type IfExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExpressionContext() *IfExpressionContext {
	var p = new(IfExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_ifExpression
	return p
}

func (*IfExpressionContext) IsIfExpressionContext() {}

func NewIfExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExpressionContext {
	var p = new(IfExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_ifExpression

	return p
}

func (s *IfExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExpressionContext) IF() antlr.TerminalNode {
	return s.GetToken(KotlinParserIF, 0)
}

func (s *IfExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *IfExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *IfExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IfExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IfExpressionContext) AllControlStructureBody() []IControlStructureBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem())
	var tst = make([]IControlStructureBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IControlStructureBodyContext)
		}
	}

	return tst
}

func (s *IfExpressionContext) ControlStructureBody(i int) IControlStructureBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *IfExpressionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *IfExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserELSE, 0)
}

func (s *IfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIfExpression(s)
	}
}

func (s *IfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIfExpression(s)
	}
}

func (s *IfExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitIfExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) IfExpression() (localctx IIfExpressionContext) {
	localctx = NewIfExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, KotlinParserRULE_ifExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2065)
		p.Match(KotlinParserIF)
	}
	p.SetState(2069)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2066)
			p.Match(KotlinParserNL)
		}

		p.SetState(2071)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2072)
		p.Match(KotlinParserLPAREN)
	}
	{
		p.SetState(2073)
		p.Expression()
	}
	{
		p.SetState(2074)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(2078)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 310, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2075)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2080)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 310, p.GetParserRuleContext())
	}
	p.SetState(2082)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 311, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2081)
			p.ControlStructureBody()
		}

	}
	p.SetState(2085)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 312, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2084)
			p.Match(KotlinParserSEMICOLON)
		}

	}
	p.SetState(2103)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 316, p.GetParserRuleContext()) == 1 {
		p.SetState(2090)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2087)
				p.Match(KotlinParserNL)
			}

			p.SetState(2092)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2093)
			p.Match(KotlinParserELSE)
		}
		p.SetState(2097)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 314, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2094)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2099)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 314, p.GetParserRuleContext())
		}
		p.SetState(2101)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2100)
				p.ControlStructureBody()
			}

		}

	}

	return localctx
}

// IControlStructureBodyContext is an interface to support dynamic dispatch.
type IControlStructureBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsControlStructureBodyContext differentiates from other interfaces.
	IsControlStructureBodyContext()
}

type ControlStructureBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControlStructureBodyContext() *ControlStructureBodyContext {
	var p = new(ControlStructureBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_controlStructureBody
	return p
}

func (*ControlStructureBodyContext) IsControlStructureBodyContext() {}

func NewControlStructureBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ControlStructureBodyContext {
	var p = new(ControlStructureBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_controlStructureBody

	return p
}

func (s *ControlStructureBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ControlStructureBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ControlStructureBodyContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ControlStructureBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ControlStructureBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ControlStructureBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterControlStructureBody(s)
	}
}

func (s *ControlStructureBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitControlStructureBody(s)
	}
}

func (s *ControlStructureBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitControlStructureBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ControlStructureBody() (localctx IControlStructureBodyContext) {
	localctx = NewControlStructureBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, KotlinParserRULE_controlStructureBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2107)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 317, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2105)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2106)
			p.Expression()
		}

	}

	return localctx
}

// IWhenExpressionContext is an interface to support dynamic dispatch.
type IWhenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenExpressionContext differentiates from other interfaces.
	IsWhenExpressionContext()
}

type WhenExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenExpressionContext() *WhenExpressionContext {
	var p = new(WhenExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenExpression
	return p
}

func (*WhenExpressionContext) IsWhenExpressionContext() {}

func NewWhenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenExpressionContext {
	var p = new(WhenExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenExpression

	return p
}

func (s *WhenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenExpressionContext) WHEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHEN, 0)
}

func (s *WhenExpressionContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *WhenExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *WhenExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *WhenExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *WhenExpressionContext) AllWhenEntry() []IWhenEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenEntryContext)(nil)).Elem())
	var tst = make([]IWhenEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenEntryContext)
		}
	}

	return tst
}

func (s *WhenExpressionContext) WhenEntry(i int) IWhenEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenEntryContext)
}

func (s *WhenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenExpression(s)
	}
}

func (s *WhenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenExpression(s)
	}
}

func (s *WhenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitWhenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) WhenExpression() (localctx IWhenExpressionContext) {
	localctx = NewWhenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, KotlinParserRULE_whenExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2109)
		p.Match(KotlinParserWHEN)
	}
	p.SetState(2113)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2110)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2115)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())
	}
	p.SetState(2120)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLPAREN {
		{
			p.SetState(2116)
			p.Match(KotlinParserLPAREN)
		}
		{
			p.SetState(2117)
			p.Expression()
		}
		{
			p.SetState(2118)
			p.Match(KotlinParserRPAREN)
		}

	}
	p.SetState(2125)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2122)
			p.Match(KotlinParserNL)
		}

		p.SetState(2127)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2128)
		p.Match(KotlinParserLCURL)
	}
	p.SetState(2132)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 321, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2129)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2134)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 321, p.GetParserRuleContext())
	}
	p.SetState(2144)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2135)
				p.WhenEntry()
			}
			p.SetState(2139)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 322, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2136)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(2141)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 322, p.GetParserRuleContext())
			}

		}
		p.SetState(2146)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())
	}
	p.SetState(2150)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2147)
			p.Match(KotlinParserNL)
		}

		p.SetState(2152)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2153)
		p.Match(KotlinParserRCURL)
	}

	return localctx
}

// IWhenEntryContext is an interface to support dynamic dispatch.
type IWhenEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenEntryContext differentiates from other interfaces.
	IsWhenEntryContext()
}

type WhenEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenEntryContext() *WhenEntryContext {
	var p = new(WhenEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenEntry
	return p
}

func (*WhenEntryContext) IsWhenEntryContext() {}

func NewWhenEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenEntryContext {
	var p = new(WhenEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenEntry

	return p
}

func (s *WhenEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenEntryContext) AllWhenCondition() []IWhenConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenConditionContext)(nil)).Elem())
	var tst = make([]IWhenConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenConditionContext)
		}
	}

	return tst
}

func (s *WhenEntryContext) WhenCondition(i int) IWhenConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenConditionContext)
}

func (s *WhenEntryContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *WhenEntryContext) ControlStructureBody() IControlStructureBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *WhenEntryContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *WhenEntryContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *WhenEntryContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenEntryContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenEntryContext) Semi() ISemiContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISemiContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *WhenEntryContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserELSE, 0)
}

func (s *WhenEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenEntry(s)
	}
}

func (s *WhenEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenEntry(s)
	}
}

func (s *WhenEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitWhenEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) WhenEntry() (localctx IWhenEntryContext) {
	localctx = NewWhenEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, KotlinParserRULE_whenEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2207)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL, KotlinParserCOLONCOLON, KotlinParserQ_COLONCOLON, KotlinParserAT, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserFILE, KotlinParserIMPORT, KotlinParserOBJECT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserIS, KotlinParserIN, KotlinParserNOT_IS, KotlinParserNOT_IN, KotlinParserOUT, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserGETTER, KotlinParserSETTER, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN, KotlinParserRealLiteral, KotlinParserLongLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserIdentifier, KotlinParserLabelReference, KotlinParserLabelDefinition, KotlinParserCharacterLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2155)
			p.WhenCondition()
		}
		p.SetState(2172)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2159)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2156)
						p.Match(KotlinParserNL)
					}

					p.SetState(2161)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2162)
					p.Match(KotlinParserCOMMA)
				}
				p.SetState(2166)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 326, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(2163)
							p.Match(KotlinParserNL)
						}

					}
					p.SetState(2168)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 326, p.GetParserRuleContext())
				}
				{
					p.SetState(2169)
					p.WhenCondition()
				}

			}
			p.SetState(2174)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext())
		}
		p.SetState(2178)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2175)
				p.Match(KotlinParserNL)
			}

			p.SetState(2180)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2181)
			p.Match(KotlinParserARROW)
		}
		p.SetState(2185)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 329, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2182)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2187)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 329, p.GetParserRuleContext())
		}
		{
			p.SetState(2188)
			p.ControlStructureBody()
		}
		p.SetState(2190)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2189)
				p.Semi()
			}

		}

	case KotlinParserELSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2192)
			p.Match(KotlinParserELSE)
		}
		p.SetState(2196)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2193)
				p.Match(KotlinParserNL)
			}

			p.SetState(2198)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2199)
			p.Match(KotlinParserARROW)
		}
		p.SetState(2203)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2200)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2205)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())
		}
		{
			p.SetState(2206)
			p.ControlStructureBody()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhenConditionContext is an interface to support dynamic dispatch.
type IWhenConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenConditionContext differentiates from other interfaces.
	IsWhenConditionContext()
}

type WhenConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenConditionContext() *WhenConditionContext {
	var p = new(WhenConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whenCondition
	return p
}

func (*WhenConditionContext) IsWhenConditionContext() {}

func NewWhenConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenConditionContext {
	var p = new(WhenConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenCondition

	return p
}

func (s *WhenConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenConditionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenConditionContext) RangeTest() IRangeTestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRangeTestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRangeTestContext)
}

func (s *WhenConditionContext) TypeTest() ITypeTestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTestContext)
}

func (s *WhenConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenCondition(s)
	}
}

func (s *WhenConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenCondition(s)
	}
}

func (s *WhenConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitWhenCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) WhenCondition() (localctx IWhenConditionContext) {
	localctx = NewWhenConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, KotlinParserRULE_whenCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2212)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL, KotlinParserCOLONCOLON, KotlinParserQ_COLONCOLON, KotlinParserAT, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserFILE, KotlinParserIMPORT, KotlinParserOBJECT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserGETTER, KotlinParserSETTER, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN, KotlinParserRealLiteral, KotlinParserLongLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserIdentifier, KotlinParserLabelReference, KotlinParserLabelDefinition, KotlinParserCharacterLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2209)
			p.Expression()
		}

	case KotlinParserIN, KotlinParserNOT_IN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2210)
			p.RangeTest()
		}

	case KotlinParserIS, KotlinParserNOT_IS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2211)
			p.TypeTest()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRangeTestContext is an interface to support dynamic dispatch.
type IRangeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeTestContext differentiates from other interfaces.
	IsRangeTestContext()
}

type RangeTestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeTestContext() *RangeTestContext {
	var p = new(RangeTestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_rangeTest
	return p
}

func (*RangeTestContext) IsRangeTestContext() {}

func NewRangeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeTestContext {
	var p = new(RangeTestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_rangeTest

	return p
}

func (s *RangeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeTestContext) InOperator() IInOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInOperatorContext)
}

func (s *RangeTestContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeTestContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *RangeTestContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *RangeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterRangeTest(s)
	}
}

func (s *RangeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitRangeTest(s)
	}
}

func (s *RangeTestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitRangeTest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) RangeTest() (localctx IRangeTestContext) {
	localctx = NewRangeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, KotlinParserRULE_rangeTest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2214)
		p.InOperator()
	}
	p.SetState(2218)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 335, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2215)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2220)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 335, p.GetParserRuleContext())
	}
	{
		p.SetState(2221)
		p.Expression()
	}

	return localctx
}

// ITypeTestContext is an interface to support dynamic dispatch.
type ITypeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeTestContext differentiates from other interfaces.
	IsTypeTestContext()
}

type TypeTestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTestContext() *TypeTestContext {
	var p = new(TypeTestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeTest
	return p
}

func (*TypeTestContext) IsTypeTestContext() {}

func NewTypeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTestContext {
	var p = new(TypeTestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeTest

	return p
}

func (s *TypeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTestContext) IsOperator() IIsOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIsOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIsOperatorContext)
}

func (s *TypeTestContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeTestContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeTestContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeTest(s)
	}
}

func (s *TypeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeTest(s)
	}
}

func (s *TypeTestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeTest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeTest() (localctx ITypeTestContext) {
	localctx = NewTypeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, KotlinParserRULE_typeTest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2223)
		p.IsOperator()
	}
	p.SetState(2227)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2224)
			p.Match(KotlinParserNL)
		}

		p.SetState(2229)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2230)
		p.Type()
	}

	return localctx
}

// ITryExpressionContext is an interface to support dynamic dispatch.
type ITryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryExpressionContext differentiates from other interfaces.
	IsTryExpressionContext()
}

type TryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExpressionContext() *TryExpressionContext {
	var p = new(TryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_tryExpression
	return p
}

func (*TryExpressionContext) IsTryExpressionContext() {}

func NewTryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExpressionContext {
	var p = new(TryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_tryExpression

	return p
}

func (s *TryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExpressionContext) TRY() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRY, 0)
}

func (s *TryExpressionContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TryExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TryExpressionContext) AllCatchBlock() []ICatchBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICatchBlockContext)(nil)).Elem())
	var tst = make([]ICatchBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICatchBlockContext)
		}
	}

	return tst
}

func (s *TryExpressionContext) CatchBlock(i int) ICatchBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICatchBlockContext)
}

func (s *TryExpressionContext) FinallyBlock() IFinallyBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinallyBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTryExpression(s)
	}
}

func (s *TryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTryExpression(s)
	}
}

func (s *TryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TryExpression() (localctx ITryExpressionContext) {
	localctx = NewTryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, KotlinParserRULE_tryExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2232)
		p.Match(KotlinParserTRY)
	}
	p.SetState(2236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2233)
			p.Match(KotlinParserNL)
		}

		p.SetState(2238)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2239)
		p.Block()
	}
	p.SetState(2249)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 339, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2243)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2240)
					p.Match(KotlinParserNL)
				}

				p.SetState(2245)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2246)
				p.CatchBlock()
			}

		}
		p.SetState(2251)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 339, p.GetParserRuleContext())
	}
	p.SetState(2259)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 341, p.GetParserRuleContext()) == 1 {
		p.SetState(2255)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2252)
				p.Match(KotlinParserNL)
			}

			p.SetState(2257)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2258)
			p.FinallyBlock()
		}

	}

	return localctx
}

// ICatchBlockContext is an interface to support dynamic dispatch.
type ICatchBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchBlockContext differentiates from other interfaces.
	IsCatchBlockContext()
}

type CatchBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchBlockContext() *CatchBlockContext {
	var p = new(CatchBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_catchBlock
	return p
}

func (*CatchBlockContext) IsCatchBlockContext() {}

func NewCatchBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchBlockContext {
	var p = new(CatchBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_catchBlock

	return p
}

func (s *CatchBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchBlockContext) CATCH() antlr.TerminalNode {
	return s.GetToken(KotlinParserCATCH, 0)
}

func (s *CatchBlockContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *CatchBlockContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CatchBlockContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *CatchBlockContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *CatchBlockContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *CatchBlockContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchBlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CatchBlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CatchBlockContext) AllAnnotations() []IAnnotationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem())
	var tst = make([]IAnnotationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsContext)
		}
	}

	return tst
}

func (s *CatchBlockContext) Annotations(i int) IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *CatchBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCatchBlock(s)
	}
}

func (s *CatchBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCatchBlock(s)
	}
}

func (s *CatchBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitCatchBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) CatchBlock() (localctx ICatchBlockContext) {
	localctx = NewCatchBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, KotlinParserRULE_catchBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2261)
		p.Match(KotlinParserCATCH)
	}
	p.SetState(2265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2262)
			p.Match(KotlinParserNL)
		}

		p.SetState(2267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2268)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2272)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(KotlinParserFIELD-93))|(1<<(KotlinParserPROPERTY-93))|(1<<(KotlinParserGET-93))|(1<<(KotlinParserSET-93))|(1<<(KotlinParserRECEIVER-93))|(1<<(KotlinParserPARAM-93))|(1<<(KotlinParserSETPARAM-93))|(1<<(KotlinParserDELEGATE-93)))) != 0) || _la == KotlinParserLabelReference {
		{
			p.SetState(2269)
			p.Annotations()
		}

		p.SetState(2274)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2275)
		p.SimpleIdentifier()
	}
	{
		p.SetState(2276)
		p.Match(KotlinParserCOLON)
	}
	{
		p.SetState(2277)
		p.UserType()
	}
	{
		p.SetState(2278)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(2282)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2279)
			p.Match(KotlinParserNL)
		}

		p.SetState(2284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2285)
		p.Block()
	}

	return localctx
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_finallyBlock
	return p
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINALLY, 0)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FinallyBlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFinallyBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FinallyBlock() (localctx IFinallyBlockContext) {
	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, KotlinParserRULE_finallyBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2287)
		p.Match(KotlinParserFINALLY)
	}
	p.SetState(2291)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2288)
			p.Match(KotlinParserNL)
		}

		p.SetState(2293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2294)
		p.Block()
	}

	return localctx
}

// ILoopExpressionContext is an interface to support dynamic dispatch.
type ILoopExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoopExpressionContext differentiates from other interfaces.
	IsLoopExpressionContext()
}

type LoopExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopExpressionContext() *LoopExpressionContext {
	var p = new(LoopExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_loopExpression
	return p
}

func (*LoopExpressionContext) IsLoopExpressionContext() {}

func NewLoopExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopExpressionContext {
	var p = new(LoopExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_loopExpression

	return p
}

func (s *LoopExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopExpressionContext) ForExpression() IForExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForExpressionContext)
}

func (s *LoopExpressionContext) WhileExpression() IWhileExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhileExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhileExpressionContext)
}

func (s *LoopExpressionContext) DoWhileExpression() IDoWhileExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoWhileExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoWhileExpressionContext)
}

func (s *LoopExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLoopExpression(s)
	}
}

func (s *LoopExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLoopExpression(s)
	}
}

func (s *LoopExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitLoopExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) LoopExpression() (localctx ILoopExpressionContext) {
	localctx = NewLoopExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, KotlinParserRULE_loopExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2299)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2296)
			p.ForExpression()
		}

	case KotlinParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2297)
			p.WhileExpression()
		}

	case KotlinParserDO:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2298)
			p.DoWhileExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForExpressionContext is an interface to support dynamic dispatch.
type IForExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForExpressionContext differentiates from other interfaces.
	IsForExpressionContext()
}

type ForExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForExpressionContext() *ForExpressionContext {
	var p = new(ForExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_forExpression
	return p
}

func (*ForExpressionContext) IsForExpressionContext() {}

func NewForExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForExpressionContext {
	var p = new(ForExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_forExpression

	return p
}

func (s *ForExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ForExpressionContext) FOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserFOR, 0)
}

func (s *ForExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ForExpressionContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *ForExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ForExpressionContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *ForExpressionContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *ForExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ForExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ForExpressionContext) AllAnnotations() []IAnnotationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem())
	var tst = make([]IAnnotationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsContext)
		}
	}

	return tst
}

func (s *ForExpressionContext) Annotations(i int) IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *ForExpressionContext) ControlStructureBody() IControlStructureBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *ForExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterForExpression(s)
	}
}

func (s *ForExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitForExpression(s)
	}
}

func (s *ForExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitForExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ForExpression() (localctx IForExpressionContext) {
	localctx = NewForExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, KotlinParserRULE_forExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2301)
		p.Match(KotlinParserFOR)
	}
	p.SetState(2305)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2302)
			p.Match(KotlinParserNL)
		}

		p.SetState(2307)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2308)
		p.Match(KotlinParserLPAREN)
	}
	p.SetState(2312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT || _la == KotlinParserFILE || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(KotlinParserFIELD-93))|(1<<(KotlinParserPROPERTY-93))|(1<<(KotlinParserGET-93))|(1<<(KotlinParserSET-93))|(1<<(KotlinParserRECEIVER-93))|(1<<(KotlinParserPARAM-93))|(1<<(KotlinParserSETPARAM-93))|(1<<(KotlinParserDELEGATE-93)))) != 0) || _la == KotlinParserLabelReference {
		{
			p.SetState(2309)
			p.Annotations()
		}

		p.SetState(2314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2317)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserGETTER, KotlinParserSETTER, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserIdentifier:
		{
			p.SetState(2315)
			p.VariableDeclaration()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(2316)
			p.MultiVariableDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2319)
		p.Match(KotlinParserIN)
	}
	{
		p.SetState(2320)
		p.Expression()
	}
	{
		p.SetState(2321)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(2325)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 350, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2322)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2327)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 350, p.GetParserRuleContext())
	}
	p.SetState(2329)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 351, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2328)
			p.ControlStructureBody()
		}

	}

	return localctx
}

// IWhileExpressionContext is an interface to support dynamic dispatch.
type IWhileExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileExpressionContext differentiates from other interfaces.
	IsWhileExpressionContext()
}

type WhileExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileExpressionContext() *WhileExpressionContext {
	var p = new(WhileExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_whileExpression
	return p
}

func (*WhileExpressionContext) IsWhileExpressionContext() {}

func NewWhileExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileExpressionContext {
	var p = new(WhileExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whileExpression

	return p
}

func (s *WhileExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileExpressionContext) WHILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHILE, 0)
}

func (s *WhileExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *WhileExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *WhileExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhileExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhileExpressionContext) ControlStructureBody() IControlStructureBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *WhileExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhileExpression(s)
	}
}

func (s *WhileExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhileExpression(s)
	}
}

func (s *WhileExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitWhileExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) WhileExpression() (localctx IWhileExpressionContext) {
	localctx = NewWhileExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, KotlinParserRULE_whileExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2331)
		p.Match(KotlinParserWHILE)
	}
	p.SetState(2335)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2332)
			p.Match(KotlinParserNL)
		}

		p.SetState(2337)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2338)
		p.Match(KotlinParserLPAREN)
	}
	{
		p.SetState(2339)
		p.Expression()
	}
	{
		p.SetState(2340)
		p.Match(KotlinParserRPAREN)
	}
	p.SetState(2344)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 353, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2341)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2346)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 353, p.GetParserRuleContext())
	}
	p.SetState(2348)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2347)
			p.ControlStructureBody()
		}

	}

	return localctx
}

// IDoWhileExpressionContext is an interface to support dynamic dispatch.
type IDoWhileExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoWhileExpressionContext differentiates from other interfaces.
	IsDoWhileExpressionContext()
}

type DoWhileExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileExpressionContext() *DoWhileExpressionContext {
	var p = new(DoWhileExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_doWhileExpression
	return p
}

func (*DoWhileExpressionContext) IsDoWhileExpressionContext() {}

func NewDoWhileExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileExpressionContext {
	var p = new(DoWhileExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_doWhileExpression

	return p
}

func (s *DoWhileExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileExpressionContext) DO() antlr.TerminalNode {
	return s.GetToken(KotlinParserDO, 0)
}

func (s *DoWhileExpressionContext) WHILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHILE, 0)
}

func (s *DoWhileExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *DoWhileExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoWhileExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *DoWhileExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DoWhileExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DoWhileExpressionContext) ControlStructureBody() IControlStructureBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlStructureBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *DoWhileExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDoWhileExpression(s)
	}
}

func (s *DoWhileExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDoWhileExpression(s)
	}
}

func (s *DoWhileExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitDoWhileExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) DoWhileExpression() (localctx IDoWhileExpressionContext) {
	localctx = NewDoWhileExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, KotlinParserRULE_doWhileExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2350)
		p.Match(KotlinParserDO)
	}
	p.SetState(2354)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 355, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2351)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2356)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 355, p.GetParserRuleContext())
	}
	p.SetState(2358)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 356, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2357)
			p.ControlStructureBody()
		}

	}
	p.SetState(2363)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2360)
			p.Match(KotlinParserNL)
		}

		p.SetState(2365)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2366)
		p.Match(KotlinParserWHILE)
	}
	p.SetState(2370)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2367)
			p.Match(KotlinParserNL)
		}

		p.SetState(2372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2373)
		p.Match(KotlinParserLPAREN)
	}
	{
		p.SetState(2374)
		p.Expression()
	}
	{
		p.SetState(2375)
		p.Match(KotlinParserRPAREN)
	}

	return localctx
}

// IJumpExpressionContext is an interface to support dynamic dispatch.
type IJumpExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJumpExpressionContext differentiates from other interfaces.
	IsJumpExpressionContext()
}

type JumpExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJumpExpressionContext() *JumpExpressionContext {
	var p = new(JumpExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_jumpExpression
	return p
}

func (*JumpExpressionContext) IsJumpExpressionContext() {}

func NewJumpExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JumpExpressionContext {
	var p = new(JumpExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_jumpExpression

	return p
}

func (s *JumpExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *JumpExpressionContext) THROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHROW, 0)
}

func (s *JumpExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JumpExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *JumpExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *JumpExpressionContext) RETURN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRETURN, 0)
}

func (s *JumpExpressionContext) RETURN_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserRETURN_AT, 0)
}

func (s *JumpExpressionContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONTINUE, 0)
}

func (s *JumpExpressionContext) CONTINUE_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONTINUE_AT, 0)
}

func (s *JumpExpressionContext) BREAK() antlr.TerminalNode {
	return s.GetToken(KotlinParserBREAK, 0)
}

func (s *JumpExpressionContext) BREAK_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserBREAK_AT, 0)
}

func (s *JumpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JumpExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JumpExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterJumpExpression(s)
	}
}

func (s *JumpExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitJumpExpression(s)
	}
}

func (s *JumpExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitJumpExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) JumpExpression() (localctx IJumpExpressionContext) {
	localctx = NewJumpExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, KotlinParserRULE_jumpExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2393)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserTHROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2377)
			p.Match(KotlinParserTHROW)
		}
		p.SetState(2381)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 359, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2378)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2383)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 359, p.GetParserRuleContext())
		}
		{
			p.SetState(2384)
			p.Expression()
		}

	case KotlinParserRETURN_AT, KotlinParserRETURN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2385)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KotlinParserRETURN_AT || _la == KotlinParserRETURN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2387)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 360, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2386)
				p.Expression()
			}

		}

	case KotlinParserCONTINUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2389)
			p.Match(KotlinParserCONTINUE)
		}

	case KotlinParserCONTINUE_AT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2390)
			p.Match(KotlinParserCONTINUE_AT)
		}

	case KotlinParserBREAK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2391)
			p.Match(KotlinParserBREAK)
		}

	case KotlinParserBREAK_AT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2392)
			p.Match(KotlinParserBREAK_AT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallableReferenceContext is an interface to support dynamic dispatch.
type ICallableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallableReferenceContext differentiates from other interfaces.
	IsCallableReferenceContext()
}

type CallableReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallableReferenceContext() *CallableReferenceContext {
	var p = new(CallableReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_callableReference
	return p
}

func (*CallableReferenceContext) IsCallableReferenceContext() {}

func NewCallableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallableReferenceContext {
	var p = new(CallableReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_callableReference

	return p
}

func (s *CallableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CallableReferenceContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLONCOLON, 0)
}

func (s *CallableReferenceContext) Q_COLONCOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserQ_COLONCOLON, 0)
}

func (s *CallableReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallableReferenceContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *CallableReferenceContext) UserType() IUserTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *CallableReferenceContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CallableReferenceContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CallableReferenceContext) AllQUEST() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserQUEST)
}

func (s *CallableReferenceContext) QUEST(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST, i)
}

func (s *CallableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCallableReference(s)
	}
}

func (s *CallableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCallableReference(s)
	}
}

func (s *CallableReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitCallableReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) CallableReference() (localctx ICallableReferenceContext) {
	localctx = NewCallableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, KotlinParserRULE_callableReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(KotlinParserIMPORT-58))|(1<<(KotlinParserCONSTRUCTOR-58))|(1<<(KotlinParserBY-58))|(1<<(KotlinParserCOMPANION-58))|(1<<(KotlinParserINIT-58))|(1<<(KotlinParserWHERE-58))|(1<<(KotlinParserCATCH-58))|(1<<(KotlinParserFINALLY-58)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(KotlinParserOUT-92))|(1<<(KotlinParserGETTER-92))|(1<<(KotlinParserSETTER-92))|(1<<(KotlinParserDYNAMIC-92))|(1<<(KotlinParserPUBLIC-92))|(1<<(KotlinParserPRIVATE-92))|(1<<(KotlinParserPROTECTED-92))|(1<<(KotlinParserINTERNAL-92))|(1<<(KotlinParserENUM-92))|(1<<(KotlinParserSEALED-92))|(1<<(KotlinParserANNOTATION-92))|(1<<(KotlinParserDATA-92))|(1<<(KotlinParserINNER-92))|(1<<(KotlinParserTAILREC-92))|(1<<(KotlinParserOPERATOR-92))|(1<<(KotlinParserINLINE-92))|(1<<(KotlinParserINFIX-92))|(1<<(KotlinParserEXTERNAL-92))|(1<<(KotlinParserSUSPEND-92))|(1<<(KotlinParserOVERRIDE-92))|(1<<(KotlinParserABSTRACT-92))|(1<<(KotlinParserFINAL-92))|(1<<(KotlinParserOPEN-92))|(1<<(KotlinParserCONST-92)))) != 0) || (((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(KotlinParserLATEINIT-124))|(1<<(KotlinParserVARARG-124))|(1<<(KotlinParserNOINLINE-124))|(1<<(KotlinParserCROSSINLINE-124))|(1<<(KotlinParserREIFIED-124))|(1<<(KotlinParserIdentifier-124)))) != 0) {
		{
			p.SetState(2395)
			p.UserType()
		}
		p.SetState(2405)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserQUEST {
			{
				p.SetState(2396)
				p.Match(KotlinParserQUEST)
			}
			p.SetState(2400)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 362, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2397)
						p.Match(KotlinParserNL)
					}

				}
				p.SetState(2402)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 362, p.GetParserRuleContext())
			}

			p.SetState(2407)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2413)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2410)
			p.Match(KotlinParserNL)
		}

		p.SetState(2415)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2416)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserCOLONCOLON || _la == KotlinParserQ_COLONCOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2417)
			p.Match(KotlinParserNL)
		}

		p.SetState(2422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2425)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserGETTER, KotlinParserSETTER, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserIdentifier:
		{
			p.SetState(2423)
			p.Identifier()
		}

	case KotlinParserCLASS:
		{
			p.SetState(2424)
			p.Match(KotlinParserCLASS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *AssignmentOperatorContext) ADD_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD_ASSIGNMENT, 0)
}

func (s *AssignmentOperatorContext) SUB_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB_ASSIGNMENT, 0)
}

func (s *AssignmentOperatorContext) MULT_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT_ASSIGNMENT, 0)
}

func (s *AssignmentOperatorContext) DIV_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDIV_ASSIGNMENT, 0)
}

func (s *AssignmentOperatorContext) MOD_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMOD_ASSIGNMENT, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, KotlinParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2427)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-27)&-(0x1f+1)) == 0 && ((1<<uint((_la-27)))&((1<<(KotlinParserASSIGNMENT-27))|(1<<(KotlinParserADD_ASSIGNMENT-27))|(1<<(KotlinParserSUB_ASSIGNMENT-27))|(1<<(KotlinParserMULT_ASSIGNMENT-27))|(1<<(KotlinParserDIV_ASSIGNMENT-27))|(1<<(KotlinParserMOD_ASSIGNMENT-27)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEqualityOperationContext is an interface to support dynamic dispatch.
type IEqualityOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqualityOperationContext differentiates from other interfaces.
	IsEqualityOperationContext()
}

type EqualityOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityOperationContext() *EqualityOperationContext {
	var p = new(EqualityOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_equalityOperation
	return p
}

func (*EqualityOperationContext) IsEqualityOperationContext() {}

func NewEqualityOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityOperationContext {
	var p = new(EqualityOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_equalityOperation

	return p
}

func (s *EqualityOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityOperationContext) EXCL_EQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_EQ, 0)
}

func (s *EqualityOperationContext) EXCL_EQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_EQEQ, 0)
}

func (s *EqualityOperationContext) EQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEQEQ, 0)
}

func (s *EqualityOperationContext) EQEQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEQEQEQ, 0)
}

func (s *EqualityOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEqualityOperation(s)
	}
}

func (s *EqualityOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEqualityOperation(s)
	}
}

func (s *EqualityOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitEqualityOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) EqualityOperation() (localctx IEqualityOperationContext) {
	localctx = NewEqualityOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, KotlinParserRULE_equalityOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2429)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-47)&-(0x1f+1)) == 0 && ((1<<uint((_la-47)))&((1<<(KotlinParserEXCL_EQ-47))|(1<<(KotlinParserEXCL_EQEQ-47))|(1<<(KotlinParserEQEQ-47))|(1<<(KotlinParserEQEQEQ-47)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *ComparisonOperatorContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *ComparisonOperatorContext) LE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLE, 0)
}

func (s *ComparisonOperatorContext) GE() antlr.TerminalNode {
	return s.GetToken(KotlinParserGE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, KotlinParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2431)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(KotlinParserLANGLE-43))|(1<<(KotlinParserRANGLE-43))|(1<<(KotlinParserLE-43))|(1<<(KotlinParserGE-43)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInOperatorContext is an interface to support dynamic dispatch.
type IInOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInOperatorContext differentiates from other interfaces.
	IsInOperatorContext()
}

type InOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInOperatorContext() *InOperatorContext {
	var p = new(InOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_inOperator
	return p
}

func (*InOperatorContext) IsInOperatorContext() {}

func NewInOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InOperatorContext {
	var p = new(InOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_inOperator

	return p
}

func (s *InOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *InOperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *InOperatorContext) NOT_IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOT_IN, 0)
}

func (s *InOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInOperator(s)
	}
}

func (s *InOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInOperator(s)
	}
}

func (s *InOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitInOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) InOperator() (localctx IInOperatorContext) {
	localctx = NewInOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, KotlinParserRULE_inOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2433)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIN || _la == KotlinParserNOT_IN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIsOperatorContext is an interface to support dynamic dispatch.
type IIsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIsOperatorContext differentiates from other interfaces.
	IsIsOperatorContext()
}

type IsOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsOperatorContext() *IsOperatorContext {
	var p = new(IsOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_isOperator
	return p
}

func (*IsOperatorContext) IsIsOperatorContext() {}

func NewIsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsOperatorContext {
	var p = new(IsOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_isOperator

	return p
}

func (s *IsOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *IsOperatorContext) IS() antlr.TerminalNode {
	return s.GetToken(KotlinParserIS, 0)
}

func (s *IsOperatorContext) NOT_IS() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOT_IS, 0)
}

func (s *IsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIsOperator(s)
	}
}

func (s *IsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIsOperator(s)
	}
}

func (s *IsOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitIsOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) IsOperator() (localctx IIsOperatorContext) {
	localctx = NewIsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, KotlinParserRULE_isOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2435)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIS || _la == KotlinParserNOT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAdditiveOperatorContext is an interface to support dynamic dispatch.
type IAdditiveOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditiveOperatorContext differentiates from other interfaces.
	IsAdditiveOperatorContext()
}

type AdditiveOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveOperatorContext() *AdditiveOperatorContext {
	var p = new(AdditiveOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_additiveOperator
	return p
}

func (*AdditiveOperatorContext) IsAdditiveOperatorContext() {}

func NewAdditiveOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveOperatorContext {
	var p = new(AdditiveOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_additiveOperator

	return p
}

func (s *AdditiveOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveOperatorContext) ADD() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD, 0)
}

func (s *AdditiveOperatorContext) SUB() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB, 0)
}

func (s *AdditiveOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAdditiveOperator(s)
	}
}

func (s *AdditiveOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAdditiveOperator(s)
	}
}

func (s *AdditiveOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAdditiveOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) AdditiveOperator() (localctx IAdditiveOperatorContext) {
	localctx = NewAdditiveOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, KotlinParserRULE_additiveOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2437)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserADD || _la == KotlinParserSUB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMultiplicativeOperationContext is an interface to support dynamic dispatch.
type IMultiplicativeOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicativeOperationContext differentiates from other interfaces.
	IsMultiplicativeOperationContext()
}

type MultiplicativeOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeOperationContext() *MultiplicativeOperationContext {
	var p = new(MultiplicativeOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_multiplicativeOperation
	return p
}

func (*MultiplicativeOperationContext) IsMultiplicativeOperationContext() {}

func NewMultiplicativeOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeOperationContext {
	var p = new(MultiplicativeOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiplicativeOperation

	return p
}

func (s *MultiplicativeOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeOperationContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *MultiplicativeOperationContext) DIV() antlr.TerminalNode {
	return s.GetToken(KotlinParserDIV, 0)
}

func (s *MultiplicativeOperationContext) MOD() antlr.TerminalNode {
	return s.GetToken(KotlinParserMOD, 0)
}

func (s *MultiplicativeOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiplicativeOperation(s)
	}
}

func (s *MultiplicativeOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiplicativeOperation(s)
	}
}

func (s *MultiplicativeOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitMultiplicativeOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) MultiplicativeOperation() (localctx IMultiplicativeOperationContext) {
	localctx = NewMultiplicativeOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, KotlinParserRULE_multiplicativeOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2439)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KotlinParserMULT)|(1<<KotlinParserMOD)|(1<<KotlinParserDIV))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeOperationContext is an interface to support dynamic dispatch.
type ITypeOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeOperationContext differentiates from other interfaces.
	IsTypeOperationContext()
}

type TypeOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeOperationContext() *TypeOperationContext {
	var p = new(TypeOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeOperation
	return p
}

func (*TypeOperationContext) IsTypeOperationContext() {}

func NewTypeOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeOperationContext {
	var p = new(TypeOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeOperation

	return p
}

func (s *TypeOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeOperationContext) AS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS, 0)
}

func (s *TypeOperationContext) AS_SAFE() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS_SAFE, 0)
}

func (s *TypeOperationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *TypeOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeOperation(s)
	}
}

func (s *TypeOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeOperation(s)
	}
}

func (s *TypeOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeOperation() (localctx ITypeOperationContext) {
	localctx = NewTypeOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, KotlinParserRULE_typeOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2441)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserCOLON || _la == KotlinParserAS_SAFE || _la == KotlinParserAS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrefixUnaryOperationContext is an interface to support dynamic dispatch.
type IPrefixUnaryOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefixUnaryOperationContext differentiates from other interfaces.
	IsPrefixUnaryOperationContext()
}

type PrefixUnaryOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixUnaryOperationContext() *PrefixUnaryOperationContext {
	var p = new(PrefixUnaryOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_prefixUnaryOperation
	return p
}

func (*PrefixUnaryOperationContext) IsPrefixUnaryOperationContext() {}

func NewPrefixUnaryOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixUnaryOperationContext {
	var p = new(PrefixUnaryOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_prefixUnaryOperation

	return p
}

func (s *PrefixUnaryOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixUnaryOperationContext) INCR() antlr.TerminalNode {
	return s.GetToken(KotlinParserINCR, 0)
}

func (s *PrefixUnaryOperationContext) DECR() antlr.TerminalNode {
	return s.GetToken(KotlinParserDECR, 0)
}

func (s *PrefixUnaryOperationContext) ADD() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD, 0)
}

func (s *PrefixUnaryOperationContext) SUB() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB, 0)
}

func (s *PrefixUnaryOperationContext) EXCL() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL, 0)
}

func (s *PrefixUnaryOperationContext) Annotations() IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *PrefixUnaryOperationContext) LabelDefinition() ILabelDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabelDefinitionContext)
}

func (s *PrefixUnaryOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixUnaryOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixUnaryOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrefixUnaryOperation(s)
	}
}

func (s *PrefixUnaryOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrefixUnaryOperation(s)
	}
}

func (s *PrefixUnaryOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitPrefixUnaryOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) PrefixUnaryOperation() (localctx IPrefixUnaryOperationContext) {
	localctx = NewPrefixUnaryOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, KotlinParserRULE_prefixUnaryOperation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2450)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserINCR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2443)
			p.Match(KotlinParserINCR)
		}

	case KotlinParserDECR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2444)
			p.Match(KotlinParserDECR)
		}

	case KotlinParserADD:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2445)
			p.Match(KotlinParserADD)
		}

	case KotlinParserSUB:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2446)
			p.Match(KotlinParserSUB)
		}

	case KotlinParserEXCL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2447)
			p.Match(KotlinParserEXCL)
		}

	case KotlinParserAT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserLabelReference:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2448)
			p.Annotations()
		}

	case KotlinParserLabelDefinition:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2449)
			p.LabelDefinition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPostfixUnaryOperationContext is an interface to support dynamic dispatch.
type IPostfixUnaryOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixUnaryOperationContext differentiates from other interfaces.
	IsPostfixUnaryOperationContext()
}

type PostfixUnaryOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnaryOperationContext() *PostfixUnaryOperationContext {
	var p = new(PostfixUnaryOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnaryOperation
	return p
}

func (*PostfixUnaryOperationContext) IsPostfixUnaryOperationContext() {}

func NewPostfixUnaryOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnaryOperationContext {
	var p = new(PostfixUnaryOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnaryOperation

	return p
}

func (s *PostfixUnaryOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnaryOperationContext) INCR() antlr.TerminalNode {
	return s.GetToken(KotlinParserINCR, 0)
}

func (s *PostfixUnaryOperationContext) DECR() antlr.TerminalNode {
	return s.GetToken(KotlinParserDECR, 0)
}

func (s *PostfixUnaryOperationContext) AllEXCL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserEXCL)
}

func (s *PostfixUnaryOperationContext) EXCL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL, i)
}

func (s *PostfixUnaryOperationContext) CallSuffix() ICallSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallSuffixContext)
}

func (s *PostfixUnaryOperationContext) ArrayAccess() IArrayAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayAccessContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayAccessContext)
}

func (s *PostfixUnaryOperationContext) MemberAccessOperator() IMemberAccessOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberAccessOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberAccessOperatorContext)
}

func (s *PostfixUnaryOperationContext) PostfixUnaryExpression() IPostfixUnaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixUnaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryExpressionContext)
}

func (s *PostfixUnaryOperationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PostfixUnaryOperationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PostfixUnaryOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnaryOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnaryOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnaryOperation(s)
	}
}

func (s *PostfixUnaryOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnaryOperation(s)
	}
}

func (s *PostfixUnaryOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitPostfixUnaryOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) PostfixUnaryOperation() (localctx IPostfixUnaryOperationContext) {
	localctx = NewPostfixUnaryOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, KotlinParserRULE_postfixUnaryOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2467)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 370, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2452)
			p.Match(KotlinParserINCR)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2453)
			p.Match(KotlinParserDECR)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2454)
			p.Match(KotlinParserEXCL)
		}
		{
			p.SetState(2455)
			p.Match(KotlinParserEXCL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2456)
			p.CallSuffix()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2457)
			p.ArrayAccess()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(2461)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2458)
				p.Match(KotlinParserNL)
			}

			p.SetState(2463)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2464)
			p.MemberAccessOperator()
		}
		{
			p.SetState(2465)
			p.PostfixUnaryExpression()
		}

	}

	return localctx
}

// IMemberAccessOperatorContext is an interface to support dynamic dispatch.
type IMemberAccessOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberAccessOperatorContext differentiates from other interfaces.
	IsMemberAccessOperatorContext()
}

type MemberAccessOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberAccessOperatorContext() *MemberAccessOperatorContext {
	var p = new(MemberAccessOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_memberAccessOperator
	return p
}

func (*MemberAccessOperatorContext) IsMemberAccessOperatorContext() {}

func NewMemberAccessOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberAccessOperatorContext {
	var p = new(MemberAccessOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_memberAccessOperator

	return p
}

func (s *MemberAccessOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberAccessOperatorContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *MemberAccessOperatorContext) QUEST() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST, 0)
}

func (s *MemberAccessOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberAccessOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMemberAccessOperator(s)
	}
}

func (s *MemberAccessOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMemberAccessOperator(s)
	}
}

func (s *MemberAccessOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitMemberAccessOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) MemberAccessOperator() (localctx IMemberAccessOperatorContext) {
	localctx = NewMemberAccessOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, KotlinParserRULE_memberAccessOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2472)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2469)
			p.Match(KotlinParserDOT)
		}

	case KotlinParserQUEST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2470)
			p.Match(KotlinParserQUEST)
		}
		{
			p.SetState(2471)
			p.Match(KotlinParserDOT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModifierListContext is an interface to support dynamic dispatch.
type IModifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierListContext differentiates from other interfaces.
	IsModifierListContext()
}

type ModifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierListContext() *ModifierListContext {
	var p = new(ModifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_modifierList
	return p
}

func (*ModifierListContext) IsModifierListContext() {}

func NewModifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierListContext {
	var p = new(ModifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_modifierList

	return p
}

func (s *ModifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierListContext) AllAnnotations() []IAnnotationsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem())
	var tst = make([]IAnnotationsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsContext)
		}
	}

	return tst
}

func (s *ModifierListContext) Annotations(i int) IAnnotationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsContext)
}

func (s *ModifierListContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *ModifierListContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ModifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterModifierList(s)
	}
}

func (s *ModifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitModifierList(s)
	}
}

func (s *ModifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitModifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ModifierList() (localctx IModifierListContext) {
	localctx = NewModifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, KotlinParserRULE_modifierList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2476)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(2476)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case KotlinParserAT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserLabelReference:
				{
					p.SetState(2474)
					p.Annotations()
				}

			case KotlinParserIN, KotlinParserOUT, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED:
				{
					p.SetState(2475)
					p.Modifier()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2478)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 373, p.GetParserRuleContext())
	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) ClassModifier() IClassModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassModifierContext)
}

func (s *ModifierContext) MemberModifier() IMemberModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *ModifierContext) VisibilityModifier() IVisibilityModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVisibilityModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVisibilityModifierContext)
}

func (s *ModifierContext) VarianceAnnotation() IVarianceAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarianceAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarianceAnnotationContext)
}

func (s *ModifierContext) FunctionModifier() IFunctionModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionModifierContext)
}

func (s *ModifierContext) PropertyModifier() IPropertyModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyModifierContext)
}

func (s *ModifierContext) InheritanceModifier() IInheritanceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInheritanceModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInheritanceModifierContext)
}

func (s *ModifierContext) ParameterModifier() IParameterModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterModifierContext)
}

func (s *ModifierContext) TypeParameterModifier() ITypeParameterModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterModifierContext)
}

func (s *ModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (s *ModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, KotlinParserRULE_modifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2489)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER:
		{
			p.SetState(2480)
			p.ClassModifier()
		}

	case KotlinParserOVERRIDE, KotlinParserLATEINIT:
		{
			p.SetState(2481)
			p.MemberModifier()
		}

	case KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL:
		{
			p.SetState(2482)
			p.VisibilityModifier()
		}

	case KotlinParserIN, KotlinParserOUT:
		{
			p.SetState(2483)
			p.VarianceAnnotation()
		}

	case KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND:
		{
			p.SetState(2484)
			p.FunctionModifier()
		}

	case KotlinParserCONST:
		{
			p.SetState(2485)
			p.PropertyModifier()
		}

	case KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN:
		{
			p.SetState(2486)
			p.InheritanceModifier()
		}

	case KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE:
		{
			p.SetState(2487)
			p.ParameterModifier()
		}

	case KotlinParserREIFIED:
		{
			p.SetState(2488)
			p.TypeParameterModifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 375, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2491)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2496)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 375, p.GetParserRuleContext())
	}

	return localctx
}

// IClassModifierContext is an interface to support dynamic dispatch.
type IClassModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassModifierContext differentiates from other interfaces.
	IsClassModifierContext()
}

type ClassModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassModifierContext() *ClassModifierContext {
	var p = new(ClassModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_classModifier
	return p
}

func (*ClassModifierContext) IsClassModifierContext() {}

func NewClassModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassModifierContext {
	var p = new(ClassModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classModifier

	return p
}

func (s *ClassModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassModifierContext) ENUM() antlr.TerminalNode {
	return s.GetToken(KotlinParserENUM, 0)
}

func (s *ClassModifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEALED, 0)
}

func (s *ClassModifierContext) ANNOTATION() antlr.TerminalNode {
	return s.GetToken(KotlinParserANNOTATION, 0)
}

func (s *ClassModifierContext) DATA() antlr.TerminalNode {
	return s.GetToken(KotlinParserDATA, 0)
}

func (s *ClassModifierContext) INNER() antlr.TerminalNode {
	return s.GetToken(KotlinParserINNER, 0)
}

func (s *ClassModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassModifier(s)
	}
}

func (s *ClassModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassModifier(s)
	}
}

func (s *ClassModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitClassModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ClassModifier() (localctx IClassModifierContext) {
	localctx = NewClassModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, KotlinParserRULE_classModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2497)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KotlinParserENUM-108))|(1<<(KotlinParserSEALED-108))|(1<<(KotlinParserANNOTATION-108))|(1<<(KotlinParserDATA-108))|(1<<(KotlinParserINNER-108)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMemberModifierContext is an interface to support dynamic dispatch.
type IMemberModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberModifierContext differentiates from other interfaces.
	IsMemberModifierContext()
}

type MemberModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberModifierContext() *MemberModifierContext {
	var p = new(MemberModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_memberModifier
	return p
}

func (*MemberModifierContext) IsMemberModifierContext() {}

func NewMemberModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberModifierContext {
	var p = new(MemberModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_memberModifier

	return p
}

func (s *MemberModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberModifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(KotlinParserOVERRIDE, 0)
}

func (s *MemberModifierContext) LATEINIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserLATEINIT, 0)
}

func (s *MemberModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMemberModifier(s)
	}
}

func (s *MemberModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMemberModifier(s)
	}
}

func (s *MemberModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitMemberModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) MemberModifier() (localctx IMemberModifierContext) {
	localctx = NewMemberModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, KotlinParserRULE_memberModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2499)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserOVERRIDE || _la == KotlinParserLATEINIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVisibilityModifierContext is an interface to support dynamic dispatch.
type IVisibilityModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVisibilityModifierContext differentiates from other interfaces.
	IsVisibilityModifierContext()
}

type VisibilityModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilityModifierContext() *VisibilityModifierContext {
	var p = new(VisibilityModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_visibilityModifier
	return p
}

func (*VisibilityModifierContext) IsVisibilityModifierContext() {}

func NewVisibilityModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilityModifierContext {
	var p = new(VisibilityModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_visibilityModifier

	return p
}

func (s *VisibilityModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VisibilityModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserPUBLIC, 0)
}

func (s *VisibilityModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPRIVATE, 0)
}

func (s *VisibilityModifierContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERNAL, 0)
}

func (s *VisibilityModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROTECTED, 0)
}

func (s *VisibilityModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilityModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVisibilityModifier(s)
	}
}

func (s *VisibilityModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVisibilityModifier(s)
	}
}

func (s *VisibilityModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitVisibilityModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) VisibilityModifier() (localctx IVisibilityModifierContext) {
	localctx = NewVisibilityModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, KotlinParserRULE_visibilityModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2501)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(KotlinParserPUBLIC-104))|(1<<(KotlinParserPRIVATE-104))|(1<<(KotlinParserPROTECTED-104))|(1<<(KotlinParserINTERNAL-104)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVarianceAnnotationContext is an interface to support dynamic dispatch.
type IVarianceAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarianceAnnotationContext differentiates from other interfaces.
	IsVarianceAnnotationContext()
}

type VarianceAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarianceAnnotationContext() *VarianceAnnotationContext {
	var p = new(VarianceAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_varianceAnnotation
	return p
}

func (*VarianceAnnotationContext) IsVarianceAnnotationContext() {}

func NewVarianceAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarianceAnnotationContext {
	var p = new(VarianceAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_varianceAnnotation

	return p
}

func (s *VarianceAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *VarianceAnnotationContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *VarianceAnnotationContext) OUT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOUT, 0)
}

func (s *VarianceAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarianceAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarianceAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVarianceAnnotation(s)
	}
}

func (s *VarianceAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVarianceAnnotation(s)
	}
}

func (s *VarianceAnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitVarianceAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) VarianceAnnotation() (localctx IVarianceAnnotationContext) {
	localctx = NewVarianceAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, KotlinParserRULE_varianceAnnotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2503)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIN || _la == KotlinParserOUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFunctionModifierContext is an interface to support dynamic dispatch.
type IFunctionModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionModifierContext differentiates from other interfaces.
	IsFunctionModifierContext()
}

type FunctionModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionModifierContext() *FunctionModifierContext {
	var p = new(FunctionModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_functionModifier
	return p
}

func (*FunctionModifierContext) IsFunctionModifierContext() {}

func NewFunctionModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionModifierContext {
	var p = new(FunctionModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionModifier

	return p
}

func (s *FunctionModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionModifierContext) TAILREC() antlr.TerminalNode {
	return s.GetToken(KotlinParserTAILREC, 0)
}

func (s *FunctionModifierContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPERATOR, 0)
}

func (s *FunctionModifierContext) INFIX() antlr.TerminalNode {
	return s.GetToken(KotlinParserINFIX, 0)
}

func (s *FunctionModifierContext) INLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINLINE, 0)
}

func (s *FunctionModifierContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXTERNAL, 0)
}

func (s *FunctionModifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *FunctionModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionModifier(s)
	}
}

func (s *FunctionModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionModifier(s)
	}
}

func (s *FunctionModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitFunctionModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) FunctionModifier() (localctx IFunctionModifierContext) {
	localctx = NewFunctionModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, KotlinParserRULE_functionModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2505)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(KotlinParserTAILREC-113))|(1<<(KotlinParserOPERATOR-113))|(1<<(KotlinParserINLINE-113))|(1<<(KotlinParserINFIX-113))|(1<<(KotlinParserEXTERNAL-113))|(1<<(KotlinParserSUSPEND-113)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPropertyModifierContext is an interface to support dynamic dispatch.
type IPropertyModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyModifierContext differentiates from other interfaces.
	IsPropertyModifierContext()
}

type PropertyModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyModifierContext() *PropertyModifierContext {
	var p = new(PropertyModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyModifier
	return p
}

func (*PropertyModifierContext) IsPropertyModifierContext() {}

func NewPropertyModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyModifierContext {
	var p = new(PropertyModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyModifier

	return p
}

func (s *PropertyModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyModifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONST, 0)
}

func (s *PropertyModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyModifier(s)
	}
}

func (s *PropertyModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyModifier(s)
	}
}

func (s *PropertyModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitPropertyModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) PropertyModifier() (localctx IPropertyModifierContext) {
	localctx = NewPropertyModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, KotlinParserRULE_propertyModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2507)
		p.Match(KotlinParserCONST)
	}

	return localctx
}

// IInheritanceModifierContext is an interface to support dynamic dispatch.
type IInheritanceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInheritanceModifierContext differentiates from other interfaces.
	IsInheritanceModifierContext()
}

type InheritanceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceModifierContext() *InheritanceModifierContext {
	var p = new(InheritanceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_inheritanceModifier
	return p
}

func (*InheritanceModifierContext) IsInheritanceModifierContext() {}

func NewInheritanceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceModifierContext {
	var p = new(InheritanceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_inheritanceModifier

	return p
}

func (s *InheritanceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(KotlinParserABSTRACT, 0)
}

func (s *InheritanceModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINAL, 0)
}

func (s *InheritanceModifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPEN, 0)
}

func (s *InheritanceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritanceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInheritanceModifier(s)
	}
}

func (s *InheritanceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInheritanceModifier(s)
	}
}

func (s *InheritanceModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitInheritanceModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) InheritanceModifier() (localctx IInheritanceModifierContext) {
	localctx = NewInheritanceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, KotlinParserRULE_inheritanceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2509)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-120)&-(0x1f+1)) == 0 && ((1<<uint((_la-120)))&((1<<(KotlinParserABSTRACT-120))|(1<<(KotlinParserFINAL-120))|(1<<(KotlinParserOPEN-120)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IParameterModifierContext is an interface to support dynamic dispatch.
type IParameterModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterModifierContext differentiates from other interfaces.
	IsParameterModifierContext()
}

type ParameterModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterModifierContext() *ParameterModifierContext {
	var p = new(ParameterModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterModifier
	return p
}

func (*ParameterModifierContext) IsParameterModifierContext() {}

func NewParameterModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterModifierContext {
	var p = new(ParameterModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameterModifier

	return p
}

func (s *ParameterModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterModifierContext) VARARG() antlr.TerminalNode {
	return s.GetToken(KotlinParserVARARG, 0)
}

func (s *ParameterModifierContext) NOINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOINLINE, 0)
}

func (s *ParameterModifierContext) CROSSINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCROSSINLINE, 0)
}

func (s *ParameterModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameterModifier(s)
	}
}

func (s *ParameterModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameterModifier(s)
	}
}

func (s *ParameterModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitParameterModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) ParameterModifier() (localctx IParameterModifierContext) {
	localctx = NewParameterModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, KotlinParserRULE_parameterModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2511)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(KotlinParserVARARG-125))|(1<<(KotlinParserNOINLINE-125))|(1<<(KotlinParserCROSSINLINE-125)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeParameterModifierContext is an interface to support dynamic dispatch.
type ITypeParameterModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterModifierContext differentiates from other interfaces.
	IsTypeParameterModifierContext()
}

type TypeParameterModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterModifierContext() *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameterModifier
	return p
}

func (*TypeParameterModifierContext) IsTypeParameterModifierContext() {}

func NewTypeParameterModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameterModifier

	return p
}

func (s *TypeParameterModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterModifierContext) REIFIED() antlr.TerminalNode {
	return s.GetToken(KotlinParserREIFIED, 0)
}

func (s *TypeParameterModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameterModifier(s)
	}
}

func (s *TypeParameterModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameterModifier(s)
	}
}

func (s *TypeParameterModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitTypeParameterModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) TypeParameterModifier() (localctx ITypeParameterModifierContext) {
	localctx = NewTypeParameterModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, KotlinParserRULE_typeParameterModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2513)
		p.Match(KotlinParserREIFIED)
	}

	return localctx
}

// ILabelDefinitionContext is an interface to support dynamic dispatch.
type ILabelDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelDefinitionContext differentiates from other interfaces.
	IsLabelDefinitionContext()
}

type LabelDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelDefinitionContext() *LabelDefinitionContext {
	var p = new(LabelDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_labelDefinition
	return p
}

func (*LabelDefinitionContext) IsLabelDefinitionContext() {}

func NewLabelDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelDefinitionContext {
	var p = new(LabelDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_labelDefinition

	return p
}

func (s *LabelDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelDefinitionContext) LabelDefinition() antlr.TerminalNode {
	return s.GetToken(KotlinParserLabelDefinition, 0)
}

func (s *LabelDefinitionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LabelDefinitionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LabelDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLabelDefinition(s)
	}
}

func (s *LabelDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLabelDefinition(s)
	}
}

func (s *LabelDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitLabelDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) LabelDefinition() (localctx ILabelDefinitionContext) {
	localctx = NewLabelDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, KotlinParserRULE_labelDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2515)
		p.Match(KotlinParserLabelDefinition)
	}
	p.SetState(2519)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 376, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2516)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2521)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 376, p.GetParserRuleContext())
	}

	return localctx
}

// IAnnotationsContext is an interface to support dynamic dispatch.
type IAnnotationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationsContext differentiates from other interfaces.
	IsAnnotationsContext()
}

type AnnotationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationsContext() *AnnotationsContext {
	var p = new(AnnotationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotations
	return p
}

func (*AnnotationsContext) IsAnnotationsContext() {}

func NewAnnotationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationsContext {
	var p = new(AnnotationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotations

	return p
}

func (s *AnnotationsContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationsContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationsContext) AnnotationList() IAnnotationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationListContext)
}

func (s *AnnotationsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotationsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotations(s)
	}
}

func (s *AnnotationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotations(s)
	}
}

func (s *AnnotationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAnnotations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Annotations() (localctx IAnnotationsContext) {
	localctx = NewAnnotationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, KotlinParserRULE_annotations)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2524)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 377, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2522)
			p.Annotation()
		}

	case 2:
		{
			p.SetState(2523)
			p.AnnotationList()
		}

	}
	p.SetState(2529)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2526)
				p.Match(KotlinParserNL)
			}

		}
		p.SetState(2531)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext())
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationUseSiteTargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationUseSiteTargetContext)
}

func (s *AnnotationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *AnnotationContext) UnescapedAnnotation() IUnescapedAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *AnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotationContext) LabelReference() antlr.TerminalNode {
	return s.GetToken(KotlinParserLabelReference, 0)
}

func (s *AnnotationContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *AnnotationContext) ValueArguments() IValueArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, KotlinParserRULE_annotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2567)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2532)
			p.AnnotationUseSiteTarget()
		}
		p.SetState(2536)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2533)
				p.Match(KotlinParserNL)
			}

			p.SetState(2538)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2539)
			p.Match(KotlinParserCOLON)
		}
		p.SetState(2543)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2540)
				p.Match(KotlinParserNL)
			}

			p.SetState(2545)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2546)
			p.UnescapedAnnotation()
		}

	case KotlinParserLabelReference:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2548)
			p.Match(KotlinParserLabelReference)
		}
		p.SetState(2556)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 382, p.GetParserRuleContext()) == 1 {
			p.SetState(2552)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2549)
					p.Match(KotlinParserNL)
				}

				p.SetState(2554)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2555)
				p.TypeArguments()
			}

		}
		p.SetState(2565)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 384, p.GetParserRuleContext()) == 1 {
			p.SetState(2561)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2558)
					p.Match(KotlinParserNL)
				}

				p.SetState(2563)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2564)
				p.ValueArguments()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotationListContext is an interface to support dynamic dispatch.
type IAnnotationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationListContext differentiates from other interfaces.
	IsAnnotationListContext()
}

type AnnotationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationListContext() *AnnotationListContext {
	var p = new(AnnotationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotationList
	return p
}

func (*AnnotationListContext) IsAnnotationListContext() {}

func NewAnnotationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationListContext {
	var p = new(AnnotationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotationList

	return p
}

func (s *AnnotationListContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationListContext) AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationUseSiteTargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationUseSiteTargetContext)
}

func (s *AnnotationListContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *AnnotationListContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *AnnotationListContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *AnnotationListContext) AllUnescapedAnnotation() []IUnescapedAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem())
	var tst = make([]IUnescapedAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnescapedAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotationListContext) UnescapedAnnotation(i int) IUnescapedAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnescapedAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *AnnotationListContext) AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT, 0)
}

func (s *AnnotationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotationList(s)
	}
}

func (s *AnnotationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotationList(s)
	}
}

func (s *AnnotationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAnnotationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) AnnotationList() (localctx IAnnotationListContext) {
	localctx = NewAnnotationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, KotlinParserRULE_annotationList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2588)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2569)
			p.AnnotationUseSiteTarget()
		}
		{
			p.SetState(2570)
			p.Match(KotlinParserCOLON)
		}
		{
			p.SetState(2571)
			p.Match(KotlinParserLSQUARE)
		}
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(KotlinParserIMPORT-58))|(1<<(KotlinParserCONSTRUCTOR-58))|(1<<(KotlinParserBY-58))|(1<<(KotlinParserCOMPANION-58))|(1<<(KotlinParserINIT-58))|(1<<(KotlinParserWHERE-58))|(1<<(KotlinParserCATCH-58))|(1<<(KotlinParserFINALLY-58)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(KotlinParserOUT-92))|(1<<(KotlinParserGETTER-92))|(1<<(KotlinParserSETTER-92))|(1<<(KotlinParserDYNAMIC-92))|(1<<(KotlinParserPUBLIC-92))|(1<<(KotlinParserPRIVATE-92))|(1<<(KotlinParserPROTECTED-92))|(1<<(KotlinParserINTERNAL-92))|(1<<(KotlinParserENUM-92))|(1<<(KotlinParserSEALED-92))|(1<<(KotlinParserANNOTATION-92))|(1<<(KotlinParserDATA-92))|(1<<(KotlinParserINNER-92))|(1<<(KotlinParserTAILREC-92))|(1<<(KotlinParserOPERATOR-92))|(1<<(KotlinParserINLINE-92))|(1<<(KotlinParserINFIX-92))|(1<<(KotlinParserEXTERNAL-92))|(1<<(KotlinParserSUSPEND-92))|(1<<(KotlinParserOVERRIDE-92))|(1<<(KotlinParserABSTRACT-92))|(1<<(KotlinParserFINAL-92))|(1<<(KotlinParserOPEN-92))|(1<<(KotlinParserCONST-92)))) != 0) || (((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(KotlinParserLATEINIT-124))|(1<<(KotlinParserVARARG-124))|(1<<(KotlinParserNOINLINE-124))|(1<<(KotlinParserCROSSINLINE-124))|(1<<(KotlinParserREIFIED-124))|(1<<(KotlinParserIdentifier-124)))) != 0) {
			{
				p.SetState(2572)
				p.UnescapedAnnotation()
			}

			p.SetState(2575)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2577)
			p.Match(KotlinParserRSQUARE)
		}

	case KotlinParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2579)
			p.Match(KotlinParserAT)
		}
		{
			p.SetState(2580)
			p.Match(KotlinParserLSQUARE)
		}
		p.SetState(2582)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(KotlinParserIMPORT-58))|(1<<(KotlinParserCONSTRUCTOR-58))|(1<<(KotlinParserBY-58))|(1<<(KotlinParserCOMPANION-58))|(1<<(KotlinParserINIT-58))|(1<<(KotlinParserWHERE-58))|(1<<(KotlinParserCATCH-58))|(1<<(KotlinParserFINALLY-58)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(KotlinParserOUT-92))|(1<<(KotlinParserGETTER-92))|(1<<(KotlinParserSETTER-92))|(1<<(KotlinParserDYNAMIC-92))|(1<<(KotlinParserPUBLIC-92))|(1<<(KotlinParserPRIVATE-92))|(1<<(KotlinParserPROTECTED-92))|(1<<(KotlinParserINTERNAL-92))|(1<<(KotlinParserENUM-92))|(1<<(KotlinParserSEALED-92))|(1<<(KotlinParserANNOTATION-92))|(1<<(KotlinParserDATA-92))|(1<<(KotlinParserINNER-92))|(1<<(KotlinParserTAILREC-92))|(1<<(KotlinParserOPERATOR-92))|(1<<(KotlinParserINLINE-92))|(1<<(KotlinParserINFIX-92))|(1<<(KotlinParserEXTERNAL-92))|(1<<(KotlinParserSUSPEND-92))|(1<<(KotlinParserOVERRIDE-92))|(1<<(KotlinParserABSTRACT-92))|(1<<(KotlinParserFINAL-92))|(1<<(KotlinParserOPEN-92))|(1<<(KotlinParserCONST-92)))) != 0) || (((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(KotlinParserLATEINIT-124))|(1<<(KotlinParserVARARG-124))|(1<<(KotlinParserNOINLINE-124))|(1<<(KotlinParserCROSSINLINE-124))|(1<<(KotlinParserREIFIED-124))|(1<<(KotlinParserIdentifier-124)))) != 0) {
			{
				p.SetState(2581)
				p.UnescapedAnnotation()
			}

			p.SetState(2584)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2586)
			p.Match(KotlinParserRSQUARE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotationUseSiteTargetContext is an interface to support dynamic dispatch.
type IAnnotationUseSiteTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationUseSiteTargetContext differentiates from other interfaces.
	IsAnnotationUseSiteTargetContext()
}

type AnnotationUseSiteTargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationUseSiteTargetContext() *AnnotationUseSiteTargetContext {
	var p = new(AnnotationUseSiteTargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_annotationUseSiteTarget
	return p
}

func (*AnnotationUseSiteTargetContext) IsAnnotationUseSiteTargetContext() {}

func NewAnnotationUseSiteTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationUseSiteTargetContext {
	var p = new(AnnotationUseSiteTargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotationUseSiteTarget

	return p
}

func (s *AnnotationUseSiteTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationUseSiteTargetContext) FIELD() antlr.TerminalNode {
	return s.GetToken(KotlinParserFIELD, 0)
}

func (s *AnnotationUseSiteTargetContext) FILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserFILE, 0)
}

func (s *AnnotationUseSiteTargetContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROPERTY, 0)
}

func (s *AnnotationUseSiteTargetContext) GET() antlr.TerminalNode {
	return s.GetToken(KotlinParserGET, 0)
}

func (s *AnnotationUseSiteTargetContext) SET() antlr.TerminalNode {
	return s.GetToken(KotlinParserSET, 0)
}

func (s *AnnotationUseSiteTargetContext) RECEIVER() antlr.TerminalNode {
	return s.GetToken(KotlinParserRECEIVER, 0)
}

func (s *AnnotationUseSiteTargetContext) PARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserPARAM, 0)
}

func (s *AnnotationUseSiteTargetContext) SETPARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserSETPARAM, 0)
}

func (s *AnnotationUseSiteTargetContext) DELEGATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserDELEGATE, 0)
}

func (s *AnnotationUseSiteTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationUseSiteTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationUseSiteTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotationUseSiteTarget(s)
	}
}

func (s *AnnotationUseSiteTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotationUseSiteTarget(s)
	}
}

func (s *AnnotationUseSiteTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAnnotationUseSiteTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) AnnotationUseSiteTarget() (localctx IAnnotationUseSiteTargetContext) {
	localctx = NewAnnotationUseSiteTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, KotlinParserRULE_annotationUseSiteTarget)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2590)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserFILE || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(KotlinParserFIELD-93))|(1<<(KotlinParserPROPERTY-93))|(1<<(KotlinParserGET-93))|(1<<(KotlinParserSET-93))|(1<<(KotlinParserRECEIVER-93))|(1<<(KotlinParserPARAM-93))|(1<<(KotlinParserSETPARAM-93))|(1<<(KotlinParserDELEGATE-93)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUnescapedAnnotationContext is an interface to support dynamic dispatch.
type IUnescapedAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnescapedAnnotationContext differentiates from other interfaces.
	IsUnescapedAnnotationContext()
}

type UnescapedAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnescapedAnnotationContext() *UnescapedAnnotationContext {
	var p = new(UnescapedAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_unescapedAnnotation
	return p
}

func (*UnescapedAnnotationContext) IsUnescapedAnnotationContext() {}

func NewUnescapedAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnescapedAnnotationContext {
	var p = new(UnescapedAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_unescapedAnnotation

	return p
}

func (s *UnescapedAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *UnescapedAnnotationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnescapedAnnotationContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *UnescapedAnnotationContext) ValueArguments() IValueArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *UnescapedAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnescapedAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnescapedAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUnescapedAnnotation(s)
	}
}

func (s *UnescapedAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUnescapedAnnotation(s)
	}
}

func (s *UnescapedAnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitUnescapedAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) UnescapedAnnotation() (localctx IUnescapedAnnotationContext) {
	localctx = NewUnescapedAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, KotlinParserRULE_unescapedAnnotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2592)
		p.Identifier()
	}
	p.SetState(2594)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLANGLE {
		{
			p.SetState(2593)
			p.TypeArguments()
		}

	}
	p.SetState(2597)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2596)
			p.ValueArguments()
		}

	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) AllSimpleIdentifier() []ISimpleIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem())
	var tst = make([]ISimpleIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleIdentifierContext)
		}
	}

	return tst
}

func (s *IdentifierContext) SimpleIdentifier(i int) ISimpleIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *IdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDOT)
}

func (s *IdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, i)
}

func (s *IdentifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IdentifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, KotlinParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2599)
		p.SimpleIdentifier()
	}
	p.SetState(2610)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 392, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2603)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2600)
					p.Match(KotlinParserNL)
				}

				p.SetState(2605)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2606)
				p.Match(KotlinParserDOT)
			}
			{
				p.SetState(2607)
				p.SimpleIdentifier()
			}

		}
		p.SetState(2612)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 392, p.GetParserRuleContext())
	}

	return localctx
}

// ISimpleIdentifierContext is an interface to support dynamic dispatch.
type ISimpleIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleIdentifierContext differentiates from other interfaces.
	IsSimpleIdentifierContext()
}

type SimpleIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdentifierContext() *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_simpleIdentifier
	return p
}

func (*SimpleIdentifierContext) IsSimpleIdentifierContext() {}

func NewSimpleIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_simpleIdentifier

	return p
}

func (s *SimpleIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(KotlinParserIdentifier, 0)
}

func (s *SimpleIdentifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(KotlinParserABSTRACT, 0)
}

func (s *SimpleIdentifierContext) ANNOTATION() antlr.TerminalNode {
	return s.GetToken(KotlinParserANNOTATION, 0)
}

func (s *SimpleIdentifierContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *SimpleIdentifierContext) CATCH() antlr.TerminalNode {
	return s.GetToken(KotlinParserCATCH, 0)
}

func (s *SimpleIdentifierContext) COMPANION() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMPANION, 0)
}

func (s *SimpleIdentifierContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *SimpleIdentifierContext) CROSSINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCROSSINLINE, 0)
}

func (s *SimpleIdentifierContext) DATA() antlr.TerminalNode {
	return s.GetToken(KotlinParserDATA, 0)
}

func (s *SimpleIdentifierContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserDYNAMIC, 0)
}

func (s *SimpleIdentifierContext) ENUM() antlr.TerminalNode {
	return s.GetToken(KotlinParserENUM, 0)
}

func (s *SimpleIdentifierContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXTERNAL, 0)
}

func (s *SimpleIdentifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINAL, 0)
}

func (s *SimpleIdentifierContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINALLY, 0)
}

func (s *SimpleIdentifierContext) GETTER() antlr.TerminalNode {
	return s.GetToken(KotlinParserGETTER, 0)
}

func (s *SimpleIdentifierContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(KotlinParserIMPORT, 0)
}

func (s *SimpleIdentifierContext) INFIX() antlr.TerminalNode {
	return s.GetToken(KotlinParserINFIX, 0)
}

func (s *SimpleIdentifierContext) INIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserINIT, 0)
}

func (s *SimpleIdentifierContext) INLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINLINE, 0)
}

func (s *SimpleIdentifierContext) INNER() antlr.TerminalNode {
	return s.GetToken(KotlinParserINNER, 0)
}

func (s *SimpleIdentifierContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERNAL, 0)
}

func (s *SimpleIdentifierContext) LATEINIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserLATEINIT, 0)
}

func (s *SimpleIdentifierContext) NOINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOINLINE, 0)
}

func (s *SimpleIdentifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPEN, 0)
}

func (s *SimpleIdentifierContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPERATOR, 0)
}

func (s *SimpleIdentifierContext) OUT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOUT, 0)
}

func (s *SimpleIdentifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(KotlinParserOVERRIDE, 0)
}

func (s *SimpleIdentifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPRIVATE, 0)
}

func (s *SimpleIdentifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROTECTED, 0)
}

func (s *SimpleIdentifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserPUBLIC, 0)
}

func (s *SimpleIdentifierContext) REIFIED() antlr.TerminalNode {
	return s.GetToken(KotlinParserREIFIED, 0)
}

func (s *SimpleIdentifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEALED, 0)
}

func (s *SimpleIdentifierContext) TAILREC() antlr.TerminalNode {
	return s.GetToken(KotlinParserTAILREC, 0)
}

func (s *SimpleIdentifierContext) SETTER() antlr.TerminalNode {
	return s.GetToken(KotlinParserSETTER, 0)
}

func (s *SimpleIdentifierContext) VARARG() antlr.TerminalNode {
	return s.GetToken(KotlinParserVARARG, 0)
}

func (s *SimpleIdentifierContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHERE, 0)
}

func (s *SimpleIdentifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONST, 0)
}

func (s *SimpleIdentifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *SimpleIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSimpleIdentifier(s)
	}
}

func (s *SimpleIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSimpleIdentifier(s)
	}
}

func (s *SimpleIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitSimpleIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) SimpleIdentifier() (localctx ISimpleIdentifierContext) {
	localctx = NewSimpleIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, KotlinParserRULE_simpleIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2613)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(KotlinParserIMPORT-58))|(1<<(KotlinParserCONSTRUCTOR-58))|(1<<(KotlinParserBY-58))|(1<<(KotlinParserCOMPANION-58))|(1<<(KotlinParserINIT-58))|(1<<(KotlinParserWHERE-58))|(1<<(KotlinParserCATCH-58))|(1<<(KotlinParserFINALLY-58)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(KotlinParserOUT-92))|(1<<(KotlinParserGETTER-92))|(1<<(KotlinParserSETTER-92))|(1<<(KotlinParserDYNAMIC-92))|(1<<(KotlinParserPUBLIC-92))|(1<<(KotlinParserPRIVATE-92))|(1<<(KotlinParserPROTECTED-92))|(1<<(KotlinParserINTERNAL-92))|(1<<(KotlinParserENUM-92))|(1<<(KotlinParserSEALED-92))|(1<<(KotlinParserANNOTATION-92))|(1<<(KotlinParserDATA-92))|(1<<(KotlinParserINNER-92))|(1<<(KotlinParserTAILREC-92))|(1<<(KotlinParserOPERATOR-92))|(1<<(KotlinParserINLINE-92))|(1<<(KotlinParserINFIX-92))|(1<<(KotlinParserEXTERNAL-92))|(1<<(KotlinParserSUSPEND-92))|(1<<(KotlinParserOVERRIDE-92))|(1<<(KotlinParserABSTRACT-92))|(1<<(KotlinParserFINAL-92))|(1<<(KotlinParserOPEN-92))|(1<<(KotlinParserCONST-92)))) != 0) || (((_la-124)&-(0x1f+1)) == 0 && ((1<<uint((_la-124)))&((1<<(KotlinParserLATEINIT-124))|(1<<(KotlinParserVARARG-124))|(1<<(KotlinParserNOINLINE-124))|(1<<(KotlinParserCROSSINLINE-124))|(1<<(KotlinParserREIFIED-124))|(1<<(KotlinParserIdentifier-124)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISemiContext is an interface to support dynamic dispatch.
type ISemiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSemiContext differentiates from other interfaces.
	IsSemiContext()
}

type SemiContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemiContext() *SemiContext {
	var p = new(SemiContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_semi
	return p
}

func (*SemiContext) IsSemiContext() {}

func NewSemiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SemiContext {
	var p = new(SemiContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_semi

	return p
}

func (s *SemiContext) GetParser() antlr.Parser { return s.parser }

func (s *SemiContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SemiContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SemiContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *SemiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SemiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SemiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSemi(s)
	}
}

func (s *SemiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSemi(s)
	}
}

func (s *SemiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitSemi(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Semi() (localctx ISemiContext) {
	localctx = NewSemiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, KotlinParserRULE_semi)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2633)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 396, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2616)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(2615)
					p.Match(KotlinParserNL)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(2618)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 393, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2623)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2620)
				p.Match(KotlinParserNL)
			}

			p.SetState(2625)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2626)
			p.Match(KotlinParserSEMICOLON)
		}
		p.SetState(2630)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 395, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2627)
					p.Match(KotlinParserNL)
				}

			}
			p.SetState(2632)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 395, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IAnysemiContext is an interface to support dynamic dispatch.
type IAnysemiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnysemiContext differentiates from other interfaces.
	IsAnysemiContext()
}

type AnysemiContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnysemiContext() *AnysemiContext {
	var p = new(AnysemiContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KotlinParserRULE_anysemi
	return p
}

func (*AnysemiContext) IsAnysemiContext() {}

func NewAnysemiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnysemiContext {
	var p = new(AnysemiContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_anysemi

	return p
}

func (s *AnysemiContext) GetParser() antlr.Parser { return s.parser }

func (s *AnysemiContext) NL() antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, 0)
}

func (s *AnysemiContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *AnysemiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnysemiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnysemiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnysemi(s)
	}
}

func (s *AnysemiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnysemi(s)
	}
}

func (s *AnysemiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KotlinParserVisitor:
		return t.VisitAnysemi(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KotlinParser) Anysemi() (localctx IAnysemiContext) {
	localctx = NewAnysemiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, KotlinParserRULE_anysemi)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2635)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserNL || _la == KotlinParserSEMICOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
